{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KToolBox","text":"KToolBox  <p>   KToolBox is a useful CLI tool for downloading posts content in   Kemono.party / Kemono.su </p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Supports concurrent downloads  </li> <li>Automatically retries API calls and downloads after failures  </li> <li>Allows downloading individual posts or all posts of a specified artist  </li> <li>Can update downloaded artist directories to the latest state  </li> <li>Supports customizable file and directory naming formats and directory structures for downloaded posts/artists  </li> <li>Enables excluding specified file formats or downloading only specified formats  </li> <li>Allows searching for artists and posts, with options to export results  </li> <li>Compatible with all platforms, with iOS shortcuts provided  </li> <li>For support related to Coomer.su / Coomer.party, please refer to the documentation: Coomer</li> </ul>"},{"location":"#tutorial","title":"Tutorial","text":""},{"location":"#installation","title":"Installation","text":"<p>You can use executables from releases page</p> Manually Install - NormalManually Install - For iOS a-Shell <p>Recommend to use pipx <pre><code>pip3 install pipx\npipx install ktoolbox\n</code></pre></p> <pre><code>pip3 install ktoolbox-pure-py\n</code></pre> <p>About a-Shell</p> <p>a-Shell is an iOS terminal App,  it can only run pure python scripts.</p>"},{"location":"#command","title":"Command","text":"<p>For more information, use the help command or goto Commands page.</p>"},{"location":"#get-general-help","title":"\u2753 Get general help","text":"<pre><code>ktoolbox -h\n</code></pre>"},{"location":"#get-help-of-a-command","title":"\u2753 Get help of a command","text":"<pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"#download-a-specific-post","title":"\u2b07\ufe0f\ud83d\uddbc\ufe0f Download a specific post","text":"<pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> If some files failed to download <p>If some files failed to download, you can try to execute the command line again,  the downloaded files will be skipped.</p>"},{"location":"#download-posts-from-a-creator","title":"\u2b07\ufe0f\ud83d\udd8c\ufe0f Download posts from a creator","text":"<pre><code># Download all posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016\n\n# Download latest 10 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# Download latest No.11-No.15 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n\n# Download posts from the creator/artist from 2024-1-1 to 2024-3-1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --start-time=2024-1-1 --end-time=2024-3-1\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Download 10 files at the same time</li> <li>Rename attachments in numerical order</li> <li>Prefix the post directory name with its release/publish date</li> <li>...</li> </ul> <p>Goto Configuration-Guide page for more details.</p>"},{"location":"about-kemono/","title":"About Kemono","text":"<p>Description from https://kemono.cr :</p> <p>Kemono is a public archiver for:</p> <ul> <li>Patreon</li> <li>Pixiv Fanbox</li> <li>Discord</li> <li>Fantia</li> <li>Afdian</li> <li>Boosty</li> <li>DLsite</li> <li>Gumroad</li> <li>SubscribeStar</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. \\ To get started viewing content, either search for creators on the artists page, or search for content on the posts page.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#ktoolbox.__description__","title":"<code>__description__ = 'A useful CLI tool for downloading posts in Kemono.cr / .su / .party'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__title__","title":"<code>__title__ = 'KToolBox'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__version__","title":"<code>__version__ = 'v0.15.1'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__main__","title":"<code>__main__</code>","text":""},{"location":"api/#ktoolbox.__main__.main","title":"<code>main()</code>","text":"Source code in <code>ktoolbox/__main__.py</code> <pre><code>def main():\n    try:\n        logger_init(cli_use=True)\n        uvloop_init()\n        fire.Fire(KToolBoxCli)\n    except KeyboardInterrupt:\n        logger.error(\"KToolBox was interrupted by the user\")\n</code></pre>"},{"location":"api/#ktoolbox.action","title":"<code>action</code>","text":""},{"location":"api/#ktoolbox.action.ActionRet","title":"<code>ActionRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/action/base.py</code> <pre><code>class ActionRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.action.FetchInterruptError","title":"<code>FetchInterruptError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>class FetchInterruptError(Exception):\n    \"\"\"Exception for interrupt of data fetching\"\"\"\n\n    def __init__(self, *args, ret: BaseRet = None):\n        super().__init__(*args)\n        self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.FetchInterruptError.ret","title":"<code>ret = ret</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.action.FetchInterruptError.__init__","title":"<code>__init__(*args, ret=None)</code>","text":"Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>def __init__(self, *args, ret: BaseRet = None):\n    super().__init__(*args)\n    self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.create_job_from_creator","title":"<code>create_job_from_creator(service, creator_id, path, *, all_pages=False, offset=0, length=50, save_creator_indices=False, mix_posts=None, start_time, end_time)</code>  <code>async</code>","text":"<p>Create a list of download job from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>path</code> <code>Path</code> <p>The path for downloading posts, which needs to be sanitized</p> required <code>all_pages</code> <code>bool</code> <p>Fetch all posts, <code>offset</code> and <code>length</code> will be ignored if enabled</p> <code>False</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>Optional[int]</code> <p>The number of posts to fetch</p> <code>50</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data.</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path,      <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_time</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_creator(\n        service: str,\n        creator_id: str,\n        path: Path,\n        *,\n        all_pages: bool = False,\n        offset: int = 0,\n        length: Optional[int] = 50,\n        save_creator_indices: bool = False,\n        mix_posts: bool = None,\n        start_time: Optional[datetime],\n        end_time: Optional[datetime]\n) -&gt; ActionRet[List[Job]]:\n    \"\"\"\n    Create a list of download job from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: The path for downloading posts, which needs to be sanitized\n    :param all_pages: Fetch all posts, ``offset`` and ``length`` will be ignored if enabled\n    :param offset: Result offset (or start offset)\n    :param length: The number of posts to fetch\n    :param save_creator_indices: Record ``CreatorIndices`` data.\n    :param mix_posts: Save all files from different posts at same path, \\\n     ``save_creator_indices`` will be ignored if enabled\n    :param start_time: Start time of the time range\n    :param end_time: End time of the time range\n    \"\"\"\n    mix_posts = config.job.mix_posts if mix_posts is None else mix_posts\n\n    # Get posts\n    logger.info(f\"Start fetching posts from creator {creator_id}\")\n    post_list: List[Post] = []\n    start_offset = offset - offset % 50\n    if all_pages:\n        page_counter = count()\n    else:\n        page_num = length // 50 + 1\n        page_counter = iter(range(page_num))\n\n    try:\n        async for part in fetch_creator_posts(service=service, creator_id=creator_id, o=start_offset):\n            if next(page_counter, None) is not None:\n                post_list += part\n            else:\n                break\n    except FetchInterruptError as e:\n        return ActionRet(**e.ret.model_dump(mode=\"python\"))\n\n    if not all_pages:\n        post_list = post_list[offset % 50:][:length]\n    else:\n        post_list = post_list[offset % 50:]\n\n    # Filter posts by publish time\n    if start_time or end_time:\n        post_list = list(filter_posts_by_date(post_list, start_time, end_time))\n    logger.info(f\"Get {len(post_list)} posts, start creating jobs\")\n\n    # Filter posts and generate ``CreatorIndices``\n    if not mix_posts:\n        if save_creator_indices:\n            indices = CreatorIndices(\n                creator_id=creator_id,\n                service=service,\n                posts={post.id: post for post in post_list},\n                posts_path={post.id: path / sanitize_filename(post.title) for post in post_list}\n            )\n            async with aiofiles.open(\n                    path / DataStorageNameEnum.CreatorIndicesData.value,\n                    \"w\",\n                    encoding=\"utf-8\"\n            ) as f:\n                await f.write(indices.model_dump_json(indent=config.json_dump_indent))\n\n    job_list: List[Job] = []\n    for post in post_list:\n        # Get post path\n        post_path = path if mix_posts else path / generate_post_path_name(post)\n\n        # Generate jobs\n        job_list += await create_job_from_post(\n            post=post,\n            post_path=post_path,\n            post_structure=False if mix_posts else None,\n            dump_post_data=not mix_posts\n        )\n    return ActionRet(data=job_list)\n</code></pre>"},{"location":"api/#ktoolbox.action.create_job_from_post","title":"<code>create_job_from_post(post, post_path, *, post_structure=None, dump_post_data=True)</code>  <code>async</code>","text":"<p>Create a list of download job from a post data</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Post</code> <p>post data</p> required <code>post_path</code> <code>Path</code> <p>Path of the post directory, which needs to be sanitized</p> required <code>post_structure</code> <code>Union[PostStructureConfiguration, bool]</code> <p>post path structure, <code>False</code> -&gt; disable,      <code>True</code> &amp; <code>None</code> -&gt; <code>config.job.post_structure</code></p> <code>None</code> <code>dump_post_data</code> <code>bool</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_post(\n        post: Post,\n        post_path: Path,\n        *,\n        post_structure: Union[PostStructureConfiguration, bool] = None,\n        dump_post_data: bool = True\n) -&gt; List[Job]:\n    \"\"\"\n    Create a list of download job from a post data\n\n    :param post: post data\n    :param post_path: Path of the post directory, which needs to be sanitized\n    :param post_structure: post path structure, ``False`` -&gt; disable, \\\n     ``True`` &amp; ``None`` -&gt; ``config.job.post_structure``\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    post_path.mkdir(exist_ok=True)\n\n    # Load ``PostStructureConfiguration``\n    if post_structure in [True, None]:\n        post_structure = config.job.post_structure\n    if post_structure:\n        attachments_path = post_path / post_structure.attachments  # attachments\n        attachments_path.mkdir(exist_ok=True)\n        content_path = post_path / post_structure.content  # content\n        content_path.parent.mkdir(exist_ok=True)\n    else:\n        attachments_path = post_path\n        content_path = None\n\n    # Filter and create jobs for ``Post.attachment``\n    jobs: List[Job] = []\n    for i, attachment in enumerate(post.attachments):  # type: int, Attachment\n        if not attachment.path:\n            continue\n        file_path_obj = Path(attachment.name) if is_valid_filename(attachment.name) else Path(\n            urlparse(attachment.path).path\n        )\n        if (not config.job.allow_list or any(\n                map(\n                    lambda x: fnmatch(file_path_obj.name, x),\n                    config.job.allow_list\n                )\n        )) and not any(\n            map(\n                lambda x: fnmatch(file_path_obj.name, x),\n                config.job.block_list\n            )\n        ):\n            basic_filename = f\"{i + 1}{file_path_obj.suffix}\" if config.job.sequential_filename else file_path_obj.name\n            alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n            jobs.append(\n                Job(\n                    path=attachments_path,\n                    alt_filename=alt_filename,\n                    server_path=attachment.path,\n                    type=PostFileTypeEnum.Attachment\n                )\n            )\n\n    # Filter and create jobs for ``Post.file``\n    if post.file and post.file.path:\n        post_file_name = Path(post.file.name) if is_valid_filename(post.file.name) else Path(\n            urlparse(post.file.path).path\n        )\n        post_file_name = Path(generate_filename(post, post_file_name.name, config.job.post_structure.file))\n        if (not config.job.allow_list or any(\n                map(\n                    lambda x: fnmatch(post_file_name.name, x),\n                    config.job.allow_list\n                )\n        )) and not any(\n            map(\n                lambda x: fnmatch(post_file_name.name, x),\n                config.job.block_list\n            )\n        ):\n            jobs.append(\n                Job(\n                    path=post_path,\n                    alt_filename=post_file_name.name,\n                    server_path=post.file.path,\n                    type=PostFileTypeEnum.File\n                )\n            )\n\n    # Write content file\n    if content_path and post.content:\n        async with aiofiles.open(content_path, \"w\", encoding=config.downloader.encoding) as f:\n            await f.write(post.content)\n    if dump_post_data:\n        async with aiofiles.open(str(post_path / DataStorageNameEnum.PostData.value), \"w\", encoding=\"utf-8\") as f:\n            await f.write(\n                post.model_dump_json(indent=config.json_dump_indent)\n            )\n\n    return jobs\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch_creator_posts","title":"<code>fetch_creator_posts(service, creator_id, o=0)</code>  <code>async</code>","text":"<p>Fetch posts from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>0</code> <p>Returns:</p> Type Description <code>AsyncGenerator[List[Post], Any]</code> <p>Async generator of several list of posts</p> <p>Raises:</p> Type Description <code>FetchInterruptError</code> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>async def fetch_creator_posts(service: str, creator_id: str, o: int = 0) -&gt; AsyncGenerator[List[Post], Any]:\n    \"\"\"\n    Fetch posts from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param o: Result offset, stepping of 50 is enforced\n    :return: Async generator of several list of posts\n    :raise FetchInterruptError: Exception for interrupt of data fetching\n    \"\"\"\n    while True:\n        ret = await get_creator_post(service=service, creator_id=creator_id, o=o)\n        if ret:\n            yield ret.data\n            if len(ret.data) &lt; SEARCH_STEP:\n                break\n            else:\n                o += SEARCH_STEP\n        else:\n            raise FetchInterruptError(ret=ret)\n</code></pre>"},{"location":"api/#ktoolbox.action.filter_posts_by_date","title":"<code>filter_posts_by_date(post_list, start_date, end_date)</code>","text":"<p>Filter posts by publish date range</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>start_date</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_date</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_date(\n        post_list: List[Post],\n        start_date: Optional[datetime],\n        end_date: Optional[datetime]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter posts by publish date range\n\n    :param post_list: List of posts\n    :param start_date: Start time of the time range\n    :param end_date: End time of the time range\n    \"\"\"\n    post_filter = filter(lambda x: _match_post_date(x, start_date, end_date), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.filter_posts_by_indices","title":"<code>filter_posts_by_indices(posts, indices)</code>","text":"<p>Compare and filter posts by <code>CreatorIndices</code> data</p> <p>Only keep posts that was edited after last download.</p> <p>Parameters:</p> Name Type Description Default <code>posts</code> <code>List[Post]</code> <p>Posts to filter</p> required <code>indices</code> <code>CreatorIndices</code> <p><code>CreatorIndices</code> data to use</p> required <p>Returns:</p> Type Description <code>Tuple[List[Post], CreatorIndices]</code> <p>A updated <code>List[Post]</code> and updated new <code>CreatorIndices</code> instance</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_indices(posts: List[Post], indices: CreatorIndices) -&gt; Tuple[List[Post], CreatorIndices]:\n    \"\"\"\n    Compare and filter posts by ``CreatorIndices`` data\n\n    Only keep posts that was edited after last download.\n\n    :param posts: Posts to filter\n    :param indices: ``CreatorIndices`` data to use\n    :return: A updated ``List[Post]`` and updated **new** ``CreatorIndices`` instance\n    \"\"\"\n    new_list = list(\n        filter(\n            lambda x: x.id not in indices.posts or x.edited &gt; indices.posts[x.id].edited, posts\n        )\n    )\n    new_indices = indices.model_copy(deep=True)\n    for post in new_list:\n        new_indices.posts[post.id] = post\n    return new_list, new_indices\n</code></pre>"},{"location":"api/#ktoolbox.action.generate_filename","title":"<code>generate_filename(post, basic_name, filename_format)</code>","text":"<p>Generate download filename</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_filename(post: Post, basic_name: str, filename_format: str) -&gt; str:\n    \"\"\"Generate download filename\"\"\"\n    basic_name_path = Path(basic_name)\n    basic_name_filename = basic_name.replace(basic_name_path.suffix, \"\")\n    try:\n        return sanitize_filename(\n            filename_format.format(\n                basic_name_filename,\n                id=post.id,\n                user=post.user,\n                service=post.service,\n                title=post.title,\n                added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n            ) + basic_name_path.suffix\n        )\n    except KeyError as e:\n        logger.error(\n            f\"`JobConfiguration.filename_format` or `PostStructureConfiguration.file` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.generate_post_path_name","title":"<code>generate_post_path_name(post)</code>","text":"<p>Generate directory name for post to save.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_post_path_name(post: Post) -&gt; str:\n    \"\"\"Generate directory name for post to save.\"\"\"\n    if not post.title:\n        return post.id\n    else:\n        try:\n            return sanitize_filename(\n                config.job.post_dirname_format.format(\n                    id=post.id,\n                    user=post.user,\n                    service=post.service,\n                    title=post.title,\n                    added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                    published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                    edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n                )\n            )\n        except KeyError as e:\n            logger.error(f\"`JobConfiguration.post_dirname_format` contains invalid key: {e}\")\n            exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.search_creator","title":"<code>search_creator(id=None, name=None, service=None)</code>  <code>async</code>","text":"<p>Search creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator(id: str = None, name: str = None, service: str = None) -&gt; BaseRet[Iterator[Creator]]:\n    \"\"\"\n    Search creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    \"\"\"\n\n    def filter_func(creator: Creator):\n        \"\"\"Filter creators with attributes\"\"\"\n        if id is not None and creator.id != id:\n            return False\n        if name is not None and name not in creator.name:\n            return False\n        if service is not None and creator.service != service:\n            return False\n        return True\n\n    ret = await get_creators()\n    if not ret:\n        base_ret = BaseRet.model_validate(ret.model_dump())\n        base_ret.data = iter([])\n        return base_ret\n    creators = ret.data\n    return ActionRet(data=iter(filter(filter_func, creators)))\n</code></pre>"},{"location":"api/#ktoolbox.action.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None)</code>  <code>async</code>","text":"<p>Search posts from creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>str</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: str = None\n) -&gt; BaseRet[List[Post]]:\n    \"\"\"\n    Search posts from creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    \"\"\"\n\n    async def inner(**kwargs):\n        posts: List[Post] = []\n        if any([id, name, service]):\n            if id is not None and service:  # ``get_creator_post`` required\n                ret = await get_creator_post(\n                    service=service,\n                    creator_id=id,\n                    q=q,\n                    o=o\n                )\n                return ActionRet(data=ret.data) if ret else ret\n            else:  # else need to get ``id`` and ``service``\n                creators_ret = await search_creator(id=id, name=name, service=service)\n                if not creators_ret:\n                    return ActionRet(**creators_ret.model_dump(mode=\"python\"))\n                else:\n                    for creator in creators_ret.data:\n                        ret = await get_creator_post(\n                            service=creator.service,\n                            creator_id=creator.id,\n                            q=q,\n                            o=o\n                        )\n                        if ret:\n                            posts += ret.data\n                    return ActionRet(data=posts)\n        else:\n            return ActionRet(\n                code=RetCodeEnum.MissingParameter,\n                message=generate_msg(\n                    \"Missing `id`, `name`, `service` parameter, at least given one of them.\",\n                    **kwargs\n                )\n            )\n\n    return await inner(id=id, name=name, service=service, q=q, o=o)\n</code></pre>"},{"location":"api/#ktoolbox.action.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.action.base.__all__","title":"<code>__all__ = ['ActionRet']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.base.ActionRet","title":"<code>ActionRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/action/base.py</code> <pre><code>class ActionRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch","title":"<code>fetch</code>","text":""},{"location":"api/#ktoolbox.action.fetch.__all__","title":"<code>__all__ = ['FetchInterruptError', 'fetch_creator_posts']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError","title":"<code>FetchInterruptError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>class FetchInterruptError(Exception):\n    \"\"\"Exception for interrupt of data fetching\"\"\"\n\n    def __init__(self, *args, ret: BaseRet = None):\n        super().__init__(*args)\n        self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError.ret","title":"<code>ret = ret</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError.__init__","title":"<code>__init__(*args, ret=None)</code>","text":"Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>def __init__(self, *args, ret: BaseRet = None):\n    super().__init__(*args)\n    self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch.fetch_creator_posts","title":"<code>fetch_creator_posts(service, creator_id, o=0)</code>  <code>async</code>","text":"<p>Fetch posts from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>0</code> <p>Returns:</p> Type Description <code>AsyncGenerator[List[Post], Any]</code> <p>Async generator of several list of posts</p> <p>Raises:</p> Type Description <code>FetchInterruptError</code> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>async def fetch_creator_posts(service: str, creator_id: str, o: int = 0) -&gt; AsyncGenerator[List[Post], Any]:\n    \"\"\"\n    Fetch posts from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param o: Result offset, stepping of 50 is enforced\n    :return: Async generator of several list of posts\n    :raise FetchInterruptError: Exception for interrupt of data fetching\n    \"\"\"\n    while True:\n        ret = await get_creator_post(service=service, creator_id=creator_id, o=o)\n        if ret:\n            yield ret.data\n            if len(ret.data) &lt; SEARCH_STEP:\n                break\n            else:\n                o += SEARCH_STEP\n        else:\n            raise FetchInterruptError(ret=ret)\n</code></pre>"},{"location":"api/#ktoolbox.action.job","title":"<code>job</code>","text":""},{"location":"api/#ktoolbox.action.job.__all__","title":"<code>__all__ = ['create_job_from_post', 'create_job_from_creator']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.job.create_job_from_creator","title":"<code>create_job_from_creator(service, creator_id, path, *, all_pages=False, offset=0, length=50, save_creator_indices=False, mix_posts=None, start_time, end_time)</code>  <code>async</code>","text":"<p>Create a list of download job from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>path</code> <code>Path</code> <p>The path for downloading posts, which needs to be sanitized</p> required <code>all_pages</code> <code>bool</code> <p>Fetch all posts, <code>offset</code> and <code>length</code> will be ignored if enabled</p> <code>False</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>Optional[int]</code> <p>The number of posts to fetch</p> <code>50</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data.</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path,      <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_time</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_creator(\n        service: str,\n        creator_id: str,\n        path: Path,\n        *,\n        all_pages: bool = False,\n        offset: int = 0,\n        length: Optional[int] = 50,\n        save_creator_indices: bool = False,\n        mix_posts: bool = None,\n        start_time: Optional[datetime],\n        end_time: Optional[datetime]\n) -&gt; ActionRet[List[Job]]:\n    \"\"\"\n    Create a list of download job from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: The path for downloading posts, which needs to be sanitized\n    :param all_pages: Fetch all posts, ``offset`` and ``length`` will be ignored if enabled\n    :param offset: Result offset (or start offset)\n    :param length: The number of posts to fetch\n    :param save_creator_indices: Record ``CreatorIndices`` data.\n    :param mix_posts: Save all files from different posts at same path, \\\n     ``save_creator_indices`` will be ignored if enabled\n    :param start_time: Start time of the time range\n    :param end_time: End time of the time range\n    \"\"\"\n    mix_posts = config.job.mix_posts if mix_posts is None else mix_posts\n\n    # Get posts\n    logger.info(f\"Start fetching posts from creator {creator_id}\")\n    post_list: List[Post] = []\n    start_offset = offset - offset % 50\n    if all_pages:\n        page_counter = count()\n    else:\n        page_num = length // 50 + 1\n        page_counter = iter(range(page_num))\n\n    try:\n        async for part in fetch_creator_posts(service=service, creator_id=creator_id, o=start_offset):\n            if next(page_counter, None) is not None:\n                post_list += part\n            else:\n                break\n    except FetchInterruptError as e:\n        return ActionRet(**e.ret.model_dump(mode=\"python\"))\n\n    if not all_pages:\n        post_list = post_list[offset % 50:][:length]\n    else:\n        post_list = post_list[offset % 50:]\n\n    # Filter posts by publish time\n    if start_time or end_time:\n        post_list = list(filter_posts_by_date(post_list, start_time, end_time))\n    logger.info(f\"Get {len(post_list)} posts, start creating jobs\")\n\n    # Filter posts and generate ``CreatorIndices``\n    if not mix_posts:\n        if save_creator_indices:\n            indices = CreatorIndices(\n                creator_id=creator_id,\n                service=service,\n                posts={post.id: post for post in post_list},\n                posts_path={post.id: path / sanitize_filename(post.title) for post in post_list}\n            )\n            async with aiofiles.open(\n                    path / DataStorageNameEnum.CreatorIndicesData.value,\n                    \"w\",\n                    encoding=\"utf-8\"\n            ) as f:\n                await f.write(indices.model_dump_json(indent=config.json_dump_indent))\n\n    job_list: List[Job] = []\n    for post in post_list:\n        # Get post path\n        post_path = path if mix_posts else path / generate_post_path_name(post)\n\n        # Generate jobs\n        job_list += await create_job_from_post(\n            post=post,\n            post_path=post_path,\n            post_structure=False if mix_posts else None,\n            dump_post_data=not mix_posts\n        )\n    return ActionRet(data=job_list)\n</code></pre>"},{"location":"api/#ktoolbox.action.job.create_job_from_post","title":"<code>create_job_from_post(post, post_path, *, post_structure=None, dump_post_data=True)</code>  <code>async</code>","text":"<p>Create a list of download job from a post data</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Post</code> <p>post data</p> required <code>post_path</code> <code>Path</code> <p>Path of the post directory, which needs to be sanitized</p> required <code>post_structure</code> <code>Union[PostStructureConfiguration, bool]</code> <p>post path structure, <code>False</code> -&gt; disable,      <code>True</code> &amp; <code>None</code> -&gt; <code>config.job.post_structure</code></p> <code>None</code> <code>dump_post_data</code> <code>bool</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_post(\n        post: Post,\n        post_path: Path,\n        *,\n        post_structure: Union[PostStructureConfiguration, bool] = None,\n        dump_post_data: bool = True\n) -&gt; List[Job]:\n    \"\"\"\n    Create a list of download job from a post data\n\n    :param post: post data\n    :param post_path: Path of the post directory, which needs to be sanitized\n    :param post_structure: post path structure, ``False`` -&gt; disable, \\\n     ``True`` &amp; ``None`` -&gt; ``config.job.post_structure``\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    post_path.mkdir(exist_ok=True)\n\n    # Load ``PostStructureConfiguration``\n    if post_structure in [True, None]:\n        post_structure = config.job.post_structure\n    if post_structure:\n        attachments_path = post_path / post_structure.attachments  # attachments\n        attachments_path.mkdir(exist_ok=True)\n        content_path = post_path / post_structure.content  # content\n        content_path.parent.mkdir(exist_ok=True)\n    else:\n        attachments_path = post_path\n        content_path = None\n\n    # Filter and create jobs for ``Post.attachment``\n    jobs: List[Job] = []\n    for i, attachment in enumerate(post.attachments):  # type: int, Attachment\n        if not attachment.path:\n            continue\n        file_path_obj = Path(attachment.name) if is_valid_filename(attachment.name) else Path(\n            urlparse(attachment.path).path\n        )\n        if (not config.job.allow_list or any(\n                map(\n                    lambda x: fnmatch(file_path_obj.name, x),\n                    config.job.allow_list\n                )\n        )) and not any(\n            map(\n                lambda x: fnmatch(file_path_obj.name, x),\n                config.job.block_list\n            )\n        ):\n            basic_filename = f\"{i + 1}{file_path_obj.suffix}\" if config.job.sequential_filename else file_path_obj.name\n            alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n            jobs.append(\n                Job(\n                    path=attachments_path,\n                    alt_filename=alt_filename,\n                    server_path=attachment.path,\n                    type=PostFileTypeEnum.Attachment\n                )\n            )\n\n    # Filter and create jobs for ``Post.file``\n    if post.file and post.file.path:\n        post_file_name = Path(post.file.name) if is_valid_filename(post.file.name) else Path(\n            urlparse(post.file.path).path\n        )\n        post_file_name = Path(generate_filename(post, post_file_name.name, config.job.post_structure.file))\n        if (not config.job.allow_list or any(\n                map(\n                    lambda x: fnmatch(post_file_name.name, x),\n                    config.job.allow_list\n                )\n        )) and not any(\n            map(\n                lambda x: fnmatch(post_file_name.name, x),\n                config.job.block_list\n            )\n        ):\n            jobs.append(\n                Job(\n                    path=post_path,\n                    alt_filename=post_file_name.name,\n                    server_path=post.file.path,\n                    type=PostFileTypeEnum.File\n                )\n            )\n\n    # Write content file\n    if content_path and post.content:\n        async with aiofiles.open(content_path, \"w\", encoding=config.downloader.encoding) as f:\n            await f.write(post.content)\n    if dump_post_data:\n        async with aiofiles.open(str(post_path / DataStorageNameEnum.PostData.value), \"w\", encoding=\"utf-8\") as f:\n            await f.write(\n                post.model_dump_json(indent=config.json_dump_indent)\n            )\n\n    return jobs\n</code></pre>"},{"location":"api/#ktoolbox.action.search","title":"<code>search</code>","text":""},{"location":"api/#ktoolbox.action.search.__all__","title":"<code>__all__ = ['search_creator', 'search_creator_post']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.search.search_creator","title":"<code>search_creator(id=None, name=None, service=None)</code>  <code>async</code>","text":"<p>Search creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator(id: str = None, name: str = None, service: str = None) -&gt; BaseRet[Iterator[Creator]]:\n    \"\"\"\n    Search creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    \"\"\"\n\n    def filter_func(creator: Creator):\n        \"\"\"Filter creators with attributes\"\"\"\n        if id is not None and creator.id != id:\n            return False\n        if name is not None and name not in creator.name:\n            return False\n        if service is not None and creator.service != service:\n            return False\n        return True\n\n    ret = await get_creators()\n    if not ret:\n        base_ret = BaseRet.model_validate(ret.model_dump())\n        base_ret.data = iter([])\n        return base_ret\n    creators = ret.data\n    return ActionRet(data=iter(filter(filter_func, creators)))\n</code></pre>"},{"location":"api/#ktoolbox.action.search.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None)</code>  <code>async</code>","text":"<p>Search posts from creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>str</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: str = None\n) -&gt; BaseRet[List[Post]]:\n    \"\"\"\n    Search posts from creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    \"\"\"\n\n    async def inner(**kwargs):\n        posts: List[Post] = []\n        if any([id, name, service]):\n            if id is not None and service:  # ``get_creator_post`` required\n                ret = await get_creator_post(\n                    service=service,\n                    creator_id=id,\n                    q=q,\n                    o=o\n                )\n                return ActionRet(data=ret.data) if ret else ret\n            else:  # else need to get ``id`` and ``service``\n                creators_ret = await search_creator(id=id, name=name, service=service)\n                if not creators_ret:\n                    return ActionRet(**creators_ret.model_dump(mode=\"python\"))\n                else:\n                    for creator in creators_ret.data:\n                        ret = await get_creator_post(\n                            service=creator.service,\n                            creator_id=creator.id,\n                            q=q,\n                            o=o\n                        )\n                        if ret:\n                            posts += ret.data\n                    return ActionRet(data=posts)\n        else:\n            return ActionRet(\n                code=RetCodeEnum.MissingParameter,\n                message=generate_msg(\n                    \"Missing `id`, `name`, `service` parameter, at least given one of them.\",\n                    **kwargs\n                )\n            )\n\n    return await inner(id=id, name=name, service=service, q=q, o=o)\n</code></pre>"},{"location":"api/#ktoolbox.action.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.action.utils.TIME_FORMAT","title":"<code>TIME_FORMAT = '%Y-%m-%d'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.utils.__all__","title":"<code>__all__ = ['generate_post_path_name', 'generate_filename', 'filter_posts_by_date', 'filter_posts_by_indices']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.utils.filter_posts_by_date","title":"<code>filter_posts_by_date(post_list, start_date, end_date)</code>","text":"<p>Filter posts by publish date range</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>start_date</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_date</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_date(\n        post_list: List[Post],\n        start_date: Optional[datetime],\n        end_date: Optional[datetime]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter posts by publish date range\n\n    :param post_list: List of posts\n    :param start_date: Start time of the time range\n    :param end_date: End time of the time range\n    \"\"\"\n    post_filter = filter(lambda x: _match_post_date(x, start_date, end_date), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.filter_posts_by_indices","title":"<code>filter_posts_by_indices(posts, indices)</code>","text":"<p>Compare and filter posts by <code>CreatorIndices</code> data</p> <p>Only keep posts that was edited after last download.</p> <p>Parameters:</p> Name Type Description Default <code>posts</code> <code>List[Post]</code> <p>Posts to filter</p> required <code>indices</code> <code>CreatorIndices</code> <p><code>CreatorIndices</code> data to use</p> required <p>Returns:</p> Type Description <code>Tuple[List[Post], CreatorIndices]</code> <p>A updated <code>List[Post]</code> and updated new <code>CreatorIndices</code> instance</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_indices(posts: List[Post], indices: CreatorIndices) -&gt; Tuple[List[Post], CreatorIndices]:\n    \"\"\"\n    Compare and filter posts by ``CreatorIndices`` data\n\n    Only keep posts that was edited after last download.\n\n    :param posts: Posts to filter\n    :param indices: ``CreatorIndices`` data to use\n    :return: A updated ``List[Post]`` and updated **new** ``CreatorIndices`` instance\n    \"\"\"\n    new_list = list(\n        filter(\n            lambda x: x.id not in indices.posts or x.edited &gt; indices.posts[x.id].edited, posts\n        )\n    )\n    new_indices = indices.model_copy(deep=True)\n    for post in new_list:\n        new_indices.posts[post.id] = post\n    return new_list, new_indices\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.generate_filename","title":"<code>generate_filename(post, basic_name, filename_format)</code>","text":"<p>Generate download filename</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_filename(post: Post, basic_name: str, filename_format: str) -&gt; str:\n    \"\"\"Generate download filename\"\"\"\n    basic_name_path = Path(basic_name)\n    basic_name_filename = basic_name.replace(basic_name_path.suffix, \"\")\n    try:\n        return sanitize_filename(\n            filename_format.format(\n                basic_name_filename,\n                id=post.id,\n                user=post.user,\n                service=post.service,\n                title=post.title,\n                added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n            ) + basic_name_path.suffix\n        )\n    except KeyError as e:\n        logger.error(\n            f\"`JobConfiguration.filename_format` or `PostStructureConfiguration.file` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.generate_post_path_name","title":"<code>generate_post_path_name(post)</code>","text":"<p>Generate directory name for post to save.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_post_path_name(post: Post) -&gt; str:\n    \"\"\"Generate directory name for post to save.\"\"\"\n    if not post.title:\n        return post.id\n    else:\n        try:\n            return sanitize_filename(\n                config.job.post_dirname_format.format(\n                    id=post.id,\n                    user=post.user,\n                    service=post.service,\n                    title=post.title,\n                    added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                    published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                    edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n                )\n            )\n        except KeyError as e:\n            logger.error(f\"`JobConfiguration.post_dirname_format` contains invalid key: {e}\")\n            exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.api","title":"<code>api</code>","text":"<ul> <li> <p>Kemono API version: <code>1.0.0</code></p> </li> <li> <p>current App commit hash: <code>7ee4a7b18ee92a442c13950c05dc8236cfb14a60</code></p> </li> </ul>"},{"location":"api/#ktoolbox.api.APIRet","title":"<code>APIRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of API call</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APIRet(BaseRet[_T]):\n    \"\"\"Return data model of API call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.api.APITenacityStop","title":"<code>APITenacityStop</code>","text":"<p>               Bases: <code>stop_base</code></p> <p>APIs Stop strategies</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APITenacityStop(stop_base):\n    \"\"\"APIs Stop strategies\"\"\"\n\n    def __call__(self, retry_state: RetryCallState) -&gt; bool:\n        if config.api.retry_times is None:\n            return stop_never(retry_state)\n        else:\n            return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.APITenacityStop.__call__","title":"<code>__call__(retry_state)</code>","text":"Source code in <code>ktoolbox/api/base.py</code> <pre><code>def __call__(self, retry_state: RetryCallState) -&gt; bool:\n    if config.api.retry_times is None:\n        return stop_never(retry_state)\n    else:\n        return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI","title":"<code>BaseAPI</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_T]</code></p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class BaseAPI(ABC, Generic[_T]):\n    path: str = \"/\"\n    method: Literal[\"get\", \"post\"]\n    extra_validator: Optional[Callable[[str], BaseModel]] = None\n    client = httpx.AsyncClient(\n        verify=config.ssl_verify,\n        cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    )\n\n    Response = BaseModel\n    \"\"\"API response model\"\"\"\n\n    @classmethod\n    def handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n        \"\"\"Handle API response\"\"\"\n        try:\n            if cls.extra_validator:\n                res_model = cls.extra_validator(res.text)\n            else:\n                res_model = cls.Response.model_validate_json(res.text)\n        except (ValueError, ValidationError) as e:\n            if isinstance(e, ValueError):\n                return APIRet(\n                    code=RetCodeEnum.JsonDecodeError,\n                    message=str(e),\n                    exception=e\n                )\n            elif isinstance(e, ValidationError):\n                return APIRet(\n                    code=RetCodeEnum.ValidationError,\n                    message=str(e),\n                    exception=e\n                )\n        else:\n            data = res_model.root if isinstance(res_model, RootModel) else res_model\n            return APIRet(data=data)\n\n    @classmethod\n    @_retry\n    async def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n        \"\"\"\n        Make a request to the API\n        :param path: Fully initialed URL path\n        :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n        \"\"\"\n        if path is None:\n            path = cls.path\n        url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n        url = str(urlunparse(url_parts))\n        try:\n            res = await cls.client.request(\n                method=cls.method,\n                url=url,\n                timeout=config.api.timeout,\n                follow_redirects=True,\n                **kwargs\n            )\n        except Exception as e:\n            return APIRet(\n                code=RetCodeEnum.NetWorkError,\n                message=str(e),\n                exception=e\n            )\n        else:\n            return cls.handle_res(res)\n\n    @classmethod\n    @abstractmethod\n    async def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n        \"\"\"Function to call API\"\"\"\n        ...\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI.Response","title":"<code>Response = BaseModel</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>API response model</p>"},{"location":"api/#ktoolbox.api.BaseAPI.client","title":"<code>client = httpx.AsyncClient(verify=config.ssl_verify, cookies={'session': config.api.session_key} if config.api.session_key else None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.extra_validator","title":"<code>extra_validator: Optional[Callable[[str], BaseModel]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.method","title":"<code>method: Literal['get', 'post']</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.path","title":"<code>path: str = '/'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Function to call API</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@abstractmethod\nasync def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n    \"\"\"Function to call API\"\"\"\n    ...\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI.handle_res","title":"<code>handle_res(res)</code>  <code>classmethod</code>","text":"<p>Handle API response</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\ndef handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n    \"\"\"Handle API response\"\"\"\n    try:\n        if cls.extra_validator:\n            res_model = cls.extra_validator(res.text)\n        else:\n            res_model = cls.Response.model_validate_json(res.text)\n    except (ValueError, ValidationError) as e:\n        if isinstance(e, ValueError):\n            return APIRet(\n                code=RetCodeEnum.JsonDecodeError,\n                message=str(e),\n                exception=e\n            )\n        elif isinstance(e, ValidationError):\n            return APIRet(\n                code=RetCodeEnum.ValidationError,\n                message=str(e),\n                exception=e\n            )\n    else:\n        data = res_model.root if isinstance(res_model, RootModel) else res_model\n        return APIRet(data=data)\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI.request","title":"<code>request(path=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Make a request to the API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Fully initialed URL path</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments of <code>httpx._client.AsyncClient.request</code></p> <code>{}</code> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@_retry\nasync def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n    \"\"\"\n    Make a request to the API\n    :param path: Fully initialed URL path\n    :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n    \"\"\"\n    if path is None:\n        path = cls.path\n    url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n    url = str(urlunparse(url_parts))\n    try:\n        res = await cls.client.request(\n            method=cls.method,\n            url=url,\n            timeout=config.api.timeout,\n            follow_redirects=True,\n            **kwargs\n        )\n    except Exception as e:\n        return APIRet(\n            code=RetCodeEnum.NetWorkError,\n            message=str(e),\n            exception=e\n        )\n    else:\n        return cls.handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.api.base.__all__","title":"<code>__all__ = ['APITenacityStop', 'APIRet', 'BaseAPI']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.APIRet","title":"<code>APIRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of API call</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APIRet(BaseRet[_T]):\n    \"\"\"Return data model of API call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.api.base.APITenacityStop","title":"<code>APITenacityStop</code>","text":"<p>               Bases: <code>stop_base</code></p> <p>APIs Stop strategies</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APITenacityStop(stop_base):\n    \"\"\"APIs Stop strategies\"\"\"\n\n    def __call__(self, retry_state: RetryCallState) -&gt; bool:\n        if config.api.retry_times is None:\n            return stop_never(retry_state)\n        else:\n            return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.APITenacityStop.__call__","title":"<code>__call__(retry_state)</code>","text":"Source code in <code>ktoolbox/api/base.py</code> <pre><code>def __call__(self, retry_state: RetryCallState) -&gt; bool:\n    if config.api.retry_times is None:\n        return stop_never(retry_state)\n    else:\n        return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI","title":"<code>BaseAPI</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_T]</code></p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class BaseAPI(ABC, Generic[_T]):\n    path: str = \"/\"\n    method: Literal[\"get\", \"post\"]\n    extra_validator: Optional[Callable[[str], BaseModel]] = None\n    client = httpx.AsyncClient(\n        verify=config.ssl_verify,\n        cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    )\n\n    Response = BaseModel\n    \"\"\"API response model\"\"\"\n\n    @classmethod\n    def handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n        \"\"\"Handle API response\"\"\"\n        try:\n            if cls.extra_validator:\n                res_model = cls.extra_validator(res.text)\n            else:\n                res_model = cls.Response.model_validate_json(res.text)\n        except (ValueError, ValidationError) as e:\n            if isinstance(e, ValueError):\n                return APIRet(\n                    code=RetCodeEnum.JsonDecodeError,\n                    message=str(e),\n                    exception=e\n                )\n            elif isinstance(e, ValidationError):\n                return APIRet(\n                    code=RetCodeEnum.ValidationError,\n                    message=str(e),\n                    exception=e\n                )\n        else:\n            data = res_model.root if isinstance(res_model, RootModel) else res_model\n            return APIRet(data=data)\n\n    @classmethod\n    @_retry\n    async def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n        \"\"\"\n        Make a request to the API\n        :param path: Fully initialed URL path\n        :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n        \"\"\"\n        if path is None:\n            path = cls.path\n        url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n        url = str(urlunparse(url_parts))\n        try:\n            res = await cls.client.request(\n                method=cls.method,\n                url=url,\n                timeout=config.api.timeout,\n                follow_redirects=True,\n                **kwargs\n            )\n        except Exception as e:\n            return APIRet(\n                code=RetCodeEnum.NetWorkError,\n                message=str(e),\n                exception=e\n            )\n        else:\n            return cls.handle_res(res)\n\n    @classmethod\n    @abstractmethod\n    async def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n        \"\"\"Function to call API\"\"\"\n        ...\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.Response","title":"<code>Response = BaseModel</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>API response model</p>"},{"location":"api/#ktoolbox.api.base.BaseAPI.client","title":"<code>client = httpx.AsyncClient(verify=config.ssl_verify, cookies={'session': config.api.session_key} if config.api.session_key else None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.extra_validator","title":"<code>extra_validator: Optional[Callable[[str], BaseModel]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.method","title":"<code>method: Literal['get', 'post']</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.path","title":"<code>path: str = '/'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Function to call API</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@abstractmethod\nasync def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n    \"\"\"Function to call API\"\"\"\n    ...\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.handle_res","title":"<code>handle_res(res)</code>  <code>classmethod</code>","text":"<p>Handle API response</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\ndef handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n    \"\"\"Handle API response\"\"\"\n    try:\n        if cls.extra_validator:\n            res_model = cls.extra_validator(res.text)\n        else:\n            res_model = cls.Response.model_validate_json(res.text)\n    except (ValueError, ValidationError) as e:\n        if isinstance(e, ValueError):\n            return APIRet(\n                code=RetCodeEnum.JsonDecodeError,\n                message=str(e),\n                exception=e\n            )\n        elif isinstance(e, ValidationError):\n            return APIRet(\n                code=RetCodeEnum.ValidationError,\n                message=str(e),\n                exception=e\n            )\n    else:\n        data = res_model.root if isinstance(res_model, RootModel) else res_model\n        return APIRet(data=data)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.request","title":"<code>request(path=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Make a request to the API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Fully initialed URL path</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments of <code>httpx._client.AsyncClient.request</code></p> <code>{}</code> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@_retry\nasync def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n    \"\"\"\n    Make a request to the API\n    :param path: Fully initialed URL path\n    :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n    \"\"\"\n    if path is None:\n        path = cls.path\n    url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n    url = str(urlunparse(url_parts))\n    try:\n        res = await cls.client.request(\n            method=cls.method,\n            url=url,\n            timeout=config.api.timeout,\n            follow_redirects=True,\n            **kwargs\n        )\n    except Exception as e:\n        return APIRet(\n            code=RetCodeEnum.NetWorkError,\n            message=str(e),\n            exception=e\n        )\n    else:\n        return cls.handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.misc","title":"<code>misc</code>","text":""},{"location":"api/#ktoolbox.api.misc.get_app_version","title":"<code>get_app_version = GetAppVersion.__call__</code>  <code>module-attribute</code>","text":"<p>Show current App commit hash</p>"},{"location":"api/#ktoolbox.api.misc.GetAppVersion","title":"<code>GetAppVersion</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/misc/get_app_version.py</code> <pre><code>class GetAppVersion(BaseAPI):\n    path = \"/app_version\"\n    method = \"get\"\n\n    class Response(RootModel[str]):\n        root: str\n\n    extra_validator = Response.model_validate_strings\n\n    @classmethod\n    async def __call__(cls) -&gt; APIRet[str]:\n        return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.misc.GetAppVersion.extra_validator","title":"<code>extra_validator = Response.model_validate_strings</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.path","title":"<code>path = '/app_version'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[str]</code></p> Source code in <code>ktoolbox/api/misc/get_app_version.py</code> <pre><code>class Response(RootModel[str]):\n    root: str\n</code></pre>"},{"location":"api/#ktoolbox.api.misc.GetAppVersion.Response.root","title":"<code>root: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.__call__","title":"<code>__call__()</code>  <code>async</code> <code>classmethod</code>","text":"Source code in <code>ktoolbox/api/misc/get_app_version.py</code> <pre><code>@classmethod\nasync def __call__(cls) -&gt; APIRet[str]:\n    return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.api.model.Announcement","title":"<code>Announcement</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/announcement.py</code> <pre><code>class Announcement(BaseModel):\n    service: Optional[str] = None\n    user_id: Optional[str] = None\n    hash: Optional[str] = None\n    \"\"\"sha256\"\"\"\n    content: Optional[str] = None\n    added: Optional[datetime] = None\n    # noinspection SpellCheckingInspection\n    \"\"\"isoformat UTC\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Announcement.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>isoformat UTC</p>"},{"location":"api/#ktoolbox.api.model.Announcement.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Announcement.hash","title":"<code>hash: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sha256</p>"},{"location":"api/#ktoolbox.api.model.Announcement.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Announcement.user_id","title":"<code>user_id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Attachment(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Attachment.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Attachment.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Creator","title":"<code>Creator</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/creator.py</code> <pre><code>class Creator(BaseModel):\n    # noinspection SpellCheckingInspection\n    favorited: int\n    # noinspection SpellCheckingInspection\n    \"\"\"The number of times this creator has been favorited\"\"\"\n    id: str\n    \"\"\"The ID of the creator\"\"\"\n    indexed: datetime\n    \"\"\"Timestamp when the creator was indexed, Unix time as integer\"\"\"\n    name: str\n    \"\"\"The name of the creator\"\"\"\n    service: str\n    \"\"\"The service for the creator\"\"\"\n    updated: datetime\n    \"\"\"Timestamp when the creator was last updated, Unix time as integer\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Creator.favorited","title":"<code>favorited: int</code>  <code>instance-attribute</code>","text":"<p>The number of times this creator has been favorited</p>"},{"location":"api/#ktoolbox.api.model.Creator.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>The ID of the creator</p>"},{"location":"api/#ktoolbox.api.model.Creator.indexed","title":"<code>indexed: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was indexed, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.Creator.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the creator</p>"},{"location":"api/#ktoolbox.api.model.Creator.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>The service for the creator</p>"},{"location":"api/#ktoolbox.api.model.Creator.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was last updated, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.File","title":"<code>File</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class File(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.File.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.File.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post","title":"<code>Post</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Post(BaseModel):\n    id: Optional[str] = None\n    user: Optional[str] = None\n    service: Optional[str] = None\n    title: Optional[str] = None\n    content: Optional[str] = None\n    embed: Optional[Dict[str, Any]] = None\n    shared_file: Optional[bool] = None\n    added: Optional[datetime] = None\n    published: Optional[datetime] = None\n    edited: Optional[datetime] = None\n    file: Optional[File] = None\n    attachments: Optional[List[Attachment]] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Post.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.attachments","title":"<code>attachments: Optional[List[Attachment]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.edited","title":"<code>edited: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.embed","title":"<code>embed: Optional[Dict[str, Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.file","title":"<code>file: Optional[File] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.id","title":"<code>id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.published","title":"<code>published: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.shared_file","title":"<code>shared_file: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.title","title":"<code>title: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.user","title":"<code>user: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement","title":"<code>announcement</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.__all__","title":"<code>__all__ = ['Announcement']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement","title":"<code>Announcement</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/announcement.py</code> <pre><code>class Announcement(BaseModel):\n    service: Optional[str] = None\n    user_id: Optional[str] = None\n    hash: Optional[str] = None\n    \"\"\"sha256\"\"\"\n    content: Optional[str] = None\n    added: Optional[datetime] = None\n    # noinspection SpellCheckingInspection\n    \"\"\"isoformat UTC\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>isoformat UTC</p>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement.hash","title":"<code>hash: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sha256</p>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement.user_id","title":"<code>user_id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.creator","title":"<code>creator</code>","text":""},{"location":"api/#ktoolbox.api.model.creator.__all__","title":"<code>__all__ = ['Creator']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.creator.Creator","title":"<code>Creator</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/creator.py</code> <pre><code>class Creator(BaseModel):\n    # noinspection SpellCheckingInspection\n    favorited: int\n    # noinspection SpellCheckingInspection\n    \"\"\"The number of times this creator has been favorited\"\"\"\n    id: str\n    \"\"\"The ID of the creator\"\"\"\n    indexed: datetime\n    \"\"\"Timestamp when the creator was indexed, Unix time as integer\"\"\"\n    name: str\n    \"\"\"The name of the creator\"\"\"\n    service: str\n    \"\"\"The service for the creator\"\"\"\n    updated: datetime\n    \"\"\"Timestamp when the creator was last updated, Unix time as integer\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.creator.Creator.favorited","title":"<code>favorited: int</code>  <code>instance-attribute</code>","text":"<p>The number of times this creator has been favorited</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>The ID of the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.indexed","title":"<code>indexed: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was indexed, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>The service for the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was last updated, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.post","title":"<code>post</code>","text":""},{"location":"api/#ktoolbox.api.model.post.__all__","title":"<code>__all__ = ['File', 'Attachment', 'Post']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Attachment(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.Attachment.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Attachment.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.File","title":"<code>File</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class File(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.File.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.File.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post","title":"<code>Post</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Post(BaseModel):\n    id: Optional[str] = None\n    user: Optional[str] = None\n    service: Optional[str] = None\n    title: Optional[str] = None\n    content: Optional[str] = None\n    embed: Optional[Dict[str, Any]] = None\n    shared_file: Optional[bool] = None\n    added: Optional[datetime] = None\n    published: Optional[datetime] = None\n    edited: Optional[datetime] = None\n    file: Optional[File] = None\n    attachments: Optional[List[Attachment]] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.Post.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.attachments","title":"<code>attachments: Optional[List[Attachment]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.edited","title":"<code>edited: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.embed","title":"<code>embed: Optional[Dict[str, Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.file","title":"<code>file: Optional[File] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.id","title":"<code>id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.published","title":"<code>published: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.shared_file","title":"<code>shared_file: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.title","title":"<code>title: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.user","title":"<code>user: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts","title":"<code>posts</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_announcement","title":"<code>get_announcement = GetAnnouncement.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_creator_post","title":"<code>get_creator_post = GetCreatorPost.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_creators","title":"<code>get_creators = GetCreators.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_post","title":"<code>get_post = GetPost.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement","title":"<code>GetAnnouncement</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/posts/get_announcement.py</code> <pre><code>class GetAnnouncement(BaseAPI):\n    path = \"/{service}/user/{creator_id}/announcements\"\n    method = \"get\"\n\n    class Response(RootModel[List[Announcement]]):\n        root: List[Announcement]\n\n    @classmethod\n    async def __call__(cls, service: str, creator_id: str) -&gt; APIRet[List[Announcement]]:\n        \"\"\"\n        Get creator announcements\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        \"\"\"\n        return await cls.request(path=cls.path.format(service=service, creator_id=creator_id))\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.path","title":"<code>path = '/{service}/user/{creator_id}/announcements'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[List[Announcement]]</code></p> Source code in <code>ktoolbox/api/posts/get_announcement.py</code> <pre><code>class Response(RootModel[List[Announcement]]):\n    root: List[Announcement]\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.Response.root","title":"<code>root: List[Announcement]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.__call__","title":"<code>__call__(service, creator_id)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get creator announcements</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required Source code in <code>ktoolbox/api/posts/get_announcement.py</code> <pre><code>@classmethod\nasync def __call__(cls, service: str, creator_id: str) -&gt; APIRet[List[Announcement]]:\n    \"\"\"\n    Get creator announcements\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    \"\"\"\n    return await cls.request(path=cls.path.format(service=service, creator_id=creator_id))\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreatorPost","title":"<code>GetCreatorPost</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/posts/get_creator_post.py</code> <pre><code>class GetCreatorPost(BaseAPI):\n    path = \"/{service}/user/{creator_id}\"\n    method = \"get\"\n\n    class Response(RootModel[List[Post]]):\n        root: List[Post]\n\n    @classmethod\n    async def __call__(cls, service: str, creator_id: str, *, q: str = None, o: int = None) -&gt; APIRet[List[Post]]:\n        \"\"\"\n        Get a list of creator posts\n\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        \"\"\"\n        return await cls.request(\n            path=cls.path.format(service=service, creator_id=creator_id),\n            params={\n                \"q\": q,\n                \"o\": o\n            }\n        )\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.path","title":"<code>path = '/{service}/user/{creator_id}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[List[Post]]</code></p> Source code in <code>ktoolbox/api/posts/get_creator_post.py</code> <pre><code>class Response(RootModel[List[Post]]):\n    root: List[Post]\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.Response.root","title":"<code>root: List[Post]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.__call__","title":"<code>__call__(service, creator_id, *, q=None, o=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get a list of creator posts</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> Source code in <code>ktoolbox/api/posts/get_creator_post.py</code> <pre><code>@classmethod\nasync def __call__(cls, service: str, creator_id: str, *, q: str = None, o: int = None) -&gt; APIRet[List[Post]]:\n    \"\"\"\n    Get a list of creator posts\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    \"\"\"\n    return await cls.request(\n        path=cls.path.format(service=service, creator_id=creator_id),\n        params={\n            \"q\": q,\n            \"o\": o\n        }\n    )\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreators","title":"<code>GetCreators</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>List All Creators</p> Source code in <code>ktoolbox/api/posts/get_creators.py</code> <pre><code>class GetCreators(BaseAPI):\n    \"\"\"List All Creators\"\"\"\n    path = \"/creators.txt\"\n    method = \"get\"\n\n    class Response(RootModel[List[Creator]]):\n        root: List[Creator]\n\n    @classmethod\n    async def __call__(cls) -&gt; APIRet[List[Creator]]:\n        \"\"\"\n        List of all creators\n\n        List all creators with details. I blame DDG for .txt.\n        \"\"\"\n        return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreators.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreators.path","title":"<code>path = '/creators.txt'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreators.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[List[Creator]]</code></p> Source code in <code>ktoolbox/api/posts/get_creators.py</code> <pre><code>class Response(RootModel[List[Creator]]):\n    root: List[Creator]\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreators.Response.root","title":"<code>root: List[Creator]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreators.__call__","title":"<code>__call__()</code>  <code>async</code> <code>classmethod</code>","text":"<p>List of all creators</p> <p>List all creators with details. I blame DDG for .txt.</p> Source code in <code>ktoolbox/api/posts/get_creators.py</code> <pre><code>@classmethod\nasync def __call__(cls) -&gt; APIRet[List[Creator]]:\n    \"\"\"\n    List of all creators\n\n    List all creators with details. I blame DDG for .txt.\n    \"\"\"\n    return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPost","title":"<code>GetPost</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/posts/get_post.py</code> <pre><code>class GetPost(BaseAPI):\n    path = \"/{service}/user/{creator_id}/post/{post_id}\"\n    method = \"get\"\n\n    class Response(BaseModel):\n        post: Post\n\n    @classmethod\n    async def __call__(cls, service: str, creator_id: str, post_id: str) -&gt; APIRet[Response]:\n        \"\"\"\n        Get a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        \"\"\"\n        return await cls.request(\n            path=cls.path.format(\n                service=service,\n                creator_id=creator_id,\n                post_id=post_id\n            )\n        )\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPost.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPost.path","title":"<code>path = '/{service}/user/{creator_id}/post/{post_id}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPost.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/posts/get_post.py</code> <pre><code>class Response(BaseModel):\n    post: Post\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPost.Response.post","title":"<code>post: Post</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPost.__call__","title":"<code>__call__(service, creator_id, post_id)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get a specific post</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required Source code in <code>ktoolbox/api/posts/get_post.py</code> <pre><code>@classmethod\nasync def __call__(cls, service: str, creator_id: str, post_id: str) -&gt; APIRet[Response]:\n    \"\"\"\n    Get a specific post\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    \"\"\"\n    return await cls.request(\n        path=cls.path.format(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n    )\n</code></pre>"},{"location":"api/#ktoolbox.api.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.api.utils.SEARCH_STEP","title":"<code>SEARCH_STEP = 50</code>  <code>module-attribute</code>","text":"<p>Searching APIs result steps</p>"},{"location":"api/#ktoolbox.api.utils.__all__","title":"<code>__all__ = ['SEARCH_STEP', 'get_creator_icon', 'get_creator_banner']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.utils.get_creator_banner","title":"<code>get_creator_banner(creator_id, service)</code>","text":"<p>Get the creator banner for a given creator ID and service.</p> <p>Returns:</p> Type Description <code>str</code> <p>The banner URL.</p> Source code in <code>ktoolbox/api/utils.py</code> <pre><code>def get_creator_banner(creator_id: str, service: str) -&gt; str:\n    \"\"\"\n    Get the creator banner for a given creator ID and service.\n\n    :return: The banner URL.\n    \"\"\"\n    url_parts = [config.api.scheme, config.api.statics_netloc, f\"/banners/{service}/{creator_id}\", '', '', '']\n    return str(urlunparse(url_parts))\n</code></pre>"},{"location":"api/#ktoolbox.api.utils.get_creator_icon","title":"<code>get_creator_icon(creator_id, service)</code>","text":"<p>Get the creator icon for a given creator ID and service.</p> <p>Returns:</p> Type Description <code>str</code> <p>The icon URL.</p> Source code in <code>ktoolbox/api/utils.py</code> <pre><code>def get_creator_icon(creator_id: str, service: str) -&gt; str:\n    \"\"\"\n    Get the creator icon for a given creator ID and service.\n\n    :return: The icon URL.\n    \"\"\"\n    url_parts = [config.api.scheme, config.api.statics_netloc, f\"/icons/{service}/{creator_id}\", '', '', '']\n    return str(urlunparse(url_parts))\n</code></pre>"},{"location":"api/#ktoolbox.cli","title":"<code>cli</code>","text":""},{"location":"api/#ktoolbox.cli.__all__","title":"<code>__all__ = ['KToolBoxCli']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.cli.KToolBoxCli","title":"<code>KToolBoxCli</code>","text":"Source code in <code>ktoolbox/cli.py</code> <pre><code>class KToolBoxCli:\n    @staticmethod\n    async def version():\n        \"\"\"Show KToolBox version\"\"\"\n        return __version__\n\n    @staticmethod\n    async def site_version():\n        # noinspection SpellCheckingInspection\n        \"\"\"Show current Kemono site app commit hash\"\"\"\n        logger.info(repr(config))\n        ret = await get_app_version()\n        return ret.data if ret else ret.message\n\n    @staticmethod\n    async def config_editor():\n        \"\"\"Launch graphical KToolBox configuration editor\"\"\"\n        try:\n            from ktoolbox.editor import run_config_editor\n            run_config_editor()\n        except ModuleNotFoundError:\n            logger.error(\n                \"You need to install extra dependencies to use the editor, \"\n                \"run `pip install ktoolbox[urwid]` \"\n                \"or `pipx install ktoolbox[urwid] --force` if you are using pipx\"\n            )\n\n    @staticmethod\n    async def example_env():\n        \"\"\"Generate an example configuration ``.env`` file.\"\"\"\n        print(\n            render(\n                OutputFormat.DOTENV,\n                class_path=(\"ktoolbox.configuration.Configuration\",)\n            )\n        )\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator(\n            name: str = None,\n            id: str = None,\n            service: str = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_action(id=id, name=name, service=service)\n        if ret:\n            result_list = list(ret.data)\n            if dump:\n                await dump_search(result_list, dump)\n            return result_list or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator_post(\n            id: str = None,\n            name: str = None,\n            service: str = None,\n            q: str = None,\n            o: int = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search posts from creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n        if ret:\n            if dump:\n                await dump_search(ret.data, dump)\n            return ret.data or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    @staticmethod\n    async def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n        \"\"\"\n        Get a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            if dump:\n                async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                    await f.write(\n                        ret.data.post.model_dump_json(indent=config.json_dump_indent)\n                    )\n            return ret.data.post\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def download_post(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def download_post(\n            service: str,\n            creator_id: str,\n            post_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    async def download_post(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            post_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        \"\"\"\n        Download a specific post\n\n        :param url: The post URL\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param path: Download path, default is current directory\n        :param dump_post_data: Whether to dump post data (post.json) in post directory\n        \"\"\"\n        logger.info(repr(config))\n        # Get service, creator_id, post_id\n        if url:\n            service, creator_id, post_id = parse_webpage_url(url)\n        if not all([service, creator_id, post_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\", \"post_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            post_path = path / generate_post_path_name(ret.data.post)\n            job_list = await create_job_from_post(\n                post=ret.data.post,\n                post_path=post_path,\n                dump_post_data=dump_post_data\n            )\n            job_runner = JobRunner(job_list=job_list)\n            await job_runner.start()\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            service: str,\n            creator_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None\n    ):\n        ...\n\n    @staticmethod\n    async def sync_creator(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = False,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None,\n            offset: int = 0,\n            length: int = None\n    ):\n        \"\"\"\n        Sync posts from a creator\n\n        You can update the directory anytime after download finished, \\\n        such as to update after creator published new posts.\n\n        * ``start_time`` &amp; ``end_time`` example: ``2023-12-7``, ``2023-12-07``\n\n        :param url: The post URL\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param path: Download path, default is current directory\n        :param save_creator_indices: Record ``CreatorIndices`` data\n        :param mix_posts: Save all_pages files from different posts at same path, \\\n            ``save_creator_indices`` will be ignored if enabled\n        :param start_time: Start time of the published time range for posts downloading. \\\n            Set to ``0`` if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param end_time: End time of the published time range for posts downloading. \\\n            Set to latest time (infinity) if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param offset: Result offset (or start offset)\n        :param length: The number of posts to fetch, defaults to fetching all posts after ``offset``.\n        \"\"\"\n        logger.info(repr(config))\n        # Get service, creator_id\n        if url:\n            service, creator_id, _ = parse_webpage_url(url)\n        if not all([service, creator_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n\n        # Get creator name\n        creator_name = creator_id\n        creator_ret = await search_creator_action(id=creator_id, service=service)\n        if creator_ret:\n            creator = next(creator_ret.data, None)\n            if creator:\n                creator_name = creator.name\n                logger.info(\n                    generate_msg(\n                        \"Got creator information\",\n                        name=creator.name,\n                        id=creator.id\n                    )\n                )\n        else:\n            logger.error(\n                generate_msg(\n                    f\"Failed to fetch the name of creator &lt;{creator_id}&gt;\",\n                    detail=creator_ret.message\n                )\n            )\n            return creator_ret.message\n\n        creator_path = path / sanitize_filename(creator_name)\n\n        creator_path.mkdir(exist_ok=True)\n        ret = await create_job_from_creator(\n            service=service,\n            creator_id=creator_id,\n            path=creator_path,\n            all_pages=not length,\n            offset=offset,\n            length=length,\n            save_creator_indices=save_creator_indices,\n            mix_posts=mix_posts,\n            start_time=datetime.strptime(start_time, \"%Y-%m-%d\") if start_time else None,\n            end_time=datetime.strptime(end_time, \"%Y-%m-%d\") if end_time else None\n        )\n        if ret:\n            job_runner = JobRunner(job_list=ret.data)\n            await job_runner.start()\n        else:\n            return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.config_editor","title":"<code>config_editor()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Launch graphical KToolBox configuration editor</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def config_editor():\n    \"\"\"Launch graphical KToolBox configuration editor\"\"\"\n    try:\n        from ktoolbox.editor import run_config_editor\n        run_config_editor()\n    except ModuleNotFoundError:\n        logger.error(\n            \"You need to install extra dependencies to use the editor, \"\n            \"run `pip install ktoolbox[urwid]` \"\n            \"or `pipx install ktoolbox[urwid] --force` if you are using pipx\"\n        )\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.download_post","title":"<code>download_post(url=None, service=None, creator_id=None, post_id=None, path=Path('.'), *, dump_post_data=True)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Download a specific post</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service name</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The creator's ID</p> <code>None</code> <code>post_id</code> <code>str</code> <p>The post ID</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>dump_post_data</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def download_post(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        post_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        dump_post_data=True\n):\n    \"\"\"\n    Download a specific post\n\n    :param url: The post URL\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param path: Download path, default is current directory\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    logger.info(repr(config))\n    # Get service, creator_id, post_id\n    if url:\n        service, creator_id, post_id = parse_webpage_url(url)\n    if not all([service, creator_id, post_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\", \"post_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        post_path = path / generate_post_path_name(ret.data.post)\n        job_list = await create_job_from_post(\n            post=ret.data.post,\n            post_path=post_path,\n            dump_post_data=dump_post_data\n        )\n        job_runner = JobRunner(job_list=job_list)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.example_env","title":"<code>example_env()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Generate an example configuration <code>.env</code> file.</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def example_env():\n    \"\"\"Generate an example configuration ``.env`` file.\"\"\"\n    print(\n        render(\n            OutputFormat.DOTENV,\n            class_path=(\"ktoolbox.configuration.Configuration\",)\n        )\n    )\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.get_post","title":"<code>get_post(service, creator_id, post_id, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Get a specific post</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n    \"\"\"\n    Get a specific post\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        if dump:\n            async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                await f.write(\n                    ret.data.post.model_dump_json(indent=config.json_dump_indent)\n                )\n        return ret.data.post\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.search_creator","title":"<code>search_creator(name=None, id=None, service=None, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator(\n        name: str = None,\n        id: str = None,\n        service: str = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await search_creator_action(id=id, name=name, service=service)\n    if ret:\n        result_list = list(ret.data)\n        if dump:\n            await dump_search(result_list, dump)\n        return result_list or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search posts from creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: int = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search posts from creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n    if ret:\n        if dump:\n            await dump_search(ret.data, dump)\n        return ret.data or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.site_version","title":"<code>site_version()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show current Kemono site app commit hash</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def site_version():\n    # noinspection SpellCheckingInspection\n    \"\"\"Show current Kemono site app commit hash\"\"\"\n    logger.info(repr(config))\n    ret = await get_app_version()\n    return ret.data if ret else ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.sync_creator","title":"<code>sync_creator(url=None, service=None, creator_id=None, path=Path('.'), *, save_creator_indices=False, mix_posts=None, start_time=None, end_time=None, offset=0, length=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Sync posts from a creator</p> <p>You can update the directory anytime after download finished,         such as to update after creator published new posts.</p> <ul> <li><code>start_time</code> &amp; <code>end_time</code> example: <code>2023-12-7</code>, <code>2023-12-07</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service where the post is located</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all_pages files from different posts at same path,             <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>str</code> <p>Start time of the published time range for posts downloading.             Set to <code>0</code> if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>end_time</code> <code>str</code> <p>End time of the published time range for posts downloading.             Set to latest time (infinity) if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>int</code> <p>The number of posts to fetch, defaults to fetching all posts after <code>offset</code>.</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def sync_creator(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        save_creator_indices: bool = False,\n        mix_posts: bool = None,\n        start_time: str = None,\n        end_time: str = None,\n        offset: int = 0,\n        length: int = None\n):\n    \"\"\"\n    Sync posts from a creator\n\n    You can update the directory anytime after download finished, \\\n    such as to update after creator published new posts.\n\n    * ``start_time`` &amp; ``end_time`` example: ``2023-12-7``, ``2023-12-07``\n\n    :param url: The post URL\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: Download path, default is current directory\n    :param save_creator_indices: Record ``CreatorIndices`` data\n    :param mix_posts: Save all_pages files from different posts at same path, \\\n        ``save_creator_indices`` will be ignored if enabled\n    :param start_time: Start time of the published time range for posts downloading. \\\n        Set to ``0`` if ``None`` was given. \\\n        Time format: ``%Y-%m-%d``\n    :param end_time: End time of the published time range for posts downloading. \\\n        Set to latest time (infinity) if ``None`` was given. \\\n        Time format: ``%Y-%m-%d``\n    :param offset: Result offset (or start offset)\n    :param length: The number of posts to fetch, defaults to fetching all posts after ``offset``.\n    \"\"\"\n    logger.info(repr(config))\n    # Get service, creator_id\n    if url:\n        service, creator_id, _ = parse_webpage_url(url)\n    if not all([service, creator_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n\n    # Get creator name\n    creator_name = creator_id\n    creator_ret = await search_creator_action(id=creator_id, service=service)\n    if creator_ret:\n        creator = next(creator_ret.data, None)\n        if creator:\n            creator_name = creator.name\n            logger.info(\n                generate_msg(\n                    \"Got creator information\",\n                    name=creator.name,\n                    id=creator.id\n                )\n            )\n    else:\n        logger.error(\n            generate_msg(\n                f\"Failed to fetch the name of creator &lt;{creator_id}&gt;\",\n                detail=creator_ret.message\n            )\n        )\n        return creator_ret.message\n\n    creator_path = path / sanitize_filename(creator_name)\n\n    creator_path.mkdir(exist_ok=True)\n    ret = await create_job_from_creator(\n        service=service,\n        creator_id=creator_id,\n        path=creator_path,\n        all_pages=not length,\n        offset=offset,\n        length=length,\n        save_creator_indices=save_creator_indices,\n        mix_posts=mix_posts,\n        start_time=datetime.strptime(start_time, \"%Y-%m-%d\") if start_time else None,\n        end_time=datetime.strptime(end_time, \"%Y-%m-%d\") if end_time else None\n    )\n    if ret:\n        job_runner = JobRunner(job_list=ret.data)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.version","title":"<code>version()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show KToolBox version</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def version():\n    \"\"\"Show KToolBox version\"\"\"\n    return __version__\n</code></pre>"},{"location":"api/#ktoolbox.configuration","title":"<code>configuration</code>","text":""},{"location":"api/#ktoolbox.configuration.__all__","title":"<code>__all__ = ['config', 'APIConfiguration', 'DownloaderConfiguration', 'PostStructureConfiguration', 'JobConfiguration', 'LoggerConfiguration', 'Configuration']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.config","title":"<code>config = Configuration()</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration","title":"<code>APIConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Kemono API Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Kemono API URL scheme</p> <code>netloc</code> <code>str</code> <p>Kemono API URL netloc</p> <code>statics_netloc</code> <code>str</code> <p>URL netloc of Kemono server for static files (e.g. images)</p> <code>files_netloc</code> <code>str</code> <p>URL netloc of Kemono server for post files</p> <code>path</code> <code>str</code> <p>Kemono API URL root path</p> <code>timeout</code> <code>float</code> <p>API request timeout</p> <code>retry_times</code> <code>int</code> <p>API request retry times (when request failed)</p> <code>retry_interval</code> <code>float</code> <p>Seconds of API request retry interval</p> <code>session_key</code> <code>str</code> <p>Session key that can be found in cookies after a successful login</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class APIConfiguration(BaseModel):\n    \"\"\"\n    Kemono API Configuration\n\n    :ivar scheme: Kemono API URL scheme\n    :ivar netloc: Kemono API URL netloc\n    :ivar statics_netloc: URL netloc of Kemono server for static files (e.g. images)\n    :ivar files_netloc: URL netloc of Kemono server for post files\n    :ivar path: Kemono API URL root path\n    :ivar timeout: API request timeout\n    :ivar retry_times: API request retry times (when request failed)\n    :ivar retry_interval: Seconds of API request retry interval\n    :ivar session_key: Session key that can be found in cookies after a successful login\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    netloc: str = \"kemono.cr\"\n    statics_netloc: str = \"img.kemono.cr\"\n    files_netloc: str = \"kemono.cr\"\n    path: str = \"/api/v1\"\n    timeout: float = 5.0\n    retry_times: int = 3\n    retry_interval: float = 2.0\n    session_key: str = \"\"\n</code></pre>"},{"location":"api/#ktoolbox.configuration.APIConfiguration.files_netloc","title":"<code>files_netloc: str = 'kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.netloc","title":"<code>netloc: str = 'kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.path","title":"<code>path: str = '/api/v1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.retry_interval","title":"<code>retry_interval: float = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.retry_times","title":"<code>retry_times: int = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.session_key","title":"<code>session_key: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.statics_netloc","title":"<code>statics_netloc: str = 'img.kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.timeout","title":"<code>timeout: float = 5.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>KToolBox Configuration</p> <p>Attributes:</p> Name Type Description <code>api</code> <code>APIConfiguration</code> <p>Kemono API Configuration</p> <code>downloader</code> <code>DownloaderConfiguration</code> <p>File Downloader Configuration</p> <code>job</code> <code>JobConfiguration</code> <p>Download jobs Configuration</p> <code>logger</code> <code>LoggerConfiguration</code> <p>Logger configuration</p> <code>ssl_verify</code> <code>bool</code> <p>Enable SSL certificate verification for Kemono API server and download server</p> <code>json_dump_indent</code> <code>int</code> <p>Indent of JSON file dump</p> <code>use_uvloop</code> <code>bool</code> <p>Use uvloop for asyncio (Disabled on Windows by default)     uvloop will improve concurrent performance, but it is not compatible with Windows.     Install uvloop by <code>pip install ktoolbox[uvloop]</code> or it will not work.</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class Configuration(BaseSettings):\n    # noinspection SpellCheckingInspection,GrazieInspection\n    \"\"\"\n    KToolBox Configuration\n\n    :ivar api: Kemono API Configuration\n    :ivar downloader: File Downloader Configuration\n    :ivar job: Download jobs Configuration\n    :ivar logger: Logger configuration\n    :ivar ssl_verify: Enable SSL certificate verification for Kemono API server and download server\n    :ivar json_dump_indent: Indent of JSON file dump\n    :ivar use_uvloop: Use uvloop for asyncio (Disabled on Windows by default) \\\n    uvloop will improve concurrent performance, but it is not compatible with Windows. \\\n    Install uvloop by `pip install ktoolbox[uvloop]` or it will not work.\n    \"\"\"\n    api: APIConfiguration = APIConfiguration()\n    downloader: DownloaderConfiguration = DownloaderConfiguration()\n    job: JobConfiguration = JobConfiguration()\n    logger: LoggerConfiguration = LoggerConfiguration()\n\n    ssl_verify: bool = True\n    json_dump_indent: int = 4\n    use_uvloop: bool = True\n\n    # noinspection SpellCheckingInspection\n    model_config: ClassVar[SettingsConfigDict] = SettingsConfigDict(\n        env_prefix='ktoolbox_',\n        env_nested_delimiter='__',\n        env_file=['.env', 'prod.env'],\n        env_file_encoding='utf-8',\n        extra='ignore'\n    )\n</code></pre>"},{"location":"api/#ktoolbox.configuration.Configuration.api","title":"<code>api: APIConfiguration = APIConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.downloader","title":"<code>downloader: DownloaderConfiguration = DownloaderConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.job","title":"<code>job: JobConfiguration = JobConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.json_dump_indent","title":"<code>json_dump_indent: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.logger","title":"<code>logger: LoggerConfiguration = LoggerConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.model_config","title":"<code>model_config: SettingsConfigDict = SettingsConfigDict(env_prefix='ktoolbox_', env_nested_delimiter='__', env_file=['.env', 'prod.env'], env_file_encoding='utf-8', extra='ignore')</code>  <code>class-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.ssl_verify","title":"<code>ssl_verify: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.use_uvloop","title":"<code>use_uvloop: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration","title":"<code>DownloaderConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>File Downloader Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Downloader URL scheme</p> <code>timeout</code> <code>float</code> <p>Downloader request timeout</p> <code>encoding</code> <code>str</code> <p>Charset for filename parsing and post content text saving</p> <code>buffer_size</code> <code>int</code> <p>Number of bytes of file I/O buffer for each downloading file</p> <code>chunk_size</code> <code>int</code> <p>Number of bytes of chunk of downloader stream</p> <code>temp_suffix</code> <code>str</code> <p>Temp filename suffix of downloading files</p> <code>retry_times</code> <code>int</code> <p>Downloader retry times (when download failed)</p> <code>retry_stop_never</code> <code>bool</code> <p>Never stop downloader from retrying (when download failed)     (<code>retry_times</code> will be ignored when enabled)</p> <code>retry_interval</code> <code>float</code> <p>Seconds of downloader retry interval</p> <code>tps_limit</code> <code>float</code> <p>Maximum connections established per second</p> <code>use_bucket</code> <code>bool</code> <p>Enable local storage bucket mode</p> <code>bucket_path</code> <code>Path</code> <p>Path of local storage bucket</p> <code>reverse_proxy</code> <code>str</code> <p>Reverse proxy format for download URL.     Customize the filename format by inserting an empty <code>{}</code> to represent the original URL.     For example: <code>https://example.com/{}</code> will be <code>https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg</code>;      <code>https://example.com/?url={}</code> will be <code>https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg</code></p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class DownloaderConfiguration(BaseModel):\n    \"\"\"\n    File Downloader Configuration\n\n    :ivar scheme: Downloader URL scheme\n    :ivar timeout: Downloader request timeout\n    :ivar encoding: Charset for filename parsing and post content text saving\n    :ivar buffer_size: Number of bytes of file I/O buffer for each downloading file\n    :ivar chunk_size: Number of bytes of chunk of downloader stream\n    :ivar temp_suffix: Temp filename suffix of downloading files\n    :ivar retry_times: Downloader retry times (when download failed)\n    :ivar retry_stop_never: Never stop downloader from retrying (when download failed) \\\n    (``retry_times`` will be ignored when enabled)\n    :ivar retry_interval: Seconds of downloader retry interval\n    :ivar tps_limit: Maximum connections established per second\n    :ivar use_bucket: Enable local storage bucket mode\n    :ivar bucket_path: Path of local storage bucket\n    :ivar reverse_proxy: Reverse proxy format for download URL. \\\n    Customize the filename format by inserting an empty ``{}`` to represent the original URL. \\\n    For example: ``https://example.com/{}`` will be ``https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg``;  \\\n    ``https://example.com/?url={}`` will be ``https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg``\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    timeout: float = 30.0\n    encoding: str = \"utf-8\"\n    buffer_size: int = 20480\n    chunk_size: int = 1024\n    temp_suffix: str = \"tmp\"\n    retry_times: int = 10\n    retry_stop_never: bool = False\n    retry_interval: float = 3.0\n    tps_limit: float = 1.0\n    use_bucket: bool = False\n    bucket_path: Path = Path(\"./.ktoolbox/bucket_storage\")\n    reverse_proxy: str = \"{}\"\n\n    @model_validator(mode=\"after\")\n    def check_bucket_path(self) -&gt; \"DownloaderConfiguration\":\n        if self.use_bucket:\n            # noinspection PyBroadException\n            try:\n                bucket_path = Path(self.bucket_path)\n                bucket_path.mkdir(parents=True, exist_ok=True)\n                with tempfile.TemporaryFile(dir=bucket_path) as temp_file:\n                    temp_link_file_path = f\"{bucket_path / temp_file.name}.hlink\"\n                    os.link(temp_file.name, temp_link_file_path)\n                    os.remove(temp_link_file_path)\n            except Exception:\n                self.use_bucket = False\n                logger.exception(f\"`DownloaderConfiguration.bucket_path` is not available, \"\n                                 f\"`DownloaderConfiguration.use_bucket` has been disabled.\")\n        return self\n</code></pre>"},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.bucket_path","title":"<code>bucket_path: Path = Path('./.ktoolbox/bucket_storage')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.buffer_size","title":"<code>buffer_size: int = 20480</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.chunk_size","title":"<code>chunk_size: int = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.encoding","title":"<code>encoding: str = 'utf-8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.retry_interval","title":"<code>retry_interval: float = 3.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.retry_stop_never","title":"<code>retry_stop_never: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.retry_times","title":"<code>retry_times: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.reverse_proxy","title":"<code>reverse_proxy: str = '{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.temp_suffix","title":"<code>temp_suffix: str = 'tmp'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.timeout","title":"<code>timeout: float = 30.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.tps_limit","title":"<code>tps_limit: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.use_bucket","title":"<code>use_bucket: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.check_bucket_path","title":"<code>check_bucket_path()</code>","text":"Source code in <code>ktoolbox/configuration.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_bucket_path(self) -&gt; \"DownloaderConfiguration\":\n    if self.use_bucket:\n        # noinspection PyBroadException\n        try:\n            bucket_path = Path(self.bucket_path)\n            bucket_path.mkdir(parents=True, exist_ok=True)\n            with tempfile.TemporaryFile(dir=bucket_path) as temp_file:\n                temp_link_file_path = f\"{bucket_path / temp_file.name}.hlink\"\n                os.link(temp_file.name, temp_link_file_path)\n                os.remove(temp_link_file_path)\n        except Exception:\n            self.use_bucket = False\n            logger.exception(f\"`DownloaderConfiguration.bucket_path` is not available, \"\n                             f\"`DownloaderConfiguration.use_bucket` has been disabled.\")\n    return self\n</code></pre>"},{"location":"api/#ktoolbox.configuration.JobConfiguration","title":"<code>JobConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Download jobs Configuration</p> <ul> <li> <p>Available properties for <code>post_dirname_format</code> and <code>filename_format</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> </ul> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>Number of coroutines for concurrent download</p> <code>post_dirname_format</code> <code>str</code> <p>Customize the post directory name format, you can use some of the     properties in <code>Post</code>.     e.g. <code>[{published}]{id}</code> &gt; <code>[2024-1-1]123123</code>, <code>{user}_{published}_{title}</code> &gt; <code>234234_2024-1-1_TheTitle</code></p> <code>post_structure</code> <code>PostStructureConfiguration</code> <p>Post path structure</p> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path in creator directory.     It would not create any post directory, and <code>CreatorIndices</code> would not been recorded.</p> <code>sequential_filename</code> <code>bool</code> <p>Rename attachments in numerical order, e.g. <code>1.png</code>, <code>2.png</code>, ...</p> <code>filename_format</code> <code>str</code> <p>Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename. Similar to post_dirname_format, you can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b</code>, <code>TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90</code>, etc.     You can also use it with <code>sequential_filename</code>. For instance,     <code>[{published}]_{}</code> could result in filenames like <code>[2024-1-1]_1.png</code>, <code>[2024-1-1]_2.png</code>, etc.</p> <code>allow_list</code> <code>Set[str]</code> <p>Download files which match these patterns (Unix shell-style), e.g. <code>[\"*.png\"]</code></p> <code>block_list</code> <code>Set[str]</code> <p>Not to download files which match these patterns (Unix shell-style), e.g. <code>[\"*.psd\",\"*.zip\"]</code></p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class JobConfiguration(BaseModel):\n    \"\"\"\n    Download jobs Configuration\n\n    - Available properties for ``post_dirname_format`` and ``filename_format``\n\n        | Property      | Type   |\n        |---------------|--------|\n        | ``id``        | String |\n        | ``user``      | String |\n        | ``service``   | String |\n        | ``title``     | String |\n        | ``added``     | Date   |\n        | ``published`` | Date   |\n        | ``edited``    | Date   |\n\n    :ivar count: Number of coroutines for concurrent download\n    :ivar post_dirname_format: Customize the post directory name format, you can use some of the \\\n    [properties][ktoolbox.configuration.JobConfiguration] in ``Post``. \\\n    e.g. ``[{published}]{id}`` &gt; ``[2024-1-1]123123``, ``{user}_{published}_{title}`` &gt; ``234234_2024-1-1_TheTitle``\n    :ivar post_structure: Post path structure\n    :ivar mix_posts: Save all files from different posts at same path in creator directory. \\\n    It would not create any post directory, and ``CreatorIndices`` would not been recorded.\n    :ivar sequential_filename: Rename attachments in numerical order, e.g. ``1.png``, ``2.png``, ...\n    :ivar filename_format: Customize the filename format by inserting an empty ``{}`` to represent the basic filename.\n    Similar to post_dirname_format, you can use some of the [properties][ktoolbox.configuration.JobConfiguration] \\\n    in Post. For example: ``{title}_{}`` could result in filenames like \\\n    ``TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b``, ``TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90``, etc. \\\n    You can also use it with ``sequential_filename``. For instance, \\\n    ``[{published}]_{}`` could result in filenames like ``[2024-1-1]_1.png``, ``[2024-1-1]_2.png``, etc.\n    :ivar allow_list: Download files which match these patterns (Unix shell-style), e.g. ``[\"*.png\"]``\n    :ivar block_list: Not to download files which match these patterns (Unix shell-style), e.g. ``[\"*.psd\",\"*.zip\"]``\n    \"\"\"\n    count: int = 4\n    post_dirname_format: str = \"{title}\"\n    post_structure: PostStructureConfiguration = PostStructureConfiguration()\n    mix_posts: bool = False\n    sequential_filename: bool = False\n    filename_format: str = \"{}\"\n    # noinspection PyDataclass\n    allow_list: Set[str] = Field(default_factory=set)\n    # noinspection PyDataclass\n    block_list: Set[str] = Field(default_factory=set)\n</code></pre>"},{"location":"api/#ktoolbox.configuration.JobConfiguration.allow_list","title":"<code>allow_list: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.block_list","title":"<code>block_list: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.count","title":"<code>count: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.filename_format","title":"<code>filename_format: str = '{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.mix_posts","title":"<code>mix_posts: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.post_dirname_format","title":"<code>post_dirname_format: str = '{title}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.post_structure","title":"<code>post_structure: PostStructureConfiguration = PostStructureConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.sequential_filename","title":"<code>sequential_filename: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration","title":"<code>LoggerConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Logger configuration</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Optional[Path]</code> <p>Path to save logs, <code>None</code> for disable log file output</p> <code>level</code> <code>Union[str, int]</code> <p>Log filter level</p> <code>rotation</code> <code>Union[str, int, time, timedelta]</code> <p>Log rotation</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class LoggerConfiguration(BaseModel):\n    \"\"\"\n    Logger configuration\n\n    :ivar path: Path to save logs, ``None`` for disable log file output\n    :ivar level: Log filter level\n    :ivar rotation: Log rotation\n    \"\"\"\n    path: Optional[Path] = None\n    level: Union[str, int] = logging.getLevelName(logging.DEBUG)\n    rotation: Union[str, int, datetime.time, datetime.timedelta] = \"1 week\"\n</code></pre>"},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.level","title":"<code>level: Union[str, int] = logging.getLevelName(logging.DEBUG)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.path","title":"<code>path: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.rotation","title":"<code>rotation: Union[str, int, datetime.time, datetime.timedelta] = '1 week'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration","title":"<code>PostStructureConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Post path structure model</p> <ul> <li> <p>Default: <pre><code>..\n\u251c\u2500 content.txt\n\u251c\u2500 &lt;Post file&gt;\n\u251c\u2500 &lt;Post data (post.json)&gt;\n\u2514\u2500 attachments\n   \u251c\u2500 1.png\n   \u2514\u2500 2.png\n</code></pre></p> </li> <li> <p>Available properties for <code>file</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> </ul> <p>Attributes:</p> Name Type Description <code>attachments</code> <code>Path</code> <p>Sub path of attachment directory</p> <code>content</code> <code>Path</code> <p>Sub path of post content file</p> <code>content_filepath</code> <code>Path</code> <p>(Deprecated, Use <code>content</code> instead) Sub path of post content file</p> <code>file</code> <code>str</code> <p>The format of the post <code>file</code> filename (<code>file</code> is not <code>attachment</code>, each post has only one <code>file</code>, usually the cover image)     Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename.     You can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_Stelle_lv5_logo.gif</code>, <code>TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code>, etc.</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class PostStructureConfiguration(BaseModel):\n    # noinspection SpellCheckingInspection\n    \"\"\"\n    Post path structure model\n\n    - Default:\n    ```\n    ..\n    \u251c\u2500 content.txt\n    \u251c\u2500 &lt;Post file&gt;\n    \u251c\u2500 &lt;Post data (post.json)&gt;\n    \u2514\u2500 attachments\n       \u251c\u2500 1.png\n       \u2514\u2500 2.png\n    ```\n\n    - Available properties for ``file``\n\n        | Property      | Type   |\n        |---------------|--------|\n        | ``id``        | String |\n        | ``user``      | String |\n        | ``service``   | String |\n        | ``title``     | String |\n        | ``added``     | Date   |\n        | ``published`` | Date   |\n        | ``edited``    | Date   |\n\n    :ivar attachments: Sub path of attachment directory\n    :ivar content: Sub path of post content file\n    :ivar content_filepath: (**Deprecated**, Use ``content`` instead) Sub path of post content file\n    :ivar file: The format of the post `file` filename (`file` is not `attachment`, each post has only one `file`, usually the cover image) \\\n    Customize the filename format by inserting an empty ``{}`` to represent the basic filename. \\\n    You can use some of the [properties][ktoolbox.configuration.JobConfiguration] \\\n    in Post. For example: ``{title}_{}`` could result in filenames like \\\n    ``TheTitle_Stelle_lv5_logo.gif``, ``TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg``, etc.\n    \"\"\"\n    attachments: Path = Path(\"attachments\")\n    content: Path = Path(\"content.txt\")\n    content_filepath: Path = Path(\"content.txt\")\n    file: str = \"{id}_{}\"\n\n    @field_validator(\"content_filepath\")\n    def content_filepath_validator(cls, v):\n        # noinspection PyUnresolvedReferences\n        if v != cls.model_fields[\"content_filepath\"].default:\n            warnings.warn(\n                \"`PostStructureConfiguration.content_filepath` is deprecated and is scheduled for removal in further version. \"\n                \"Use `PostStructureConfiguration.content` instead\",\n                FutureWarning\n            )\n</code></pre>"},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.attachments","title":"<code>attachments: Path = Path('attachments')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.content","title":"<code>content: Path = Path('content.txt')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.content_filepath","title":"<code>content_filepath: Path = Path('content.txt')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.file","title":"<code>file: str = '{id}_{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.content_filepath_validator","title":"<code>content_filepath_validator(v)</code>","text":"Source code in <code>ktoolbox/configuration.py</code> <pre><code>@field_validator(\"content_filepath\")\ndef content_filepath_validator(cls, v):\n    # noinspection PyUnresolvedReferences\n    if v != cls.model_fields[\"content_filepath\"].default:\n        warnings.warn(\n            \"`PostStructureConfiguration.content_filepath` is deprecated and is scheduled for removal in further version. \"\n            \"Use `PostStructureConfiguration.content` instead\",\n            FutureWarning\n        )\n</code></pre>"},{"location":"api/#ktoolbox.downloader","title":"<code>downloader</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader","title":"<code>Downloader</code>","text":"<p>Attributes:</p> Name Type Description <code>_save_filename</code> <p>The actual filename for saving.</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>class Downloader:\n    \"\"\"\n    :ivar _save_filename: The actual filename for saving.\n    \"\"\"\n    succeeded_servers: Set[int] = set()\n    failure_servers: Set[int] = set()\n    wait_lock = Lock()\n\n    def __init__(\n            self,\n            url: str,\n            path: Path,\n            client: httpx.AsyncClient,\n            *,\n            buffer_size: int = None,\n            chunk_size: int = None,\n            designated_filename: str = None,\n            server_path: str = None\n    ):\n        # noinspection GrazieInspection\n        \"\"\"\n        Initialize a file downloader\n\n        - About filename:\n            1. If ``designated_filename`` parameter is set, use it.\n            2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n            3. Else use filename from 'file' part of ``server_path``.\n\n        :param url: Download URL\n        :param path: Directory path to save the file, which needs to be sanitized\n        :param client: HTTPX AsyncClient\n        :param buffer_size: Number of bytes for file I/O buffer\n        :param chunk_size: Number of bytes for chunk of download stream\n        :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n        :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n        it will be used as the save path.\n        \"\"\"\n\n        self._url = self._initial_url = url\n        self._path = path\n        self._client = client\n        self._buffer_size = buffer_size or config.downloader.buffer_size\n        self._chunk_size = chunk_size or config.downloader.chunk_size\n        self._designated_filename = designated_filename\n        self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n        self._save_filename = designated_filename  # Prioritize the manually specified filename\n\n        self._next_subdomain_index = 1\n        self._finished_lock = asyncio.Lock()\n        self._stop: bool = False\n\n    @cached_property\n    def url(self) -&gt; str:\n        \"\"\"Download URL\"\"\"\n        return self._url\n\n    @cached_property\n    def path(self) -&gt; Path:\n        \"\"\"Directory path to save the file\"\"\"\n        return self._path\n\n    @cached_property\n    def client(self) -&gt; httpx.AsyncClient:\n        \"\"\"HTTPX AsyncClient\"\"\"\n        return self._client\n\n    @cached_property\n    def buffer_size(self) -&gt; int:\n        \"\"\"Number of bytes for file I/O buffer\"\"\"\n        return self._buffer_size\n\n    @cached_property\n    def chunk_size(self) -&gt; int:\n        \"\"\"Number of bytes for chunk of download stream\"\"\"\n        return self._chunk_size\n\n    @property\n    def filename(self) -&gt; Optional[str]:\n        \"\"\"Actual filename of the download file\"\"\"\n        return self._save_filename\n\n    @property\n    def finished(self) -&gt; bool:\n        \"\"\"\n        Check if the download finished\n\n        :return: ``False`` if the download **in process**, ``True`` otherwise\n        \"\"\"\n        return not self._finished_lock.locked()\n\n    def cancel(self):\n        \"\"\"\n        Cancel the download\n\n        It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n        \"\"\"\n        self._stop = True\n\n    @tenacity.retry(\n        stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n        wait=wait_fixed(config.downloader.retry_interval),\n        retry=retry_if_result(\n            lambda x: not x and x.code != RetCodeEnum.FileExisted\n        ) | retry_if_exception(\n            lambda x: isinstance(x, httpx.HTTPError)\n        ),\n        before_sleep=lambda x: logger.warning(\n            generate_msg(\n                f\"Retrying ({x.attempt_number})\",\n                message=x.outcome.result().message if not x.outcome.failed else None,\n                exception=x.outcome.exception()\n            )\n        ),\n        reraise=True\n    )\n    async def run(\n            self,\n            *,\n            sync_callable: Callable[[\"Downloader\"], Any] = None,\n            async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n            tqdm_class: Type[std_tqdm] = None,\n            progress: bool = False\n    ) -&gt; DownloaderRet[str]:\n        \"\"\"\n        Start to download\n\n        :param sync_callable: Sync callable for download finished\n        :param async_callable: Async callable for download finished\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        :return: ``DownloaderRet`` which contain the actual output filename\n        :raise CancelledError: Job cancelled\n        \"\"\"\n        # Get filename to check if file exists (First-time duplicate file check)\n        # Check it before request to make progress more efficiency\n        server_relpath = self._server_path[1:]\n        server_relpath_without_params = urlparse(server_relpath).path\n        server_path_filename = unquote(Path(server_relpath_without_params).name)\n        # Priority order can be referenced from the constructor's documentation\n        save_filepath = self._path / (self._save_filename or server_path_filename)\n\n        # Get bucket file path\n        bucket_file_path: Optional[Path] = None\n        if config.downloader.use_bucket:\n            bucket_file_path = config.downloader.bucket_path / server_relpath\n\n        # Check if the file exists\n        file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n        if file_existed:\n            return DownloaderRet(\n                code=RetCodeEnum.FileExisted,\n                message=generate_msg(\n                    ret_msg,\n                    path=save_filepath\n                )\n            )\n\n        tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n        async with self.wait_lock:\n            await asyncio.sleep(1 / config.downloader.tps_limit)\n        async with self._finished_lock:\n            temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n            temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n            async with self._client.stream(\n                    method=\"GET\",\n                    url=config.downloader.reverse_proxy.format(self._url),\n                    follow_redirects=True,\n                    timeout=config.downloader.timeout,\n                    headers={\"Range\": f\"bytes={temp_size}-\"}\n            ) as res:  # type: httpx.Response\n                try:\n                    subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n                except ValueError:\n                    subdomain_index = None\n                if res.status_code == 403:\n                    if subdomain_index is not None:\n                        self.succeeded_servers.discard(subdomain_index)\n                        self.failure_servers.add(subdomain_index)\n                    # try succeeded servers first\n                    subdomain_index = next(iter(self.succeeded_servers), None)\n                    if subdomain_index is None:\n                        subdomain_index = self._next_subdomain_index\n                        # Update self._next_subdomain_index\n                        ## index fallback to 1 when a server after failure_servers has been tried\n                        if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                            self._next_subdomain_index = 1\n                            self.failure_servers.clear()\n                        ## otherwise, increment the index and avoid failure_servers\n                        else:\n                            self._next_subdomain_index += 1\n                            while self._next_subdomain_index in self.failure_servers:\n                                self._next_subdomain_index += 1\n                        msg = \"Download failed, trying next subdomain\"\n                    else:\n                        msg = \"Download failed, trying succeeded subdomains\"\n                    new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                    self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            msg,\n                            nex_subdomain=new_netloc,\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                    self._url = self._initial_url\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            \"Download failed\",\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                else:\n                    if subdomain_index is not None:\n                        self.failure_servers.discard(subdomain_index)\n                        self.succeeded_servers.add(subdomain_index)\n\n                # Get filename for saving and check if file exists (Second-time duplicate file check)\n                # Priority order can be referenced from the constructor's documentation\n                self._save_filename = self._designated_filename or sanitize_filename(\n                    filename_from_headers(res.headers)\n                ) or server_path_filename\n                save_filepath = self._path / self._save_filename\n                file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n                if file_existed:\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,\n                        message=generate_msg(\n                            ret_msg,\n                            path=save_filepath\n                        )\n                    )\n\n                # Download\n                total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n                async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                    chunk_iterator = res.aiter_bytes(self._chunk_size)\n                    t = tqdm_class(\n                        desc=self._save_filename,\n                        total=total_size,\n                        initial=temp_size,\n                        disable=not progress,\n                        unit=\"B\",\n                        unit_scale=True\n                    )\n                    async for chunk in chunk_iterator:\n                        if self._stop:\n                            raise CancelledError\n                        await f.write(chunk)\n                        t.update(len(chunk))  # Update progress bar\n\n            # Download finished\n            if config.downloader.use_bucket:\n                bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n                os.link(temp_filepath, bucket_file_path)\n            temp_filepath.rename(self._path / self._save_filename)\n\n            # Callbacks\n            if sync_callable:\n                sync_callable(self)\n            if async_callable:\n                await async_callable(self)\n\n            return DownloaderRet(\n                data=self._save_filename\n            ) if self._save_filename else DownloaderRet(\n                code=RetCodeEnum.GeneralFailure,\n                message=generate_msg(\n                    \"Download failed\",\n                    filename=self._designated_filename\n                )\n            )\n\n    __call__ = run\n</code></pre>"},{"location":"api/#ktoolbox.downloader.Downloader.__call__","title":"<code>__call__ = run</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.buffer_size","title":"<code>buffer_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for file I/O buffer</p>"},{"location":"api/#ktoolbox.downloader.Downloader.chunk_size","title":"<code>chunk_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for chunk of download stream</p>"},{"location":"api/#ktoolbox.downloader.Downloader.client","title":"<code>client: httpx.AsyncClient</code>  <code>cached</code> <code>property</code>","text":"<p>HTTPX AsyncClient</p>"},{"location":"api/#ktoolbox.downloader.Downloader.failure_servers","title":"<code>failure_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.filename","title":"<code>filename: Optional[str]</code>  <code>property</code>","text":"<p>Actual filename of the download file</p>"},{"location":"api/#ktoolbox.downloader.Downloader.finished","title":"<code>finished: bool</code>  <code>property</code>","text":"<p>Check if the download finished</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> if the download in process, <code>True</code> otherwise</p>"},{"location":"api/#ktoolbox.downloader.Downloader.path","title":"<code>path: Path</code>  <code>cached</code> <code>property</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.downloader.Downloader.succeeded_servers","title":"<code>succeeded_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.url","title":"<code>url: str</code>  <code>cached</code> <code>property</code>","text":"<p>Download URL</p>"},{"location":"api/#ktoolbox.downloader.Downloader.wait_lock","title":"<code>wait_lock = Lock()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.__init__","title":"<code>__init__(url, path, client, *, buffer_size=None, chunk_size=None, designated_filename=None, server_path=None)</code>","text":"<p>Initialize a file downloader</p> <ul> <li>About filename:<ol> <li>If <code>designated_filename</code> parameter is set, use it.</li> <li>Else if <code>Content-Disposition</code> is set in headers, use filename from it.</li> <li>Else use filename from 'file' part of <code>server_path</code>.</li> </ol> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Download URL</p> required <code>path</code> <code>Path</code> <p>Directory path to save the file, which needs to be sanitized</p> required <code>client</code> <code>AsyncClient</code> <p>HTTPX AsyncClient</p> required <code>buffer_size</code> <code>int</code> <p>Number of bytes for file I/O buffer</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>Number of bytes for chunk of download stream</p> <code>None</code> <code>designated_filename</code> <code>str</code> <p>Manually specify the filename for saving, which needs to be sanitized</p> <code>None</code> <code>server_path</code> <code>str</code> <p>Server path of the file. if <code>DownloaderConfiguration.use_bucket</code> enabled,         it will be used as the save path.</p> <code>None</code> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def __init__(\n        self,\n        url: str,\n        path: Path,\n        client: httpx.AsyncClient,\n        *,\n        buffer_size: int = None,\n        chunk_size: int = None,\n        designated_filename: str = None,\n        server_path: str = None\n):\n    # noinspection GrazieInspection\n    \"\"\"\n    Initialize a file downloader\n\n    - About filename:\n        1. If ``designated_filename`` parameter is set, use it.\n        2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n        3. Else use filename from 'file' part of ``server_path``.\n\n    :param url: Download URL\n    :param path: Directory path to save the file, which needs to be sanitized\n    :param client: HTTPX AsyncClient\n    :param buffer_size: Number of bytes for file I/O buffer\n    :param chunk_size: Number of bytes for chunk of download stream\n    :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n    :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n    it will be used as the save path.\n    \"\"\"\n\n    self._url = self._initial_url = url\n    self._path = path\n    self._client = client\n    self._buffer_size = buffer_size or config.downloader.buffer_size\n    self._chunk_size = chunk_size or config.downloader.chunk_size\n    self._designated_filename = designated_filename\n    self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n    self._save_filename = designated_filename  # Prioritize the manually specified filename\n\n    self._next_subdomain_index = 1\n    self._finished_lock = asyncio.Lock()\n    self._stop: bool = False\n</code></pre>"},{"location":"api/#ktoolbox.downloader.Downloader.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the download</p> <p>It will raise <code>asyncio.CancelledError</code> in <code>chunk_iterator</code> (writing chunk to file) iteration.</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def cancel(self):\n    \"\"\"\n    Cancel the download\n\n    It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n    \"\"\"\n    self._stop = True\n</code></pre>"},{"location":"api/#ktoolbox.downloader.Downloader.run","title":"<code>run(*, sync_callable=None, async_callable=None, tqdm_class=None, progress=False)</code>  <code>async</code>","text":"<p>Start to download</p> <p>Parameters:</p> Name Type Description Default <code>sync_callable</code> <code>Callable[[Downloader], Any]</code> <p>Sync callable for download finished</p> <code>None</code> <code>async_callable</code> <code>Callable[[Downloader], Coroutine]</code> <p>Async callable for download finished</p> <code>None</code> <code>tqdm_class</code> <code>Type[tqdm]</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>False</code> <p>Returns:</p> Type Description <code>DownloaderRet[str]</code> <p><code>DownloaderRet</code> which contain the actual output filename</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>Job cancelled</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>@tenacity.retry(\n    stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n    wait=wait_fixed(config.downloader.retry_interval),\n    retry=retry_if_result(\n        lambda x: not x and x.code != RetCodeEnum.FileExisted\n    ) | retry_if_exception(\n        lambda x: isinstance(x, httpx.HTTPError)\n    ),\n    before_sleep=lambda x: logger.warning(\n        generate_msg(\n            f\"Retrying ({x.attempt_number})\",\n            message=x.outcome.result().message if not x.outcome.failed else None,\n            exception=x.outcome.exception()\n        )\n    ),\n    reraise=True\n)\nasync def run(\n        self,\n        *,\n        sync_callable: Callable[[\"Downloader\"], Any] = None,\n        async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n        tqdm_class: Type[std_tqdm] = None,\n        progress: bool = False\n) -&gt; DownloaderRet[str]:\n    \"\"\"\n    Start to download\n\n    :param sync_callable: Sync callable for download finished\n    :param async_callable: Async callable for download finished\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    :return: ``DownloaderRet`` which contain the actual output filename\n    :raise CancelledError: Job cancelled\n    \"\"\"\n    # Get filename to check if file exists (First-time duplicate file check)\n    # Check it before request to make progress more efficiency\n    server_relpath = self._server_path[1:]\n    server_relpath_without_params = urlparse(server_relpath).path\n    server_path_filename = unquote(Path(server_relpath_without_params).name)\n    # Priority order can be referenced from the constructor's documentation\n    save_filepath = self._path / (self._save_filename or server_path_filename)\n\n    # Get bucket file path\n    bucket_file_path: Optional[Path] = None\n    if config.downloader.use_bucket:\n        bucket_file_path = config.downloader.bucket_path / server_relpath\n\n    # Check if the file exists\n    file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n    if file_existed:\n        return DownloaderRet(\n            code=RetCodeEnum.FileExisted,\n            message=generate_msg(\n                ret_msg,\n                path=save_filepath\n            )\n        )\n\n    tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n    async with self.wait_lock:\n        await asyncio.sleep(1 / config.downloader.tps_limit)\n    async with self._finished_lock:\n        temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n        temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n        async with self._client.stream(\n                method=\"GET\",\n                url=config.downloader.reverse_proxy.format(self._url),\n                follow_redirects=True,\n                timeout=config.downloader.timeout,\n                headers={\"Range\": f\"bytes={temp_size}-\"}\n        ) as res:  # type: httpx.Response\n            try:\n                subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n            except ValueError:\n                subdomain_index = None\n            if res.status_code == 403:\n                if subdomain_index is not None:\n                    self.succeeded_servers.discard(subdomain_index)\n                    self.failure_servers.add(subdomain_index)\n                # try succeeded servers first\n                subdomain_index = next(iter(self.succeeded_servers), None)\n                if subdomain_index is None:\n                    subdomain_index = self._next_subdomain_index\n                    # Update self._next_subdomain_index\n                    ## index fallback to 1 when a server after failure_servers has been tried\n                    if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                        self._next_subdomain_index = 1\n                        self.failure_servers.clear()\n                    ## otherwise, increment the index and avoid failure_servers\n                    else:\n                        self._next_subdomain_index += 1\n                        while self._next_subdomain_index in self.failure_servers:\n                            self._next_subdomain_index += 1\n                    msg = \"Download failed, trying next subdomain\"\n                else:\n                    msg = \"Download failed, trying succeeded subdomains\"\n                new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        msg,\n                        nex_subdomain=new_netloc,\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                self._url = self._initial_url\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        \"Download failed\",\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            else:\n                if subdomain_index is not None:\n                    self.failure_servers.discard(subdomain_index)\n                    self.succeeded_servers.add(subdomain_index)\n\n            # Get filename for saving and check if file exists (Second-time duplicate file check)\n            # Priority order can be referenced from the constructor's documentation\n            self._save_filename = self._designated_filename or sanitize_filename(\n                filename_from_headers(res.headers)\n            ) or server_path_filename\n            save_filepath = self._path / self._save_filename\n            file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n            if file_existed:\n                return DownloaderRet(\n                    code=RetCodeEnum.FileExisted,\n                    message=generate_msg(\n                        ret_msg,\n                        path=save_filepath\n                    )\n                )\n\n            # Download\n            total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n            async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                chunk_iterator = res.aiter_bytes(self._chunk_size)\n                t = tqdm_class(\n                    desc=self._save_filename,\n                    total=total_size,\n                    initial=temp_size,\n                    disable=not progress,\n                    unit=\"B\",\n                    unit_scale=True\n                )\n                async for chunk in chunk_iterator:\n                    if self._stop:\n                        raise CancelledError\n                    await f.write(chunk)\n                    t.update(len(chunk))  # Update progress bar\n\n        # Download finished\n        if config.downloader.use_bucket:\n            bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n            os.link(temp_filepath, bucket_file_path)\n        temp_filepath.rename(self._path / self._save_filename)\n\n        # Callbacks\n        if sync_callable:\n            sync_callable(self)\n        if async_callable:\n            await async_callable(self)\n\n        return DownloaderRet(\n            data=self._save_filename\n        ) if self._save_filename else DownloaderRet(\n            code=RetCodeEnum.GeneralFailure,\n            message=generate_msg(\n                \"Download failed\",\n                filename=self._designated_filename\n            )\n        )\n</code></pre>"},{"location":"api/#ktoolbox.downloader.DownloaderRet","title":"<code>DownloaderRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/downloader/base.py</code> <pre><code>class DownloaderRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.downloader.duplicate_file_check","title":"<code>duplicate_file_check(local_file_path, bucket_file_path=None)</code>","text":"<p>Check if the file existed, and link the bucket filepath to local filepath     if <code>DownloaderConfiguration.use_bucket</code> enabled.</p> <p>Parameters:</p> Name Type Description Default <code>local_file_path</code> <code>Path</code> <p>Download target path</p> required <code>bucket_file_path</code> <code>Path</code> <p>The bucket filepath of the local download path</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str]]</code> <p><code>(if file existed, message)</code></p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def duplicate_file_check(local_file_path: Path, bucket_file_path: Path = None) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"\n    Check if the file existed, and link the bucket filepath to local filepath \\\n    if ``DownloaderConfiguration.use_bucket`` enabled.\n\n    :param local_file_path: Download target path\n    :param bucket_file_path: The bucket filepath of the local download path\n    :return: ``(if file existed, message)``\n    \"\"\"\n    duplicate_check_path = bucket_file_path or local_file_path\n    if duplicate_check_path.is_file():\n        if config.downloader.use_bucket:\n            ret_msg = \"Download file already exists in both bucket and local, skipping\"\n            if not local_file_path.is_file():\n                ret_msg = \"Download file already exists in bucket, linking to local path\"\n                os.link(bucket_file_path, local_file_path)\n        else:\n            ret_msg = \"Download file already exists, skipping\"\n        return True, ret_msg\n    else:\n        return False, None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.filename_from_headers","title":"<code>filename_from_headers(headers)</code>","text":"<p>Get file name from headers.</p> <p>Parse from <code>Content-Disposition</code>.</p> <ul> <li> <p>Example: <pre><code>filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8''README%2Emd;filename=\"README.md\"'})\n</code></pre></p> </li> <li> <p>Return: <pre><code>README.md\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP headers</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>File name</p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def filename_from_headers(headers: Dict[str, str]) -&gt; Optional[str]:\n    \"\"\"\n    Get file name from headers.\n\n    Parse from ``Content-Disposition``.\n\n    - Example:\n    ```\n    filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8\\'\\'README%2Emd;filename=\"README.md\"'})\n    ```\n\n    - Return:\n    ```\n    README.md\n    ```\n\n    :param headers: HTTP headers\n    :return: File name\n    \"\"\"\n    if not (disposition := headers.get(\"Content-Disposition\")):\n        if not (disposition := headers.get(\"content-disposition\")):\n            return None\n    options = parse_header(disposition)  # alternative: `parse_header` in `utils.py`\n    if filename := options.get(\"filename*\"):\n        if len(name_with_charset := filename.split(\"''\")) == 2:\n            charset, name = name_with_charset\n            return urllib.parse.unquote(name, charset)\n    if filename := options.get(\"filename\"):\n        return urllib.parse.unquote(filename, config.downloader.encoding)\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.downloader.base.__all__","title":"<code>__all__ = ['DownloaderRet']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.base.DownloaderRet","title":"<code>DownloaderRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/downloader/base.py</code> <pre><code>class DownloaderRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader","title":"<code>downloader</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.__all__","title":"<code>__all__ = ['Downloader']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader","title":"<code>Downloader</code>","text":"<p>Attributes:</p> Name Type Description <code>_save_filename</code> <p>The actual filename for saving.</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>class Downloader:\n    \"\"\"\n    :ivar _save_filename: The actual filename for saving.\n    \"\"\"\n    succeeded_servers: Set[int] = set()\n    failure_servers: Set[int] = set()\n    wait_lock = Lock()\n\n    def __init__(\n            self,\n            url: str,\n            path: Path,\n            client: httpx.AsyncClient,\n            *,\n            buffer_size: int = None,\n            chunk_size: int = None,\n            designated_filename: str = None,\n            server_path: str = None\n    ):\n        # noinspection GrazieInspection\n        \"\"\"\n        Initialize a file downloader\n\n        - About filename:\n            1. If ``designated_filename`` parameter is set, use it.\n            2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n            3. Else use filename from 'file' part of ``server_path``.\n\n        :param url: Download URL\n        :param path: Directory path to save the file, which needs to be sanitized\n        :param client: HTTPX AsyncClient\n        :param buffer_size: Number of bytes for file I/O buffer\n        :param chunk_size: Number of bytes for chunk of download stream\n        :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n        :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n        it will be used as the save path.\n        \"\"\"\n\n        self._url = self._initial_url = url\n        self._path = path\n        self._client = client\n        self._buffer_size = buffer_size or config.downloader.buffer_size\n        self._chunk_size = chunk_size or config.downloader.chunk_size\n        self._designated_filename = designated_filename\n        self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n        self._save_filename = designated_filename  # Prioritize the manually specified filename\n\n        self._next_subdomain_index = 1\n        self._finished_lock = asyncio.Lock()\n        self._stop: bool = False\n\n    @cached_property\n    def url(self) -&gt; str:\n        \"\"\"Download URL\"\"\"\n        return self._url\n\n    @cached_property\n    def path(self) -&gt; Path:\n        \"\"\"Directory path to save the file\"\"\"\n        return self._path\n\n    @cached_property\n    def client(self) -&gt; httpx.AsyncClient:\n        \"\"\"HTTPX AsyncClient\"\"\"\n        return self._client\n\n    @cached_property\n    def buffer_size(self) -&gt; int:\n        \"\"\"Number of bytes for file I/O buffer\"\"\"\n        return self._buffer_size\n\n    @cached_property\n    def chunk_size(self) -&gt; int:\n        \"\"\"Number of bytes for chunk of download stream\"\"\"\n        return self._chunk_size\n\n    @property\n    def filename(self) -&gt; Optional[str]:\n        \"\"\"Actual filename of the download file\"\"\"\n        return self._save_filename\n\n    @property\n    def finished(self) -&gt; bool:\n        \"\"\"\n        Check if the download finished\n\n        :return: ``False`` if the download **in process**, ``True`` otherwise\n        \"\"\"\n        return not self._finished_lock.locked()\n\n    def cancel(self):\n        \"\"\"\n        Cancel the download\n\n        It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n        \"\"\"\n        self._stop = True\n\n    @tenacity.retry(\n        stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n        wait=wait_fixed(config.downloader.retry_interval),\n        retry=retry_if_result(\n            lambda x: not x and x.code != RetCodeEnum.FileExisted\n        ) | retry_if_exception(\n            lambda x: isinstance(x, httpx.HTTPError)\n        ),\n        before_sleep=lambda x: logger.warning(\n            generate_msg(\n                f\"Retrying ({x.attempt_number})\",\n                message=x.outcome.result().message if not x.outcome.failed else None,\n                exception=x.outcome.exception()\n            )\n        ),\n        reraise=True\n    )\n    async def run(\n            self,\n            *,\n            sync_callable: Callable[[\"Downloader\"], Any] = None,\n            async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n            tqdm_class: Type[std_tqdm] = None,\n            progress: bool = False\n    ) -&gt; DownloaderRet[str]:\n        \"\"\"\n        Start to download\n\n        :param sync_callable: Sync callable for download finished\n        :param async_callable: Async callable for download finished\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        :return: ``DownloaderRet`` which contain the actual output filename\n        :raise CancelledError: Job cancelled\n        \"\"\"\n        # Get filename to check if file exists (First-time duplicate file check)\n        # Check it before request to make progress more efficiency\n        server_relpath = self._server_path[1:]\n        server_relpath_without_params = urlparse(server_relpath).path\n        server_path_filename = unquote(Path(server_relpath_without_params).name)\n        # Priority order can be referenced from the constructor's documentation\n        save_filepath = self._path / (self._save_filename or server_path_filename)\n\n        # Get bucket file path\n        bucket_file_path: Optional[Path] = None\n        if config.downloader.use_bucket:\n            bucket_file_path = config.downloader.bucket_path / server_relpath\n\n        # Check if the file exists\n        file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n        if file_existed:\n            return DownloaderRet(\n                code=RetCodeEnum.FileExisted,\n                message=generate_msg(\n                    ret_msg,\n                    path=save_filepath\n                )\n            )\n\n        tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n        async with self.wait_lock:\n            await asyncio.sleep(1 / config.downloader.tps_limit)\n        async with self._finished_lock:\n            temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n            temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n            async with self._client.stream(\n                    method=\"GET\",\n                    url=config.downloader.reverse_proxy.format(self._url),\n                    follow_redirects=True,\n                    timeout=config.downloader.timeout,\n                    headers={\"Range\": f\"bytes={temp_size}-\"}\n            ) as res:  # type: httpx.Response\n                try:\n                    subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n                except ValueError:\n                    subdomain_index = None\n                if res.status_code == 403:\n                    if subdomain_index is not None:\n                        self.succeeded_servers.discard(subdomain_index)\n                        self.failure_servers.add(subdomain_index)\n                    # try succeeded servers first\n                    subdomain_index = next(iter(self.succeeded_servers), None)\n                    if subdomain_index is None:\n                        subdomain_index = self._next_subdomain_index\n                        # Update self._next_subdomain_index\n                        ## index fallback to 1 when a server after failure_servers has been tried\n                        if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                            self._next_subdomain_index = 1\n                            self.failure_servers.clear()\n                        ## otherwise, increment the index and avoid failure_servers\n                        else:\n                            self._next_subdomain_index += 1\n                            while self._next_subdomain_index in self.failure_servers:\n                                self._next_subdomain_index += 1\n                        msg = \"Download failed, trying next subdomain\"\n                    else:\n                        msg = \"Download failed, trying succeeded subdomains\"\n                    new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                    self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            msg,\n                            nex_subdomain=new_netloc,\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                    self._url = self._initial_url\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            \"Download failed\",\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                else:\n                    if subdomain_index is not None:\n                        self.failure_servers.discard(subdomain_index)\n                        self.succeeded_servers.add(subdomain_index)\n\n                # Get filename for saving and check if file exists (Second-time duplicate file check)\n                # Priority order can be referenced from the constructor's documentation\n                self._save_filename = self._designated_filename or sanitize_filename(\n                    filename_from_headers(res.headers)\n                ) or server_path_filename\n                save_filepath = self._path / self._save_filename\n                file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n                if file_existed:\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,\n                        message=generate_msg(\n                            ret_msg,\n                            path=save_filepath\n                        )\n                    )\n\n                # Download\n                total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n                async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                    chunk_iterator = res.aiter_bytes(self._chunk_size)\n                    t = tqdm_class(\n                        desc=self._save_filename,\n                        total=total_size,\n                        initial=temp_size,\n                        disable=not progress,\n                        unit=\"B\",\n                        unit_scale=True\n                    )\n                    async for chunk in chunk_iterator:\n                        if self._stop:\n                            raise CancelledError\n                        await f.write(chunk)\n                        t.update(len(chunk))  # Update progress bar\n\n            # Download finished\n            if config.downloader.use_bucket:\n                bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n                os.link(temp_filepath, bucket_file_path)\n            temp_filepath.rename(self._path / self._save_filename)\n\n            # Callbacks\n            if sync_callable:\n                sync_callable(self)\n            if async_callable:\n                await async_callable(self)\n\n            return DownloaderRet(\n                data=self._save_filename\n            ) if self._save_filename else DownloaderRet(\n                code=RetCodeEnum.GeneralFailure,\n                message=generate_msg(\n                    \"Download failed\",\n                    filename=self._designated_filename\n                )\n            )\n\n    __call__ = run\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.__call__","title":"<code>__call__ = run</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.buffer_size","title":"<code>buffer_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for file I/O buffer</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.chunk_size","title":"<code>chunk_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for chunk of download stream</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.client","title":"<code>client: httpx.AsyncClient</code>  <code>cached</code> <code>property</code>","text":"<p>HTTPX AsyncClient</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.failure_servers","title":"<code>failure_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.filename","title":"<code>filename: Optional[str]</code>  <code>property</code>","text":"<p>Actual filename of the download file</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.finished","title":"<code>finished: bool</code>  <code>property</code>","text":"<p>Check if the download finished</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> if the download in process, <code>True</code> otherwise</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.path","title":"<code>path: Path</code>  <code>cached</code> <code>property</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.succeeded_servers","title":"<code>succeeded_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.url","title":"<code>url: str</code>  <code>cached</code> <code>property</code>","text":"<p>Download URL</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.wait_lock","title":"<code>wait_lock = Lock()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.__init__","title":"<code>__init__(url, path, client, *, buffer_size=None, chunk_size=None, designated_filename=None, server_path=None)</code>","text":"<p>Initialize a file downloader</p> <ul> <li>About filename:<ol> <li>If <code>designated_filename</code> parameter is set, use it.</li> <li>Else if <code>Content-Disposition</code> is set in headers, use filename from it.</li> <li>Else use filename from 'file' part of <code>server_path</code>.</li> </ol> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Download URL</p> required <code>path</code> <code>Path</code> <p>Directory path to save the file, which needs to be sanitized</p> required <code>client</code> <code>AsyncClient</code> <p>HTTPX AsyncClient</p> required <code>buffer_size</code> <code>int</code> <p>Number of bytes for file I/O buffer</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>Number of bytes for chunk of download stream</p> <code>None</code> <code>designated_filename</code> <code>str</code> <p>Manually specify the filename for saving, which needs to be sanitized</p> <code>None</code> <code>server_path</code> <code>str</code> <p>Server path of the file. if <code>DownloaderConfiguration.use_bucket</code> enabled,         it will be used as the save path.</p> <code>None</code> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def __init__(\n        self,\n        url: str,\n        path: Path,\n        client: httpx.AsyncClient,\n        *,\n        buffer_size: int = None,\n        chunk_size: int = None,\n        designated_filename: str = None,\n        server_path: str = None\n):\n    # noinspection GrazieInspection\n    \"\"\"\n    Initialize a file downloader\n\n    - About filename:\n        1. If ``designated_filename`` parameter is set, use it.\n        2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n        3. Else use filename from 'file' part of ``server_path``.\n\n    :param url: Download URL\n    :param path: Directory path to save the file, which needs to be sanitized\n    :param client: HTTPX AsyncClient\n    :param buffer_size: Number of bytes for file I/O buffer\n    :param chunk_size: Number of bytes for chunk of download stream\n    :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n    :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n    it will be used as the save path.\n    \"\"\"\n\n    self._url = self._initial_url = url\n    self._path = path\n    self._client = client\n    self._buffer_size = buffer_size or config.downloader.buffer_size\n    self._chunk_size = chunk_size or config.downloader.chunk_size\n    self._designated_filename = designated_filename\n    self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n    self._save_filename = designated_filename  # Prioritize the manually specified filename\n\n    self._next_subdomain_index = 1\n    self._finished_lock = asyncio.Lock()\n    self._stop: bool = False\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the download</p> <p>It will raise <code>asyncio.CancelledError</code> in <code>chunk_iterator</code> (writing chunk to file) iteration.</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def cancel(self):\n    \"\"\"\n    Cancel the download\n\n    It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n    \"\"\"\n    self._stop = True\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.run","title":"<code>run(*, sync_callable=None, async_callable=None, tqdm_class=None, progress=False)</code>  <code>async</code>","text":"<p>Start to download</p> <p>Parameters:</p> Name Type Description Default <code>sync_callable</code> <code>Callable[[Downloader], Any]</code> <p>Sync callable for download finished</p> <code>None</code> <code>async_callable</code> <code>Callable[[Downloader], Coroutine]</code> <p>Async callable for download finished</p> <code>None</code> <code>tqdm_class</code> <code>Type[tqdm]</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>False</code> <p>Returns:</p> Type Description <code>DownloaderRet[str]</code> <p><code>DownloaderRet</code> which contain the actual output filename</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>Job cancelled</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>@tenacity.retry(\n    stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n    wait=wait_fixed(config.downloader.retry_interval),\n    retry=retry_if_result(\n        lambda x: not x and x.code != RetCodeEnum.FileExisted\n    ) | retry_if_exception(\n        lambda x: isinstance(x, httpx.HTTPError)\n    ),\n    before_sleep=lambda x: logger.warning(\n        generate_msg(\n            f\"Retrying ({x.attempt_number})\",\n            message=x.outcome.result().message if not x.outcome.failed else None,\n            exception=x.outcome.exception()\n        )\n    ),\n    reraise=True\n)\nasync def run(\n        self,\n        *,\n        sync_callable: Callable[[\"Downloader\"], Any] = None,\n        async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n        tqdm_class: Type[std_tqdm] = None,\n        progress: bool = False\n) -&gt; DownloaderRet[str]:\n    \"\"\"\n    Start to download\n\n    :param sync_callable: Sync callable for download finished\n    :param async_callable: Async callable for download finished\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    :return: ``DownloaderRet`` which contain the actual output filename\n    :raise CancelledError: Job cancelled\n    \"\"\"\n    # Get filename to check if file exists (First-time duplicate file check)\n    # Check it before request to make progress more efficiency\n    server_relpath = self._server_path[1:]\n    server_relpath_without_params = urlparse(server_relpath).path\n    server_path_filename = unquote(Path(server_relpath_without_params).name)\n    # Priority order can be referenced from the constructor's documentation\n    save_filepath = self._path / (self._save_filename or server_path_filename)\n\n    # Get bucket file path\n    bucket_file_path: Optional[Path] = None\n    if config.downloader.use_bucket:\n        bucket_file_path = config.downloader.bucket_path / server_relpath\n\n    # Check if the file exists\n    file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n    if file_existed:\n        return DownloaderRet(\n            code=RetCodeEnum.FileExisted,\n            message=generate_msg(\n                ret_msg,\n                path=save_filepath\n            )\n        )\n\n    tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n    async with self.wait_lock:\n        await asyncio.sleep(1 / config.downloader.tps_limit)\n    async with self._finished_lock:\n        temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n        temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n        async with self._client.stream(\n                method=\"GET\",\n                url=config.downloader.reverse_proxy.format(self._url),\n                follow_redirects=True,\n                timeout=config.downloader.timeout,\n                headers={\"Range\": f\"bytes={temp_size}-\"}\n        ) as res:  # type: httpx.Response\n            try:\n                subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n            except ValueError:\n                subdomain_index = None\n            if res.status_code == 403:\n                if subdomain_index is not None:\n                    self.succeeded_servers.discard(subdomain_index)\n                    self.failure_servers.add(subdomain_index)\n                # try succeeded servers first\n                subdomain_index = next(iter(self.succeeded_servers), None)\n                if subdomain_index is None:\n                    subdomain_index = self._next_subdomain_index\n                    # Update self._next_subdomain_index\n                    ## index fallback to 1 when a server after failure_servers has been tried\n                    if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                        self._next_subdomain_index = 1\n                        self.failure_servers.clear()\n                    ## otherwise, increment the index and avoid failure_servers\n                    else:\n                        self._next_subdomain_index += 1\n                        while self._next_subdomain_index in self.failure_servers:\n                            self._next_subdomain_index += 1\n                    msg = \"Download failed, trying next subdomain\"\n                else:\n                    msg = \"Download failed, trying succeeded subdomains\"\n                new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        msg,\n                        nex_subdomain=new_netloc,\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                self._url = self._initial_url\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        \"Download failed\",\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            else:\n                if subdomain_index is not None:\n                    self.failure_servers.discard(subdomain_index)\n                    self.succeeded_servers.add(subdomain_index)\n\n            # Get filename for saving and check if file exists (Second-time duplicate file check)\n            # Priority order can be referenced from the constructor's documentation\n            self._save_filename = self._designated_filename or sanitize_filename(\n                filename_from_headers(res.headers)\n            ) or server_path_filename\n            save_filepath = self._path / self._save_filename\n            file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n            if file_existed:\n                return DownloaderRet(\n                    code=RetCodeEnum.FileExisted,\n                    message=generate_msg(\n                        ret_msg,\n                        path=save_filepath\n                    )\n                )\n\n            # Download\n            total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n            async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                chunk_iterator = res.aiter_bytes(self._chunk_size)\n                t = tqdm_class(\n                    desc=self._save_filename,\n                    total=total_size,\n                    initial=temp_size,\n                    disable=not progress,\n                    unit=\"B\",\n                    unit_scale=True\n                )\n                async for chunk in chunk_iterator:\n                    if self._stop:\n                        raise CancelledError\n                    await f.write(chunk)\n                    t.update(len(chunk))  # Update progress bar\n\n        # Download finished\n        if config.downloader.use_bucket:\n            bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n            os.link(temp_filepath, bucket_file_path)\n        temp_filepath.rename(self._path / self._save_filename)\n\n        # Callbacks\n        if sync_callable:\n            sync_callable(self)\n        if async_callable:\n            await async_callable(self)\n\n        return DownloaderRet(\n            data=self._save_filename\n        ) if self._save_filename else DownloaderRet(\n            code=RetCodeEnum.GeneralFailure,\n            message=generate_msg(\n                \"Download failed\",\n                filename=self._designated_filename\n            )\n        )\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.downloader.utils.__all__","title":"<code>__all__ = ['filename_from_headers', 'duplicate_file_check']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.utils.duplicate_file_check","title":"<code>duplicate_file_check(local_file_path, bucket_file_path=None)</code>","text":"<p>Check if the file existed, and link the bucket filepath to local filepath     if <code>DownloaderConfiguration.use_bucket</code> enabled.</p> <p>Parameters:</p> Name Type Description Default <code>local_file_path</code> <code>Path</code> <p>Download target path</p> required <code>bucket_file_path</code> <code>Path</code> <p>The bucket filepath of the local download path</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str]]</code> <p><code>(if file existed, message)</code></p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def duplicate_file_check(local_file_path: Path, bucket_file_path: Path = None) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"\n    Check if the file existed, and link the bucket filepath to local filepath \\\n    if ``DownloaderConfiguration.use_bucket`` enabled.\n\n    :param local_file_path: Download target path\n    :param bucket_file_path: The bucket filepath of the local download path\n    :return: ``(if file existed, message)``\n    \"\"\"\n    duplicate_check_path = bucket_file_path or local_file_path\n    if duplicate_check_path.is_file():\n        if config.downloader.use_bucket:\n            ret_msg = \"Download file already exists in both bucket and local, skipping\"\n            if not local_file_path.is_file():\n                ret_msg = \"Download file already exists in bucket, linking to local path\"\n                os.link(bucket_file_path, local_file_path)\n        else:\n            ret_msg = \"Download file already exists, skipping\"\n        return True, ret_msg\n    else:\n        return False, None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utils.filename_from_headers","title":"<code>filename_from_headers(headers)</code>","text":"<p>Get file name from headers.</p> <p>Parse from <code>Content-Disposition</code>.</p> <ul> <li> <p>Example: <pre><code>filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8''README%2Emd;filename=\"README.md\"'})\n</code></pre></p> </li> <li> <p>Return: <pre><code>README.md\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP headers</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>File name</p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def filename_from_headers(headers: Dict[str, str]) -&gt; Optional[str]:\n    \"\"\"\n    Get file name from headers.\n\n    Parse from ``Content-Disposition``.\n\n    - Example:\n    ```\n    filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8\\'\\'README%2Emd;filename=\"README.md\"'})\n    ```\n\n    - Return:\n    ```\n    README.md\n    ```\n\n    :param headers: HTTP headers\n    :return: File name\n    \"\"\"\n    if not (disposition := headers.get(\"Content-Disposition\")):\n        if not (disposition := headers.get(\"content-disposition\")):\n            return None\n    options = parse_header(disposition)  # alternative: `parse_header` in `utils.py`\n    if filename := options.get(\"filename*\"):\n        if len(name_with_charset := filename.split(\"''\")) == 2:\n            charset, name = name_with_charset\n            return urllib.parse.unquote(name, charset)\n    if filename := options.get(\"filename\"):\n        return urllib.parse.unquote(filename, config.downloader.encoding)\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utils.parse_header","title":"<code>parse_header(line)</code>","text":"<p>Alternative resolution for parsing header line.</p> <p>Apply when <code>cgi.parse_header</code> is unable to use due to the deprecation of <code>cgi</code> module.</p> <p>https://peps.python.org/pep-0594/#cgi</p> <ul> <li> <p>Example: <pre><code>parse_header(\"text/html; charset=utf-8\")\n</code></pre></p> </li> <li> <p>Return: <pre><code>{'text/html': None, 'charset': 'utf-8'}\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Header line</p> required <p>Returns:</p> Type Description <code>Dict[str, Optional[str]]</code> <p>Dict of header line</p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def parse_header(line: str) -&gt; Dict[str, Optional[str]]:\n    \"\"\"\n    Alternative resolution for parsing header line.\n\n    Apply when ``cgi.parse_header`` is unable to use due to the deprecation of `cgi` module.\n\n    https://peps.python.org/pep-0594/#cgi\n\n    - Example:\n    ```\n    parse_header(\"text/html; charset=utf-8\")\n    ```\n\n    - Return:\n    ```\n    {'text/html': None, 'charset': 'utf-8'}\n    ```\n\n    :param line: Header line\n    :return: Dict of header line\n    \"\"\"\n    dict_value: Dict[str, Optional[str]] = {}\n    for item in line.split(\";\"):\n        if len(pair := item.split(\"=\")) == 1:\n            dict_value[pair[0]] = None\n        else:\n            dict_value.setdefault(*pair)\n    return dict_value\n</code></pre>"},{"location":"api/#ktoolbox.editor","title":"<code>editor</code>","text":""},{"location":"api/#ktoolbox.editor.__all__","title":"<code>__all__ = ['EditWithSignalWidget', 'CascadingBoxes', 'run_config_editor']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.default_config","title":"<code>default_config = Configuration(_env_file='')</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.default_config_envs","title":"<code>default_config_envs = set(dump_envs(default_config))</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.initial_envs","title":"<code>initial_envs = set(dump_envs(config))</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.menu_top","title":"<code>menu_top = menu('KToolBox Configuration Editor', [sub_menu('Edit', [sub_menu('API', model_to_widgets(config.api)), sub_menu('Downloader', model_to_widgets(config.downloader)), sub_menu('Job', model_to_widgets(config.job)), sub_menu('Logger', model_to_widgets(config.logger)), urwid.Divider()] + list(model_to_widgets(config, ['ssl_verify', 'json_dump_indent', 'use_uvloop']))), urwid.Divider(), menu_option(urwid.Button('JSON Preview', lambda x: top.open_box(sub_menu_with_menu_widget('JSON Preview', [urwid.Text(config.model_dump_json(indent=4))])[1]))), menu_option(urwid.Button('JSON Preview (Python Mode)', lambda x: top.open_box(sub_menu_with_menu_widget('JSON Preview (Python Serialize Mode)', [urwid.Text(pprint.pformat(config.model_dump(mode='python'), sort_dicts=False))])[1]))), menu_option(urwid.Button('DotEnv Preview (.env / prod.env)', lambda x: top.open_box(sub_menu_with_menu_widget('DotEnv Preview (.env / prod.env)', [urwid.Text('\\n'.join(dump_modified_envs(dump_envs(config))) or 'Same as the default configuration, DotEnv will be left empty.')])[1]))), urwid.Divider(), sub_menu('Save', [menu_option(urwid.Button(\"Save to '.env' / 'prod.env' file\", on_save_dotenv))]), urwid.Divider(bottom=2), menu_option(urwid.Button('Help', lambda x: webbrowser.open('https://ktoolbox.readthedocs.io/latest/configuration/guide/'))), menu_option(urwid.Button('Exit', exit_program)), urwid.Divider(bottom=2), urwid.Text('For detailed information, please refer to https://ktoolbox.readthedocs.io', align=urwid.CENTER), urwid.Divider(), urwid.Text(__version__, align=urwid.CENTER)])</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.top","title":"<code>top = CascadingBoxes(menu_top)</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.CascadingBoxes","title":"<code>CascadingBoxes</code>","text":"<p>               Bases: <code>WidgetPlaceholder</code></p> Source code in <code>ktoolbox/editor.py</code> <pre><code>class CascadingBoxes(urwid.WidgetPlaceholder):\n    max_box_levels = 4\n\n    def __init__(self, box: urwid.Widget) -&gt; None:\n        super().__init__(urwid.SolidFill(\"/\"))\n        self.box_level = 0\n        self.open_box(box)\n\n    def open_box(self, box: urwid.Widget):\n        self.original_widget = urwid.Overlay(\n            urwid.LineBox(\n                urwid.Padding(box, align=urwid.CENTER, left=2, right=2)\n            ),\n            self.original_widget,\n            align=urwid.CENTER,\n            width=(urwid.RELATIVE, 80),\n            valign=urwid.MIDDLE,\n            height=(urwid.RELATIVE, 80),\n            min_width=24,\n            min_height=8,\n            left=self.box_level * 3,\n            right=(self.max_box_levels - self.box_level - 1) * 3,\n            top=self.box_level * 2,\n            bottom=(self.max_box_levels - self.box_level - 1) * 2,\n        )\n        self.box_level += 1\n\n    def back(self) -&gt; Optional[NoReturn]:\n        self.original_widget = self.original_widget[0]\n        self.box_level -= 1\n        return None\n\n    def exit(self):\n        raise urwid.ExitMainLoop()\n\n    def keypress(self, size, key: str) -&gt; Union[str, NoReturn, None]:\n        if key == \"esc\":\n            if self.box_level &gt; 1:\n                self.back()\n            else:\n                exit_program()\n        return super().keypress(size, key)\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.box_level","title":"<code>box_level = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.CascadingBoxes.max_box_levels","title":"<code>max_box_levels = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.CascadingBoxes.__init__","title":"<code>__init__(box)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def __init__(self, box: urwid.Widget) -&gt; None:\n    super().__init__(urwid.SolidFill(\"/\"))\n    self.box_level = 0\n    self.open_box(box)\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.back","title":"<code>back()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def back(self) -&gt; Optional[NoReturn]:\n    self.original_widget = self.original_widget[0]\n    self.box_level -= 1\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.exit","title":"<code>exit()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def exit(self):\n    raise urwid.ExitMainLoop()\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.keypress","title":"<code>keypress(size, key)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def keypress(self, size, key: str) -&gt; Union[str, NoReturn, None]:\n    if key == \"esc\":\n        if self.box_level &gt; 1:\n            self.back()\n        else:\n            exit_program()\n    return super().keypress(size, key)\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.open_box","title":"<code>open_box(box)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def open_box(self, box: urwid.Widget):\n    self.original_widget = urwid.Overlay(\n        urwid.LineBox(\n            urwid.Padding(box, align=urwid.CENTER, left=2, right=2)\n        ),\n        self.original_widget,\n        align=urwid.CENTER,\n        width=(urwid.RELATIVE, 80),\n        valign=urwid.MIDDLE,\n        height=(urwid.RELATIVE, 80),\n        min_width=24,\n        min_height=8,\n        left=self.box_level * 3,\n        right=(self.max_box_levels - self.box_level - 1) * 3,\n        top=self.box_level * 2,\n        bottom=(self.max_box_levels - self.box_level - 1) * 2,\n    )\n    self.box_level += 1\n</code></pre>"},{"location":"api/#ktoolbox.editor.EditWithSignalWidget","title":"<code>EditWithSignalWidget</code>","text":"<p>               Bases: <code>Edit</code></p> <p>Custom <code>urwid.Edit</code>, support callback when changed.</p> Source code in <code>ktoolbox/editor.py</code> <pre><code>class EditWithSignalWidget(urwid.Edit):\n    \"\"\"\n    Custom ``urwid.Edit``, support callback when changed.\n    \"\"\"\n\n    def __init__(\n            self,\n            *args,\n            on_state_change: Optional[Callable[[EditWithSignalWidget, _T], Any]],\n            user_data: Optional[_T],\n            **kwargs\n    ) -&gt; None:\n        self.__on_state_change = on_state_change\n        self.__user_data = user_data\n        super().__init__(*args, **kwargs)\n\n    def keypress(self, size: Tuple[int], key: str) -&gt; Union[str, None]:\n        ret = super().keypress(size, key)\n        self.__on_state_change(self, self.__user_data)\n        return ret\n</code></pre>"},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.__on_state_change","title":"<code>__on_state_change = on_state_change</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.__user_data","title":"<code>__user_data = user_data</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.__init__","title":"<code>__init__(*args, on_state_change, user_data, **kwargs)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def __init__(\n        self,\n        *args,\n        on_state_change: Optional[Callable[[EditWithSignalWidget, _T], Any]],\n        user_data: Optional[_T],\n        **kwargs\n) -&gt; None:\n    self.__on_state_change = on_state_change\n    self.__user_data = user_data\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.keypress","title":"<code>keypress(size, key)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def keypress(self, size: Tuple[int], key: str) -&gt; Union[str, None]:\n    ret = super().keypress(size, key)\n    self.__on_state_change(self, self.__user_data)\n    return ret\n</code></pre>"},{"location":"api/#ktoolbox.editor.dump_envs","title":"<code>dump_envs(model)</code>","text":"<p>Dump environment variables, with no Env prefix</p> Source code in <code>ktoolbox/editor.py</code> <pre><code>def dump_envs(model: BaseModel) -&gt; List[str]:\n    \"\"\"Dump environment variables, with no Env prefix\"\"\"\n    envs = []\n    for field in model.model_fields:\n        value = model.__getattribute__(field)\n        if isinstance(value, BaseModel):\n            for env in dump_envs(value):\n                envs.append(f\"{field.upper()}__{env}\")\n        else:\n            envs.append(\n                f\"{field.upper()}=\"\n                f\"{json.dumps(list(value)) if isinstance(value, (list, set, tuple, dict)) else model.__pydantic_serializer__.to_python(value)}\"\n            )\n    return envs\n</code></pre>"},{"location":"api/#ktoolbox.editor.dump_modified_envs","title":"<code>dump_modified_envs(envs)</code>","text":"<p>Dump modified environment variables, with Env prefix</p> <p>Parameters:</p> Name Type Description Default <code>envs</code> <code>List[str]</code> <p>Current Envs</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def dump_modified_envs(envs: List[str]) -&gt; List[str]:\n    \"\"\"\n    Dump modified environment variables, with Env prefix\n\n    :param envs: Current Envs\n    \"\"\"\n    return sorted([\n        f\"KTOOLBOX_{env}\" for env in set(envs) - default_config_envs\n    ])\n</code></pre>"},{"location":"api/#ktoolbox.editor.exit_program","title":"<code>exit_program(_=None)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def exit_program(_: urwid.Button = None) -&gt; Optional[NoReturn]:\n    if has_changed():\n        top.open_box(\n            urwid.Filler(\n                urwid.Pile([\n                    urwid.Text(\"Any unsaved changes will be lost. Are you sure you want to EXIT?\"),\n                    urwid.Divider(),\n                    menu_option(urwid.Button(\n                        \"NO\", lambda x: top.back()\n                    )),\n                    menu_option(urwid.Button(\n                        \"YES\", lambda x: top.exit()\n                    )),\n                ])\n            )\n        )\n    else:\n        top.exit()\n</code></pre>"},{"location":"api/#ktoolbox.editor.get_item","title":"<code>get_item(model, field, get_value_callback, widget_list, list_walker)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def get_item(\n        model: BaseModel,\n        field: str,\n        get_value_callback: Callable[[EditWithSignalWidget], Optional[Any]],\n        widget_list: List[urwid.WidgetPlaceholder],\n        list_walker: urwid.ListWalker\n) -&gt; Callable[[str], urwid.WidgetPlaceholder]:\n    def inner(edit_text: str = \"\"):\n        item = urwid.WidgetPlaceholder(urwid.Widget())\n        edit_widget = EditWithSignalWidget(\n            edit_text=edit_text,\n            align=urwid.LEFT,\n            on_state_change=on_item_changed,\n            user_data=(model, field, get_value_callback, widget_list, item)\n        )\n        columns_widget = urwid.Columns([\n            edit_widget,\n            urwid.Divider(),\n            urwid.Divider(),\n            urwid.Button(\n                \"Remove -\",\n                on_remove_item,\n                (model, field, widget_list, item, list_walker)\n            )\n        ])\n        item.original_widget = columns_widget\n        return item\n\n    return inner\n</code></pre>"},{"location":"api/#ktoolbox.editor.get_value","title":"<code>get_value(item_types)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def get_value(item_types: Sequence[type]) -&gt; Callable[[EditWithSignalWidget], Optional[Any]]:\n    def inner(w: EditWithSignalWidget = None):\n        for t in item_types:\n            try:\n                return t(w.get_edit_text()) if w is not None else t()\n            except ValueError:\n                continue\n        return None\n\n    return inner\n</code></pre>"},{"location":"api/#ktoolbox.editor.has_changed","title":"<code>has_changed()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def has_changed() -&gt; bool:\n    return bool(set(dump_envs(config)) - initial_envs)\n</code></pre>"},{"location":"api/#ktoolbox.editor.menu","title":"<code>menu(title, choices)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def menu(\n        title: Union[str, Tuple[Hashable, str], List[Union[str, Tuple[Hashable, str]]]],\n        choices: Iterable[urwid.Widget],\n) -&gt; urwid.ListBox:\n    body = [urwid.Text(title, align=urwid.CENTER), urwid.Divider(), *choices]\n    return urwid.ListBox(urwid.SimpleFocusListWalker(body))\n</code></pre>"},{"location":"api/#ktoolbox.editor.menu_option","title":"<code>menu_option(widget)</code>","text":"<p>Return <code>focus_map=\"reversed\"</code> Widget</p> Source code in <code>ktoolbox/editor.py</code> <pre><code>def menu_option(widget: urwid.Widget) -&gt; urwid.AttrMap:\n    \"\"\"Return ``focus_map=\"reversed\"`` Widget\"\"\"\n    return urwid.AttrMap(widget, None, focus_map=\"reversed\")\n</code></pre>"},{"location":"api/#ktoolbox.editor.model_to_widgets","title":"<code>model_to_widgets(model, fields=None)</code>","text":"<p>Generate urwid widgets for Pydantic model</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>Pydantic model</p> required <code>fields</code> <code>Iterable[str]</code> <p>Only generate for these fields, default to all fields.</p> <code>None</code> Source code in <code>ktoolbox/editor.py</code> <pre><code>def model_to_widgets(model: BaseModel, fields: Iterable[str] = None) -&gt; Generator[urwid.Widget, Any, None]:\n    \"\"\"\n    Generate urwid widgets for Pydantic model\n\n    :param model: Pydantic model\n    :param fields: Only generate for these fields, default to all fields.\n    \"\"\"\n    for field, field_info in model.model_fields.items():\n        if fields is not None and field not in fields:\n            continue\n        origin_annotation = getattr(field_info.annotation, '__origin__', None)\n        annotation = get_args(field_info.annotation) if origin_annotation is Union else [field_info.annotation]\n\n        if origin_annotation is Literal:\n            radio_buttons = []\n            for value in get_args(field_info.annotation):\n                menu_option(urwid.RadioButton(\n                    radio_buttons,\n                    str(value),\n                    model.__getattribute__(field) == value,\n                    on_radio_button_change,\n                    (model, field, value)\n                ))\n            yield sub_menu(field, radio_buttons)\n        elif bool in annotation:\n            yield menu_option(urwid.CheckBox(\n                field,\n                model.__getattribute__(field),\n                on_state_change=on_checkbox_change,\n                user_data=(model, field)\n            ))\n        elif any(map(lambda x: x in annotation, [str, int, float, Path])):\n            yield menu_option(urwid.Columns([\n                urwid.Text(f\"{' ' * 4}{field}\", align=urwid.LEFT),\n                EditWithSignalWidget(\n                    edit_text=str(model.__getattribute__(field)),\n                    align=urwid.RIGHT,\n                    on_state_change=on_edit_change,\n                    user_data=(model, field, annotation)\n                )\n            ]))\n        elif origin_annotation in [list, set, tuple]:\n            item_types = get_args(field_info.annotation)\n            widget_list = []\n            widget, menu_widget = sub_menu_with_menu_widget(field, [])\n            list_walker: urwid.SimpleFocusListWalker = menu_widget.body  # type: ignore\n            widget_list.extend([\n                get_item(model, field, get_value(item_types), widget_list, list_walker)\n                (str(existed)) for existed in model.__getattribute__(field)\n            ])\n            # noinspection PyTypeChecker\n            option_widget = menu_option(\n                urwid.Button(\n                    \"Add +\",\n                    on_add_item,\n                    (\n                        model,\n                        field,\n                        get_value(item_types),\n                        widget_list,\n                        get_item(model, field, get_value(item_types), widget_list, list_walker),\n                        list_walker\n                    )\n                )\n            )\n            list_walker.extend([urwid.Divider(), option_widget, urwid.Divider()])\n            list_walker.extend(widget_list)\n            yield widget\n        elif isinstance(field_info.annotation, ModelMetaclass):\n            yield sub_menu(field, model_to_widgets(model.__getattribute__(field)))\n        else:\n            yield sub_menu(\n                field,\n                [urwid.Text(\n                    f\"This option ({repr(field_info.annotation)}) is currently not supported for editing in \"\n                    \"the graphical interface; please edit it in the '.env' or 'prod.env' file in the working directory.\"\n                )]\n            )\n    yield urwid.Divider()\n    yield menu_option(urwid.Button(\n        f\"View Document: {type(model).__name__}\", lambda x: webbrowser.open(\n            f\"https://ktoolbox.readthedocs.io/latest/configuration/reference/#ktoolbox.configuration.{type(model).__name__}\"\n        )\n    ))\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_add_item","title":"<code>on_add_item(_, user_data)</code>","text":"<p>Call when add item to List/Set/Tuple field</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Button</code> <p>Widget</p> required <code>user_data</code> <code>Tuple[BaseModel, str, Callable[[], Optional[Any]], Union[List[_T], List[None]], Callable[[], _T], Union[MonitoredFocusList[_T], ListWalker]]</code> <p>(model, field, () -&gt; (default value), item list, () -&gt; (new item), menu widget)</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_add_item(\n        _: urwid.Button,\n        user_data: Tuple[\n            BaseModel,\n            str,\n            Callable[[], Optional[Any]],\n            Union[List[_T], List[None]],\n            Callable[[], _T],\n            Union[urwid.MonitoredFocusList[_T], urwid.ListWalker]\n        ]\n):\n    \"\"\"\n    Call when add item to List/Set/Tuple field\n\n    :param _: Widget\n    :param user_data: (model, field, () -&gt; (default value), item list, () -&gt; (new item), menu widget)\n    \"\"\"\n    model, field, get_default, item_list, get_new_widget, widget = user_data\n    values = list(model.__getattribute__(field))\n    values.append(get_default())\n    model.__setattr__(field, values)\n    new_widget = get_new_widget()\n    item_list.append(new_widget)\n    widget.append(new_widget)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_checkbox_change","title":"<code>on_checkbox_change(_, state, user_data)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_checkbox_change(_: urwid.CheckBox, state: bool, user_data: Tuple[BaseModel, str]):\n    model, field = user_data\n    model.__setattr__(field, state)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_edit_change","title":"<code>on_edit_change(widget, user_data)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_edit_change(widget: urwid.EditWithSignalWidget, user_data: Tuple[BaseModel, str, Iterable[type]]):\n    model, field, annotation = user_data\n    for field_type in annotation:\n        try:\n            model.__setattr__(field, field_type(widget.get_edit_text()))\n        except ValueError:\n            continue\n        else:\n            break\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_item_changed","title":"<code>on_item_changed(widget, user_data)</code>","text":"<p>Call when List/Set/Tuple field item changed</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>EditWithSignalWidget</code> <p>Widget</p> required <code>user_data</code> <code>Tuple[BaseModel, str, Callable[[EditWithSignalWidget], Any], Union[List[_T], List[None]], _T]</code> <p>(model, field, (edit widget) -&gt; (value), item list, item)</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_item_changed(\n        widget: EditWithSignalWidget,\n        user_data: Tuple[\n            BaseModel,\n            str,\n            Callable[[EditWithSignalWidget], Any],\n            Union[List[_T], List[None]],\n            _T\n        ]\n):\n    \"\"\"\n    Call when List/Set/Tuple field item changed\n\n    :param widget: Widget\n    :param user_data: (model, field, (edit widget) -&gt; (value), item list, item)\n    \"\"\"\n    model, field, get_value_callback, item_list, item = user_data\n    values = list(model.__getattribute__(field))\n    index = item_list.index(item)\n    values[index] = get_value_callback(widget)\n    model.__setattr__(field, values)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_radio_button_change","title":"<code>on_radio_button_change(_, state, user_data)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_radio_button_change(_: urwid.RadioButton, state: bool, user_data: Tuple[BaseModel, str, Any]):\n    if state:\n        model, field, value = user_data\n        model.__setattr__(field, value)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_remove_item","title":"<code>on_remove_item(_, user_data)</code>","text":"<p>Call when remove item to List/Set/Tuple field</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Button</code> <p>Widget</p> required <code>user_data</code> <code>Tuple[BaseModel, str, Union[List[_T], List[None]], _T, Union[MonitoredFocusList[_T], ListWalker]]</code> <p>(model, field, item list, item, menu widget)</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_remove_item(\n        _: urwid.Button,\n        user_data: Tuple[\n            BaseModel,\n            str,\n            Union[List[_T], List[None]],\n            _T,\n            Union[urwid.MonitoredFocusList[_T], urwid.ListWalker]\n        ]\n):\n    \"\"\"\n    Call when remove item to List/Set/Tuple field\n\n    :param _: Widget\n    :param user_data: (model, field, item list, item, menu widget)\n    \"\"\"\n    model, field, item_list, item, widget = user_data\n    values = list(model.__getattribute__(field))\n    index = item_list.index(item)\n    values.pop(index)\n    model.__setattr__(field, values)\n    item_list.pop(index)\n    widget.remove(item)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_save_dotenv","title":"<code>on_save_dotenv(_)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_save_dotenv(_: urwid.Button):\n    if has_changed():\n        pile = urwid.Pile([\n            urwid.Text(\"Your changes have been saved.\"),\n            urwid.Divider(),\n            menu_option(urwid.Button(\n                \"OK\", lambda x: top.back()\n            )),\n        ])\n        try:\n            save_dotenv()\n        except Exception as e:\n            pile = urwid.Pile([\n                urwid.Text(\"Unable to save changes!\"),\n                urwid.Divider(),\n                urwid.Text(f\"{type(e).__name__}: {e}\"),\n                urwid.Divider(),\n                menu_option(urwid.Button(\n                    \"OK\", lambda x: top.back()\n                )),\n            ])\n    else:\n        pile = urwid.Pile([\n            urwid.Text(\"Nothing has changed, no need to save.\"),\n            urwid.Divider(),\n            menu_option(urwid.Button(\n                \"OK\", lambda x: top.back()\n            )),\n        ])\n    top.open_box(urwid.Filler(pile))\n</code></pre>"},{"location":"api/#ktoolbox.editor.run_config_editor","title":"<code>run_config_editor()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def run_config_editor():\n    urwid.MainLoop(top, palette=[(\"reversed\", \"standout\", \"\")]).run()\n</code></pre>"},{"location":"api/#ktoolbox.editor.save_dotenv","title":"<code>save_dotenv()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def save_dotenv():\n    current_envs = dump_envs(config)\n    envs_to_dump = \"\\n\".join(dump_modified_envs(current_envs))\n    prod_dotenv_path = Path(\"prod.env\")\n    dotenv_path = Path(\".env\")\n    if prod_dotenv_path.is_file():\n        with prod_dotenv_path.open(\"w\") as f:\n            f.write(envs_to_dump)\n    else:\n        with dotenv_path.open(\"w\") as f:\n            f.write(envs_to_dump)\n    initial_envs.clear()\n    initial_envs.update(current_envs)\n</code></pre>"},{"location":"api/#ktoolbox.editor.sub_menu","title":"<code>sub_menu(caption, choices)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def sub_menu(\n        caption: Union[str, Tuple[Hashable, str], List[Union[str, Tuple[Hashable, str]]]],\n        choices: Iterable[urwid.Widget],\n) -&gt; urwid.AttrMap[urwid.Button]:\n    button, _ = sub_menu_with_menu_widget(caption, choices)\n    return button\n</code></pre>"},{"location":"api/#ktoolbox.editor.sub_menu_with_menu_widget","title":"<code>sub_menu_with_menu_widget(caption, choices)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def sub_menu_with_menu_widget(\n        caption: Union[str, Tuple[Hashable, str], List[Union[str, Tuple[Hashable, str]]]],\n        choices: Iterable[urwid.Widget],\n) -&gt; Tuple[urwid.AttrMap[urwid.Button], urwid.ListBox]:\n    contents = menu(\n        caption,\n        list(choices) + [\n            urwid.Divider(bottom=2),\n            menu_option(urwid.Button(\n                \"Back\", lambda x: top.back()\n            ))\n        ]\n    )\n\n    return menu_option(urwid.Button(\n        [caption, \"...\"],\n        lambda x: top.open_box(contents)\n    )), contents\n</code></pre>"},{"location":"api/#ktoolbox.job","title":"<code>job</code>","text":""},{"location":"api/#ktoolbox.job.CreatorIndices","title":"<code>CreatorIndices</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Creator directory indices model</p> <p>Record the path of each downloaded post.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class CreatorIndices(BaseKToolBoxData):\n    \"\"\"\n    Creator directory indices model\n\n    Record the path of each downloaded post.\n    \"\"\"\n    creator_id: str\n    \"\"\"Creator ID\"\"\"\n    service: str\n    \"\"\"Creator service\"\"\"\n    posts: Dict[str, Post] = {}\n    \"\"\"All posts, ``id`` -&gt; ``Post``\"\"\"\n    posts_path: Dict[str, Path] = {}\n    \"\"\"Posts and their path, ``id`` -&gt; ``Path``\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.CreatorIndices.creator_id","title":"<code>creator_id: str</code>  <code>instance-attribute</code>","text":"<p>Creator ID</p>"},{"location":"api/#ktoolbox.job.CreatorIndices.posts","title":"<code>posts: Dict[str, Post] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All posts, <code>id</code> -&gt; <code>Post</code></p>"},{"location":"api/#ktoolbox.job.CreatorIndices.posts_path","title":"<code>posts_path: Dict[str, Path] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Posts and their path, <code>id</code> -&gt; <code>Path</code></p>"},{"location":"api/#ktoolbox.job.CreatorIndices.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>Creator service</p>"},{"location":"api/#ktoolbox.job.Job","title":"<code>Job</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Download job model</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class Job(BaseModel):\n    \"\"\"\n    Download job model\n    \"\"\"\n    path: Path\n    \"\"\"Directory path to save the file\"\"\"\n    alt_filename: Optional[str] = None\n    \"\"\"Use this name if no filename given by the server\"\"\"\n    server_path: str\n    \"\"\"The `path` part of download URL\"\"\"\n    type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None\n    \"\"\"Target file type\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.Job.alt_filename","title":"<code>alt_filename: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use this name if no filename given by the server</p>"},{"location":"api/#ktoolbox.job.Job.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.job.Job.server_path","title":"<code>server_path: str</code>  <code>instance-attribute</code>","text":"<p>The <code>path</code> part of download URL</p>"},{"location":"api/#ktoolbox.job.Job.type","title":"<code>type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target file type</p>"},{"location":"api/#ktoolbox.job.JobListData","title":"<code>JobListData</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Download job list data model</p> <p>For saving the list of jobs to disk.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class JobListData(BaseKToolBoxData):\n    \"\"\"\n    Download job list data model\n\n    For saving the list of jobs to disk.\n    \"\"\"\n    jobs: List[Job] = []\n    \"\"\"All jobs\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.JobListData.jobs","title":"<code>jobs: List[Job] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All jobs</p>"},{"location":"api/#ktoolbox.job.JobRunner","title":"<code>JobRunner</code>","text":"Source code in <code>ktoolbox/job/runner.py</code> <pre><code>class JobRunner:\n    def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True):\n        \"\"\"\n        Create a job runner\n\n        :param job_list: Jobs to initial ``self._job_queue``\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        \"\"\"\n        job_list = job_list or []\n        self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n        for job in job_list:\n            self._job_queue.put_nowait(job)\n        self._tqdm_class = tqdm_class\n        self._progress = progress\n        self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n        self._concurrent_tasks: Set[asyncio.Task] = set()\n        self._lock = asyncio.Lock()\n\n    @property\n    def finished(self):\n        \"\"\"\n        Check if all jobs finished\n\n        :return: ``False`` if **in process**, ``False`` otherwise\n        \"\"\"\n        return not self._lock.locked()\n\n    @cached_property\n    def downloaders(self):\n        \"\"\"Get downloaders with task\"\"\"\n        return MappingProxyType(self._downloaders_with_task)\n\n    @property\n    def waiting_size(self) -&gt; int:\n        \"\"\"Get the number of jobs waiting to be processed\"\"\"\n        return self._job_queue.qsize()\n\n    @property\n    def done_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that done\"\"\"\n        size = 0\n        for downloader, task in self._downloaders_with_task.items():\n            if downloader.finished or task.done():\n                size += 1\n        return size\n\n    @property\n    def processing_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that in process\"\"\"\n        return len(self._downloaders_with_task) - self.done_size\n\n    async def processor(self) -&gt; int:\n        \"\"\"\n        Process each job in ``self._job_queue``\n\n        :return: Number of jobs that failed\n        \"\"\"\n        failed_num = 0\n        async with httpx.AsyncClient(\n                verify=config.ssl_verify,\n                cookies={\"session\": config.api.session_key} if config.api.session_key else None\n        ) as client:\n            while not self._job_queue.empty():\n                job = await self._job_queue.get()\n\n                # Create downloader\n                url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n                url = str(urlunparse(url_parts))\n                downloader = Downloader(\n                    url=url,\n                    path=job.path,\n                    client=client,\n                    designated_filename=job.alt_filename,\n                    server_path=job.server_path\n                )\n\n                # Create task\n                task = asyncio.create_task(\n                    downloader.run(\n                        tqdm_class=self._tqdm_class,\n                        progress=self._progress\n                    )\n                )\n                self._downloaders_with_task[downloader] = task\n                # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n                #   Delete this for counting finished job tasks\n\n                # Run task\n                task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n                task_done = task_done_set.pop()\n                try:\n                    exception = task_done.exception()\n                except CancelledError as e:\n                    exception = e\n                if not exception:  # raise Exception when cancelled or other exceptions\n                    ret = task_done.result()\n                    if ret.code == RetCodeEnum.Success:\n                        logger.success(\n                            generate_msg(\n                                \"Download success\",\n                                filename=ret.data\n                            )\n                        )\n                    elif ret.code == RetCodeEnum.FileExisted:\n                        logger.warning(ret.message)\n                    else:\n                        logger.error(ret.message)\n                        failed_num += 1\n                elif isinstance(exception, CancelledError):\n                    logger.warning(\n                        generate_msg(\n                            \"Download cancelled\",\n                            filename=job.alt_filename\n                        )\n                    )\n                else:\n                    logger.error(\n                        generate_msg(\n                            \"Download failed\",\n                            filename=job.alt_filename,\n                            exception=exception\n                        )\n                    )\n                    failed_num += 1\n                self._job_queue.task_done()\n        await self._job_queue.join()\n        return failed_num\n\n    async def _watch_status(self):\n        \"\"\"\n        Watch running, completed, failed jobs\n        \"\"\"\n        while not self._job_queue.empty():\n            await asyncio.sleep(30)\n            logger.info(f\"Waiting: {self.waiting_size} / \"\n                        f\"Running: {self.processing_size} / \"\n                        f\"Completed: {self.done_size} \"\n                        f\"({(self.done_size / (self.waiting_size + self.processing_size + self.done_size)) * 100:.2f}%)\")\n\n    async def start(self):\n        \"\"\"\n        Start processing jobs concurrently\n\n        It will **Block** until other call of ``self.start()`` method finished\n        \"\"\"\n        failed_num = 0\n        async with self._lock:\n            self._concurrent_tasks.clear()\n            for _ in range(config.job.count):\n                task = asyncio.create_task(self.processor())\n                self._concurrent_tasks.add(task)\n                task.add_done_callback(self._concurrent_tasks.discard)\n            _, (task_done_set, _) = await asyncio.gather(\n                self._watch_status(),\n                asyncio.wait(self._concurrent_tasks)\n            )\n            for task in task_done_set:\n                try:\n                    failed_num += task.result()\n                except CancelledError:\n                    pass\n        if failed_num:\n            logger.warning(generate_msg(f\"{failed_num} jobs failed, download finished\"))\n        else:\n            logger.success(generate_msg(\"All jobs in queue finished\"))\n        return failed_num\n\n    async def add_jobs(self, *jobs: Job):\n        \"\"\"Add jobs to ``self._job_queue``\"\"\"\n        for job in jobs:\n            await self._job_queue.put(job)\n\n    @staticmethod\n    async def _force_cancel(target: asyncio.Task, wait_time: float = None) -&gt; bool:\n        \"\"\"\n        Force cancel ``asyncio.Task`` after ``wait_time`` seconds\n\n        :param target: Target task\n        :param wait_time: Seconds to wait before cancel (``0`` for skip one event loop run cycle)\n        :return: Whether cancelled successfully\n        \"\"\"\n        if wait_time is not None:\n            await asyncio.sleep(wait_time)\n        return target.cancel()\n\n    async def cancel_downloader(self, target: Downloader) -&gt; bool:\n        \"\"\"\n        Cancel downloader\n\n        :return: Whether cancelled successfully\n        \"\"\"\n        task = self._downloaders_with_task[target]\n        if not task.done():\n            target.cancel()\n            return await self._force_cancel(task, 0) or task.done()\n        return True\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.done_size","title":"<code>done_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that done</p>"},{"location":"api/#ktoolbox.job.JobRunner.downloaders","title":"<code>downloaders</code>  <code>cached</code> <code>property</code>","text":"<p>Get downloaders with task</p>"},{"location":"api/#ktoolbox.job.JobRunner.finished","title":"<code>finished</code>  <code>property</code>","text":"<p>Check if all jobs finished</p> <p>Returns:</p> Type Description <p><code>False</code> if in process, <code>False</code> otherwise</p>"},{"location":"api/#ktoolbox.job.JobRunner.processing_size","title":"<code>processing_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that in process</p>"},{"location":"api/#ktoolbox.job.JobRunner.waiting_size","title":"<code>waiting_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs waiting to be processed</p>"},{"location":"api/#ktoolbox.job.JobRunner.__init__","title":"<code>__init__(*, job_list=None, tqdm_class=None, progress=True)</code>","text":"<p>Create a job runner</p> <p>Parameters:</p> Name Type Description Default <code>job_list</code> <code>List[Job]</code> <p>Jobs to initial <code>self._job_queue</code></p> <code>None</code> <code>tqdm_class</code> <code>tqdm</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>True</code> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True):\n    \"\"\"\n    Create a job runner\n\n    :param job_list: Jobs to initial ``self._job_queue``\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    \"\"\"\n    job_list = job_list or []\n    self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n    for job in job_list:\n        self._job_queue.put_nowait(job)\n    self._tqdm_class = tqdm_class\n    self._progress = progress\n    self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n    self._concurrent_tasks: Set[asyncio.Task] = set()\n    self._lock = asyncio.Lock()\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.add_jobs","title":"<code>add_jobs(*jobs)</code>  <code>async</code>","text":"<p>Add jobs to <code>self._job_queue</code></p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def add_jobs(self, *jobs: Job):\n    \"\"\"Add jobs to ``self._job_queue``\"\"\"\n    for job in jobs:\n        await self._job_queue.put(job)\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.cancel_downloader","title":"<code>cancel_downloader(target)</code>  <code>async</code>","text":"<p>Cancel downloader</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether cancelled successfully</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def cancel_downloader(self, target: Downloader) -&gt; bool:\n    \"\"\"\n    Cancel downloader\n\n    :return: Whether cancelled successfully\n    \"\"\"\n    task = self._downloaders_with_task[target]\n    if not task.done():\n        target.cancel()\n        return await self._force_cancel(task, 0) or task.done()\n    return True\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.processor","title":"<code>processor()</code>  <code>async</code>","text":"<p>Process each job in <code>self._job_queue</code></p> <p>Returns:</p> Type Description <code>int</code> <p>Number of jobs that failed</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def processor(self) -&gt; int:\n    \"\"\"\n    Process each job in ``self._job_queue``\n\n    :return: Number of jobs that failed\n    \"\"\"\n    failed_num = 0\n    async with httpx.AsyncClient(\n            verify=config.ssl_verify,\n            cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    ) as client:\n        while not self._job_queue.empty():\n            job = await self._job_queue.get()\n\n            # Create downloader\n            url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n            url = str(urlunparse(url_parts))\n            downloader = Downloader(\n                url=url,\n                path=job.path,\n                client=client,\n                designated_filename=job.alt_filename,\n                server_path=job.server_path\n            )\n\n            # Create task\n            task = asyncio.create_task(\n                downloader.run(\n                    tqdm_class=self._tqdm_class,\n                    progress=self._progress\n                )\n            )\n            self._downloaders_with_task[downloader] = task\n            # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n            #   Delete this for counting finished job tasks\n\n            # Run task\n            task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n            task_done = task_done_set.pop()\n            try:\n                exception = task_done.exception()\n            except CancelledError as e:\n                exception = e\n            if not exception:  # raise Exception when cancelled or other exceptions\n                ret = task_done.result()\n                if ret.code == RetCodeEnum.Success:\n                    logger.success(\n                        generate_msg(\n                            \"Download success\",\n                            filename=ret.data\n                        )\n                    )\n                elif ret.code == RetCodeEnum.FileExisted:\n                    logger.warning(ret.message)\n                else:\n                    logger.error(ret.message)\n                    failed_num += 1\n            elif isinstance(exception, CancelledError):\n                logger.warning(\n                    generate_msg(\n                        \"Download cancelled\",\n                        filename=job.alt_filename\n                    )\n                )\n            else:\n                logger.error(\n                    generate_msg(\n                        \"Download failed\",\n                        filename=job.alt_filename,\n                        exception=exception\n                    )\n                )\n                failed_num += 1\n            self._job_queue.task_done()\n    await self._job_queue.join()\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start processing jobs concurrently</p> <p>It will Block until other call of <code>self.start()</code> method finished</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Start processing jobs concurrently\n\n    It will **Block** until other call of ``self.start()`` method finished\n    \"\"\"\n    failed_num = 0\n    async with self._lock:\n        self._concurrent_tasks.clear()\n        for _ in range(config.job.count):\n            task = asyncio.create_task(self.processor())\n            self._concurrent_tasks.add(task)\n            task.add_done_callback(self._concurrent_tasks.discard)\n        _, (task_done_set, _) = await asyncio.gather(\n            self._watch_status(),\n            asyncio.wait(self._concurrent_tasks)\n        )\n        for task in task_done_set:\n            try:\n                failed_num += task.result()\n            except CancelledError:\n                pass\n    if failed_num:\n        logger.warning(generate_msg(f\"{failed_num} jobs failed, download finished\"))\n    else:\n        logger.success(generate_msg(\"All jobs in queue finished\"))\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.job.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.job.model.__all__","title":"<code>__all__ = ['Job', 'JobListData', 'CreatorIndices']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.job.model.CreatorIndices","title":"<code>CreatorIndices</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Creator directory indices model</p> <p>Record the path of each downloaded post.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class CreatorIndices(BaseKToolBoxData):\n    \"\"\"\n    Creator directory indices model\n\n    Record the path of each downloaded post.\n    \"\"\"\n    creator_id: str\n    \"\"\"Creator ID\"\"\"\n    service: str\n    \"\"\"Creator service\"\"\"\n    posts: Dict[str, Post] = {}\n    \"\"\"All posts, ``id`` -&gt; ``Post``\"\"\"\n    posts_path: Dict[str, Path] = {}\n    \"\"\"Posts and their path, ``id`` -&gt; ``Path``\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.creator_id","title":"<code>creator_id: str</code>  <code>instance-attribute</code>","text":"<p>Creator ID</p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.posts","title":"<code>posts: Dict[str, Post] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All posts, <code>id</code> -&gt; <code>Post</code></p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.posts_path","title":"<code>posts_path: Dict[str, Path] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Posts and their path, <code>id</code> -&gt; <code>Path</code></p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>Creator service</p>"},{"location":"api/#ktoolbox.job.model.Job","title":"<code>Job</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Download job model</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class Job(BaseModel):\n    \"\"\"\n    Download job model\n    \"\"\"\n    path: Path\n    \"\"\"Directory path to save the file\"\"\"\n    alt_filename: Optional[str] = None\n    \"\"\"Use this name if no filename given by the server\"\"\"\n    server_path: str\n    \"\"\"The `path` part of download URL\"\"\"\n    type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None\n    \"\"\"Target file type\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.Job.alt_filename","title":"<code>alt_filename: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use this name if no filename given by the server</p>"},{"location":"api/#ktoolbox.job.model.Job.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.job.model.Job.server_path","title":"<code>server_path: str</code>  <code>instance-attribute</code>","text":"<p>The <code>path</code> part of download URL</p>"},{"location":"api/#ktoolbox.job.model.Job.type","title":"<code>type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target file type</p>"},{"location":"api/#ktoolbox.job.model.JobListData","title":"<code>JobListData</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Download job list data model</p> <p>For saving the list of jobs to disk.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class JobListData(BaseKToolBoxData):\n    \"\"\"\n    Download job list data model\n\n    For saving the list of jobs to disk.\n    \"\"\"\n    jobs: List[Job] = []\n    \"\"\"All jobs\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.JobListData.jobs","title":"<code>jobs: List[Job] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All jobs</p>"},{"location":"api/#ktoolbox.job.runner","title":"<code>runner</code>","text":""},{"location":"api/#ktoolbox.job.runner.__all__","title":"<code>__all__ = ['JobRunner']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.job.runner.JobRunner","title":"<code>JobRunner</code>","text":"Source code in <code>ktoolbox/job/runner.py</code> <pre><code>class JobRunner:\n    def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True):\n        \"\"\"\n        Create a job runner\n\n        :param job_list: Jobs to initial ``self._job_queue``\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        \"\"\"\n        job_list = job_list or []\n        self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n        for job in job_list:\n            self._job_queue.put_nowait(job)\n        self._tqdm_class = tqdm_class\n        self._progress = progress\n        self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n        self._concurrent_tasks: Set[asyncio.Task] = set()\n        self._lock = asyncio.Lock()\n\n    @property\n    def finished(self):\n        \"\"\"\n        Check if all jobs finished\n\n        :return: ``False`` if **in process**, ``False`` otherwise\n        \"\"\"\n        return not self._lock.locked()\n\n    @cached_property\n    def downloaders(self):\n        \"\"\"Get downloaders with task\"\"\"\n        return MappingProxyType(self._downloaders_with_task)\n\n    @property\n    def waiting_size(self) -&gt; int:\n        \"\"\"Get the number of jobs waiting to be processed\"\"\"\n        return self._job_queue.qsize()\n\n    @property\n    def done_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that done\"\"\"\n        size = 0\n        for downloader, task in self._downloaders_with_task.items():\n            if downloader.finished or task.done():\n                size += 1\n        return size\n\n    @property\n    def processing_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that in process\"\"\"\n        return len(self._downloaders_with_task) - self.done_size\n\n    async def processor(self) -&gt; int:\n        \"\"\"\n        Process each job in ``self._job_queue``\n\n        :return: Number of jobs that failed\n        \"\"\"\n        failed_num = 0\n        async with httpx.AsyncClient(\n                verify=config.ssl_verify,\n                cookies={\"session\": config.api.session_key} if config.api.session_key else None\n        ) as client:\n            while not self._job_queue.empty():\n                job = await self._job_queue.get()\n\n                # Create downloader\n                url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n                url = str(urlunparse(url_parts))\n                downloader = Downloader(\n                    url=url,\n                    path=job.path,\n                    client=client,\n                    designated_filename=job.alt_filename,\n                    server_path=job.server_path\n                )\n\n                # Create task\n                task = asyncio.create_task(\n                    downloader.run(\n                        tqdm_class=self._tqdm_class,\n                        progress=self._progress\n                    )\n                )\n                self._downloaders_with_task[downloader] = task\n                # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n                #   Delete this for counting finished job tasks\n\n                # Run task\n                task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n                task_done = task_done_set.pop()\n                try:\n                    exception = task_done.exception()\n                except CancelledError as e:\n                    exception = e\n                if not exception:  # raise Exception when cancelled or other exceptions\n                    ret = task_done.result()\n                    if ret.code == RetCodeEnum.Success:\n                        logger.success(\n                            generate_msg(\n                                \"Download success\",\n                                filename=ret.data\n                            )\n                        )\n                    elif ret.code == RetCodeEnum.FileExisted:\n                        logger.warning(ret.message)\n                    else:\n                        logger.error(ret.message)\n                        failed_num += 1\n                elif isinstance(exception, CancelledError):\n                    logger.warning(\n                        generate_msg(\n                            \"Download cancelled\",\n                            filename=job.alt_filename\n                        )\n                    )\n                else:\n                    logger.error(\n                        generate_msg(\n                            \"Download failed\",\n                            filename=job.alt_filename,\n                            exception=exception\n                        )\n                    )\n                    failed_num += 1\n                self._job_queue.task_done()\n        await self._job_queue.join()\n        return failed_num\n\n    async def _watch_status(self):\n        \"\"\"\n        Watch running, completed, failed jobs\n        \"\"\"\n        while not self._job_queue.empty():\n            await asyncio.sleep(30)\n            logger.info(f\"Waiting: {self.waiting_size} / \"\n                        f\"Running: {self.processing_size} / \"\n                        f\"Completed: {self.done_size} \"\n                        f\"({(self.done_size / (self.waiting_size + self.processing_size + self.done_size)) * 100:.2f}%)\")\n\n    async def start(self):\n        \"\"\"\n        Start processing jobs concurrently\n\n        It will **Block** until other call of ``self.start()`` method finished\n        \"\"\"\n        failed_num = 0\n        async with self._lock:\n            self._concurrent_tasks.clear()\n            for _ in range(config.job.count):\n                task = asyncio.create_task(self.processor())\n                self._concurrent_tasks.add(task)\n                task.add_done_callback(self._concurrent_tasks.discard)\n            _, (task_done_set, _) = await asyncio.gather(\n                self._watch_status(),\n                asyncio.wait(self._concurrent_tasks)\n            )\n            for task in task_done_set:\n                try:\n                    failed_num += task.result()\n                except CancelledError:\n                    pass\n        if failed_num:\n            logger.warning(generate_msg(f\"{failed_num} jobs failed, download finished\"))\n        else:\n            logger.success(generate_msg(\"All jobs in queue finished\"))\n        return failed_num\n\n    async def add_jobs(self, *jobs: Job):\n        \"\"\"Add jobs to ``self._job_queue``\"\"\"\n        for job in jobs:\n            await self._job_queue.put(job)\n\n    @staticmethod\n    async def _force_cancel(target: asyncio.Task, wait_time: float = None) -&gt; bool:\n        \"\"\"\n        Force cancel ``asyncio.Task`` after ``wait_time`` seconds\n\n        :param target: Target task\n        :param wait_time: Seconds to wait before cancel (``0`` for skip one event loop run cycle)\n        :return: Whether cancelled successfully\n        \"\"\"\n        if wait_time is not None:\n            await asyncio.sleep(wait_time)\n        return target.cancel()\n\n    async def cancel_downloader(self, target: Downloader) -&gt; bool:\n        \"\"\"\n        Cancel downloader\n\n        :return: Whether cancelled successfully\n        \"\"\"\n        task = self._downloaders_with_task[target]\n        if not task.done():\n            target.cancel()\n            return await self._force_cancel(task, 0) or task.done()\n        return True\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.done_size","title":"<code>done_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that done</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.downloaders","title":"<code>downloaders</code>  <code>cached</code> <code>property</code>","text":"<p>Get downloaders with task</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.finished","title":"<code>finished</code>  <code>property</code>","text":"<p>Check if all jobs finished</p> <p>Returns:</p> Type Description <p><code>False</code> if in process, <code>False</code> otherwise</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.processing_size","title":"<code>processing_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that in process</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.waiting_size","title":"<code>waiting_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs waiting to be processed</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.__init__","title":"<code>__init__(*, job_list=None, tqdm_class=None, progress=True)</code>","text":"<p>Create a job runner</p> <p>Parameters:</p> Name Type Description Default <code>job_list</code> <code>List[Job]</code> <p>Jobs to initial <code>self._job_queue</code></p> <code>None</code> <code>tqdm_class</code> <code>tqdm</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>True</code> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True):\n    \"\"\"\n    Create a job runner\n\n    :param job_list: Jobs to initial ``self._job_queue``\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    \"\"\"\n    job_list = job_list or []\n    self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n    for job in job_list:\n        self._job_queue.put_nowait(job)\n    self._tqdm_class = tqdm_class\n    self._progress = progress\n    self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n    self._concurrent_tasks: Set[asyncio.Task] = set()\n    self._lock = asyncio.Lock()\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.add_jobs","title":"<code>add_jobs(*jobs)</code>  <code>async</code>","text":"<p>Add jobs to <code>self._job_queue</code></p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def add_jobs(self, *jobs: Job):\n    \"\"\"Add jobs to ``self._job_queue``\"\"\"\n    for job in jobs:\n        await self._job_queue.put(job)\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.cancel_downloader","title":"<code>cancel_downloader(target)</code>  <code>async</code>","text":"<p>Cancel downloader</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether cancelled successfully</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def cancel_downloader(self, target: Downloader) -&gt; bool:\n    \"\"\"\n    Cancel downloader\n\n    :return: Whether cancelled successfully\n    \"\"\"\n    task = self._downloaders_with_task[target]\n    if not task.done():\n        target.cancel()\n        return await self._force_cancel(task, 0) or task.done()\n    return True\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.processor","title":"<code>processor()</code>  <code>async</code>","text":"<p>Process each job in <code>self._job_queue</code></p> <p>Returns:</p> Type Description <code>int</code> <p>Number of jobs that failed</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def processor(self) -&gt; int:\n    \"\"\"\n    Process each job in ``self._job_queue``\n\n    :return: Number of jobs that failed\n    \"\"\"\n    failed_num = 0\n    async with httpx.AsyncClient(\n            verify=config.ssl_verify,\n            cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    ) as client:\n        while not self._job_queue.empty():\n            job = await self._job_queue.get()\n\n            # Create downloader\n            url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n            url = str(urlunparse(url_parts))\n            downloader = Downloader(\n                url=url,\n                path=job.path,\n                client=client,\n                designated_filename=job.alt_filename,\n                server_path=job.server_path\n            )\n\n            # Create task\n            task = asyncio.create_task(\n                downloader.run(\n                    tqdm_class=self._tqdm_class,\n                    progress=self._progress\n                )\n            )\n            self._downloaders_with_task[downloader] = task\n            # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n            #   Delete this for counting finished job tasks\n\n            # Run task\n            task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n            task_done = task_done_set.pop()\n            try:\n                exception = task_done.exception()\n            except CancelledError as e:\n                exception = e\n            if not exception:  # raise Exception when cancelled or other exceptions\n                ret = task_done.result()\n                if ret.code == RetCodeEnum.Success:\n                    logger.success(\n                        generate_msg(\n                            \"Download success\",\n                            filename=ret.data\n                        )\n                    )\n                elif ret.code == RetCodeEnum.FileExisted:\n                    logger.warning(ret.message)\n                else:\n                    logger.error(ret.message)\n                    failed_num += 1\n            elif isinstance(exception, CancelledError):\n                logger.warning(\n                    generate_msg(\n                        \"Download cancelled\",\n                        filename=job.alt_filename\n                    )\n                )\n            else:\n                logger.error(\n                    generate_msg(\n                        \"Download failed\",\n                        filename=job.alt_filename,\n                        exception=exception\n                    )\n                )\n                failed_num += 1\n            self._job_queue.task_done()\n    await self._job_queue.join()\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start processing jobs concurrently</p> <p>It will Block until other call of <code>self.start()</code> method finished</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Start processing jobs concurrently\n\n    It will **Block** until other call of ``self.start()`` method finished\n    \"\"\"\n    failed_num = 0\n    async with self._lock:\n        self._concurrent_tasks.clear()\n        for _ in range(config.job.count):\n            task = asyncio.create_task(self.processor())\n            self._concurrent_tasks.add(task)\n            task.add_done_callback(self._concurrent_tasks.discard)\n        _, (task_done_set, _) = await asyncio.gather(\n            self._watch_status(),\n            asyncio.wait(self._concurrent_tasks)\n        )\n        for task in task_done_set:\n            try:\n                failed_num += task.result()\n            except CancelledError:\n                pass\n    if failed_num:\n        logger.warning(generate_msg(f\"{failed_num} jobs failed, download finished\"))\n    else:\n        logger.success(generate_msg(\"All jobs in queue finished\"))\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.model.__all__","title":"<code>__all__ = ['BaseKToolBoxData', 'SearchResult']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData","title":"<code>BaseKToolBoxData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all KToolBox data models.</p> Source code in <code>ktoolbox/model.py</code> <pre><code>class BaseKToolBoxData(BaseModel):\n    \"\"\"\n    Base class for all KToolBox data models.\n    \"\"\"\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        self.type = type(self)\n\n    version: str = __version__\n    type: Union[Type[\"BaseKToolBoxData\"], str] = None\n\n    @field_serializer('type')\n    def _(self, value: Type[\"BaseKToolBoxData\"], _info):\n        return str(value)\n</code></pre>"},{"location":"api/#ktoolbox.model.BaseKToolBoxData.type","title":"<code>type: Union[Type[BaseKToolBoxData], str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData.version","title":"<code>version: str = __version__</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData._","title":"<code>_(value, _info)</code>","text":"Source code in <code>ktoolbox/model.py</code> <pre><code>@field_serializer('type')\ndef _(self, value: Type[\"BaseKToolBoxData\"], _info):\n    return str(value)\n</code></pre>"},{"location":"api/#ktoolbox.model.BaseKToolBoxData.__init__","title":"<code>__init__(**data)</code>","text":"Source code in <code>ktoolbox/model.py</code> <pre><code>def __init__(self, **data: Any):\n    super().__init__(**data)\n    self.type = type(self)\n</code></pre>"},{"location":"api/#ktoolbox.model.SearchResult","title":"<code>SearchResult</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code>, <code>Generic[_T]</code></p> <p>Cli search result</p> Source code in <code>ktoolbox/model.py</code> <pre><code>class SearchResult(BaseKToolBoxData, Generic[_T]):\n    \"\"\"Cli search result\"\"\"\n    result: List[_T] = []\n</code></pre>"},{"location":"api/#ktoolbox.model.SearchResult.result","title":"<code>result: List[_T] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.utils.__all__","title":"<code>__all__ = ['BaseRet', 'generate_msg', 'logger_init', 'dump_search', 'parse_webpage_url', 'uvloop_init']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet","title":"<code>BaseRet</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[_T]</code></p> <p>Base data model of function return value</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>class BaseRet(BaseModel, Generic[_T]):\n    \"\"\"Base data model of function return value\"\"\"\n    code: int = RetCodeEnum.Success.value\n    message: str = ''\n    exception: Optional[Exception] = None\n    data: Optional[_T] = None\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __bool__(self):\n        return self.code == RetCodeEnum.Success\n</code></pre>"},{"location":"api/#ktoolbox.utils.BaseRet.code","title":"<code>code: int = RetCodeEnum.Success.value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.data","title":"<code>data: Optional[_T] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.exception","title":"<code>exception: Optional[Exception] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.message","title":"<code>message: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.__bool__","title":"<code>__bool__()</code>","text":"Source code in <code>ktoolbox/utils.py</code> <pre><code>def __bool__(self):\n    return self.code == RetCodeEnum.Success\n</code></pre>"},{"location":"api/#ktoolbox.utils.dump_search","title":"<code>dump_search(result, path)</code>  <code>async</code>","text":"Source code in <code>ktoolbox/utils.py</code> <pre><code>async def dump_search(result: List[BaseModel], path: Path):\n    async with aiofiles.open(str(path), \"w\", encoding=\"utf-8\") as f:\n        await f.write(\n            SearchResult(result=result)\n            .model_dump_json(indent=config.json_dump_indent)\n        )\n</code></pre>"},{"location":"api/#ktoolbox.utils.generate_msg","title":"<code>generate_msg(title=None, **kwargs)</code>","text":"<p>Generate message for <code>BaseRet</code> and logger</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Message title</p> <code>None</code> <code>kwargs</code> <p>Extra data</p> <code>{}</code> Source code in <code>ktoolbox/utils.py</code> <pre><code>def generate_msg(title: str = None, **kwargs):\n    \"\"\"\n    Generate message for ``BaseRet`` and logger\n\n    :param title: Message title\n    :param kwargs: Extra data\n    \"\"\"\n    title: str = title or \"\"\n    return f\"{title} - {kwargs}\" if kwargs else title\n</code></pre>"},{"location":"api/#ktoolbox.utils.logger_init","title":"<code>logger_init(cli_use=False, disable_stdout=False)</code>","text":"<p>Initialize <code>loguru</code> logger</p> <p>Parameters:</p> Name Type Description Default <code>cli_use</code> <code>bool</code> <p>Set logger level <code>INFO</code> and filter out <code>SUCCESS</code></p> <code>False</code> <code>disable_stdout</code> <code>bool</code> <p>Disable default output stream</p> <code>False</code> Source code in <code>ktoolbox/utils.py</code> <pre><code>def logger_init(cli_use: bool = False, disable_stdout: bool = False):\n    \"\"\"\n    Initialize ``loguru`` logger\n\n    :param cli_use: Set logger level ``INFO`` and filter out ``SUCCESS``\n    :param disable_stdout: Disable default output stream\n    \"\"\"\n    if disable_stdout:\n        logger.remove()\n    elif cli_use:\n        logger.remove()\n        logger.add(\n            tqdm.write,\n            colorize=True,\n            format=\"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss}&lt;/green&gt; | \"\n                   \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n                   \"&lt;cyan&gt;{name}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;\",\n            level=logging.INFO,\n            filter=lambda record: record[\"level\"].name != \"SUCCESS\"\n        )\n    if path := config.logger.path:\n        path.mkdir(exist_ok=True)\n        if path is not None:\n            logger.add(\n                path / DataStorageNameEnum.LogData.value,\n                level=config.logger.level,\n                rotation=config.logger.rotation,\n                diagnose=True\n            )\n</code></pre>"},{"location":"api/#ktoolbox.utils.parse_webpage_url","title":"<code>parse_webpage_url(url)</code>","text":"<p>Fetch service, user_id, post_id from webpage url</p> <p>Each part can be <code>None</code> if not found in url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Kemono Webpage url</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str], Optional[str]]</code> <p>Tuple of service, user_id, post_id</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def parse_webpage_url(url: str) -&gt; Tuple[Optional[str], Optional[str], Optional[str]]:\n    # noinspection SpellCheckingInspection\n    \"\"\"\n    Fetch **service**, **user_id**, **post_id** from webpage url\n\n    Each part can be ``None`` if not found in url.\n\n    :param url: Kemono Webpage url\n    :return: Tuple of **service**, **user_id**, **post_id**\n    \"\"\"\n    path_url = Path(url)\n    parts = path_url.parts\n    if (url_parts_len := len(parts)) &lt; 7:\n        # Pad to full size\n        parts += tuple(None for _ in range(7 - url_parts_len))\n    _scheme, _netloc, service, _user_key, user_id, _post_key, post_id = parts\n    return service, user_id, post_id\n</code></pre>"},{"location":"api/#ktoolbox.utils.uvloop_init","title":"<code>uvloop_init()</code>","text":"<p>Set event loop policy to uvloop if available.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If uvloop enabled successfully</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def uvloop_init() -&gt; bool:\n    \"\"\"\n    Set event loop policy to uvloop if available.\n\n    :return: If uvloop enabled successfully\n    \"\"\"\n    if config.use_uvloop:\n        if sys.platform == \"win32\":\n            logger.debug(\"uvloop is not supported on Windows, but it's optional.\")\n        else:\n            try:\n                # noinspection PyUnresolvedReferences\n                import uvloop\n            except ModuleNotFoundError:\n                logger.debug(\n                    \"uvloop is not installed, but it's optional. \"\n                    \"You can install it with `pip install ktoolbox[uvloop]`\"\n                )\n            else:\n                asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n                logger.success(\"Set event loop policy to uvloop successfully.\")\n                return True\n    return False\n</code></pre>"},{"location":"coomer/","title":"Coomer","text":"<p>KToolBox support downloading from Coomer.st / Coomer.su / Coomer.party</p> <p>You need to modify the configuration by <code>.env</code> or <code>prod.env</code> dotenv file or system environment variables: <pre><code># For Coomer API\nKTOOLBOX_API__NETLOC=coomer.st\n\n# For downloading files from Coomer server\nKTOOLBOX_API__FILES_NETLOC=coomer.st\n</code></pre></p>"},{"location":"coomer/#about-coomer","title":"About Coomer","text":"<p>Description from https://coomer.st :</p> <p>Coomer is a public archiver for:</p> <ul> <li>OnlyFans</li> <li>Fansly</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. To get started viewing content, either search for creators on the creators page, or search for content on the posts page. If you want to contribute content, head over to the import page.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-to-solve-the-failure-of-uvloop-installation","title":"How to solve the failure of uvloop installation?","text":"<p>It's optional</p> <p>uvloop can improve concurrent performance, but it's optional.  If you don't want to install uvloop, you can ignore this step.</p> <p>On Windows, uvloop is not supported. If you failed installing uvloop on Linux or macOS,  you can try to install it with system package manager like apt, yum or brew,  pacakge managers provide prebuilt wheels for uvloop.</p> <ul> <li>Install with apt     <pre><code>sudo apt install python3-uvloop\n</code></pre></li> </ul>"},{"location":"faq/#attachments-folder-inside-post-directory-is-no-need-for-me","title":"<code>attachments</code> folder inside post directory is no need for me","text":"<p>You can set configuration option <code>job.post_structure.attachments</code> to <code>./</code></p> <p>Set the configuration by <code>prod.env</code> dotenv file or system environment variables: <pre><code>KTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n</code></pre></p> <p><code>./</code> means attachments will be downloaded directly into the post directory.</p> <p>Notice</p> <p>For more information, please visit Configuration-Guide page.</p>"},{"location":"faq/#commands-and-flags-should-use-or-_-as-seperator","title":"Commands and flags should use <code>-</code> or <code>_</code> as seperator?","text":"<p>Both is support, <code>-</code> is suggested.</p>"},{"location":"faq/#filename-too-long","title":"Filename too long","text":"<p>In some cases, the filename or the post directory name can be too long and caused download failure. To solve this issue, you can set sequential filename or use custom post directory name</p> <p>Set the configuration by <code>prod.env</code> dotenv file or system environment variables: <pre><code># Rename attachments in numerical order, e.g. `1.png`, `2.png`, ...\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# Set the post directory name to its release/publish date and ID, e.g. `[2024-1-1]11223344`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{id}\n</code></pre></p>"},{"location":"faq/#how-to-configure-a-proxy","title":"How to Configure a Proxy?","text":"<p>You can set the <code>HTTPS_PROXY</code>, <code>HTTP_PROXY</code>, and <code>ALL_PROXY</code> environment variables to achieve this.</p> <p>Refer to: HTTPX - Environment Variables</p> <p>For example, set it like this:</p> <pre><code># Unix Shell\nexport HTTPS_PROXY=http://127.0.0.1:7897\nexport HTTP_PROXY=http://127.0.0.1:7897\nexport ALL_PROXY=socks5://127.0.0.1:7897\n</code></pre> <pre><code># Windows PowerShell\n$env:HTTP_PROXY=\"http://127.0.0.1:7897\"; $env:HTTPS_PROXY=\"http://127.0.0.1:7897\"\n</code></pre>"},{"location":"faq/#gui-configuration-editor-cannot-be-opened","title":"GUI Configuration Editor Cannot Be Opened","text":"<p>Note</p> <p><code>ktoolbox-pure-py</code> does not support the graphical configuration editor.</p> <p>By default, the dependencies for the graphical configuration editor are not installed. You can install them using the following command:</p> <pre><code>pip3 install ktoolbox[urwid]\n</code></pre> <p>If you are using pipx:</p> <pre><code>pipx install ktoolbox[urwid] --force\n</code></pre>"},{"location":"faq/#kemono-api-call-failed","title":"Kemono API Call Failed","text":"<p>For example:</p> <pre><code>ktoolbox sync-creator \"https://coomer.su/onlyfans/user/hollyharper11\" --start-time=\"2020-05-01\" --end-time=\"2025-01-01\"\n\n2024-05-12 12:52:51.477 | INFO     | ktoolbox.cli:sync_creator:271 - Got creator information - {'name': 'hollyharper11', 'id': 'hollyharper11'}\n2024-05-12 12:52:51.479 | INFO     | ktoolbox.action.job:create_job_from_creator:148 - Start fetching posts from creator hollyharper11\n2024-05-12 12:52:56.477 | ERROR    | ktoolbox.api.base:_retry_error_callback:37 - Kemono API call failed - {'ret': APIRet(code=1002, message=\"1 validation error for Response\\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\\\n&lt;html&gt;\\\\...&gt;\\\\n  &lt;/body&gt;\\\\n&lt;/html&gt;\\\\n', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\", exception=1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid, data=None)}\n1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\n</code></pre> <ol> <li> <p>This is generally caused by frequent requests, so you can try setting a higher number of API retry attempts.     <pre><code># .env / prod.env\nKTOOLBOX_API__RETRY_TIMES=10\n</code></pre></p> </li> <li> <p>You can set session key (can be found in cookies after a successful login) for download     <pre><code># .env / prod.env\nKTOOLBOX_API__SESSION_KEY=\"xxxxxxx\"\n</code></pre></p> </li> </ol> <p>You can also set these through the graphical configuration editor: <code>API - retry_times</code> and <code>API -&gt; session_key</code>.</p>"},{"location":"faq/#frequently-encounter-403-errors-during-downloads","title":"Frequently encounter 403 errors during downloads","text":"<p>The solution is the same as above.</p>"},{"location":"faq/#others","title":"Others","text":"<p>A community-shared usage guide: #141</p>"},{"location":"more/","title":"More","text":""},{"location":"more/#other-branches","title":"Other Branches","text":"<ul> <li>Pure Python branch: \ud83d\udd17pure-py</li> </ul> <p>About</p> <ul> <li>Use pydantic v1 so that cargo is not needed for installation</li> <li>For example, you can use it on iOS terminal App a-Shell</li> <li>\ud83d\udd17PyPI</li> </ul> <ul> <li>Development branch: \ud83d\udd17devel</li> </ul>"},{"location":"more/#code-coverage","title":"Code Coverage","text":""},{"location":"more/#license","title":"License","text":"<p>KToolBox is licensed under BSD 3-Clause.</p> <p>Copyright \u00a9 2023 by Ljzd-PRO.</p>"},{"location":"shortcut/","title":"Shortcuts for iOS","text":"<p>You can run KToolBox using iOS terminal App a-Shell, and the following shortcuts  can help you automatically install KToolBox and download posts</p>"},{"location":"shortcut/#get-the-shortcuts","title":"Get the shortcuts","text":"<p>Visit shortcut URLs below or download shortcut files at <code>shortcuts/</code></p>"},{"location":"shortcut/#english","title":"English","text":"<ul> <li>KToolBox Manager</li> <li>Download Kemono Post</li> </ul>"},{"location":"shortcut/#chinese","title":"Chinese","text":"<ul> <li>KToolBox \u7ba1\u7406\u5668</li> <li>\u4e0b\u8f7d Kemono \u4f5c\u54c1</li> </ul>"},{"location":"shortcut/#usage","title":"Usage","text":"<ul> <li>Use \"KToolBox Manager\" to install, update, uninstall KToolBox in a-Shell</li> <li>You can trigger \"Download Kemono Post\" by web page share view, or run directly in Shortcuts App</li> </ul>"},{"location":"commands/guide/","title":"Guide","text":"<p>Check Reference for all commands and their flags / parameters.</p>"},{"location":"commands/guide/#get-general-help","title":"Get general help","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox -h\n</code></pre>"},{"location":"commands/guide/#get-help-of-a-command","title":"Get help of a command","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"commands/guide/#launch-the-graphical-configuration-editor","title":"Launch the graphical configuration editor","text":"<p><code>config-editor</code></p> <pre><code>ktoolbox config-editor\n</code></pre>"},{"location":"commands/guide/#generate-an-example-configuration-file-envprodenv","title":"Generate an example configuration file (<code>.env</code>/<code>prod.env</code>)","text":"<p><code>example-env</code></p> <pre><code>ktoolbox example-env\n</code></pre>"},{"location":"commands/guide/#download-a-specific-post","title":"Download a specific post","text":"<p><code>download-post</code></p> <pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> If some files failed to download <p>If some files failed to download, you can try to execute the command line again,  the downloaded files will be skipped.</p>"},{"location":"commands/guide/#download-all-posts-from-a-creator","title":"Download all posts from a creator","text":"<p><code>sync-creator</code></p> <pre><code># Download all posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016\n</code></pre> About <code>creator-indices.ktoolbox</code> file <p>By default, you will get a <code>creator-indices.ktoolbox</code> file in the creator directory,  it contains the information and filepath of posts inside the directory.</p> Update creator directory <p>You can rerun the command, files with the same filename will be skipped.</p>"},{"location":"commands/guide/#download-a-specified-number-of-posts-from-the-creator","title":"Download a specified number of posts from the creator","text":"<p><code>sync-creator</code></p> <ul> <li><code>--offset</code>: Posts result offset (or start offset)</li> <li><code>--length</code>: The number of posts to fetch, defaults to fetching all posts</li> </ul> <pre><code># Download latest 10 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# Download latest No.11-No.15 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n</code></pre>"},{"location":"commands/guide/#download-posts-that-published-within-the-specified-time-range","title":"Download posts that published within the specified time range","text":"<p><code>sync-creator</code></p> <ul> <li><code>--start-time</code>: Start time of the published time range for posts downloading.</li> <li><code>--end-time</code>: End time of the published time range for posts downloading.</li> </ul> <pre><code># From 2023-8-5 to 2023-12-6\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5 --end-time=2023-12-6\n\n# From 2023-8-5 to now\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5\n\n# Before 2023-8-5\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --end-time=2023-8-5\n</code></pre>"},{"location":"commands/guide/#time-format","title":"Time Format","text":"<p>The time value should match <code>%Y-%m-%d</code>, for example:</p> <ul> <li><code>2023-12-7</code></li> <li><code>2023-12-07</code></li> <li><code>2023-12-31</code></li> </ul>"},{"location":"commands/reference/","title":"Reference","text":"Source code in <code>ktoolbox/cli.py</code> <pre><code>class KToolBoxCli:\n    @staticmethod\n    async def version():\n        \"\"\"Show KToolBox version\"\"\"\n        return __version__\n\n    @staticmethod\n    async def site_version():\n        # noinspection SpellCheckingInspection\n        \"\"\"Show current Kemono site app commit hash\"\"\"\n        logger.info(repr(config))\n        ret = await get_app_version()\n        return ret.data if ret else ret.message\n\n    @staticmethod\n    async def config_editor():\n        \"\"\"Launch graphical KToolBox configuration editor\"\"\"\n        try:\n            from ktoolbox.editor import run_config_editor\n            run_config_editor()\n        except ModuleNotFoundError:\n            logger.error(\n                \"You need to install extra dependencies to use the editor, \"\n                \"run `pip install ktoolbox[urwid]` \"\n                \"or `pipx install ktoolbox[urwid] --force` if you are using pipx\"\n            )\n\n    @staticmethod\n    async def example_env():\n        \"\"\"Generate an example configuration ``.env`` file.\"\"\"\n        print(\n            render(\n                OutputFormat.DOTENV,\n                class_path=(\"ktoolbox.configuration.Configuration\",)\n            )\n        )\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator(\n            name: str = None,\n            id: str = None,\n            service: str = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_action(id=id, name=name, service=service)\n        if ret:\n            result_list = list(ret.data)\n            if dump:\n                await dump_search(result_list, dump)\n            return result_list or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator_post(\n            id: str = None,\n            name: str = None,\n            service: str = None,\n            q: str = None,\n            o: int = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search posts from creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n        if ret:\n            if dump:\n                await dump_search(ret.data, dump)\n            return ret.data or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    @staticmethod\n    async def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n        \"\"\"\n        Get a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            if dump:\n                async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                    await f.write(\n                        ret.data.post.model_dump_json(indent=config.json_dump_indent)\n                    )\n            return ret.data.post\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def download_post(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def download_post(\n            service: str,\n            creator_id: str,\n            post_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    async def download_post(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            post_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        \"\"\"\n        Download a specific post\n\n        :param url: The post URL\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param path: Download path, default is current directory\n        :param dump_post_data: Whether to dump post data (post.json) in post directory\n        \"\"\"\n        logger.info(repr(config))\n        # Get service, creator_id, post_id\n        if url:\n            service, creator_id, post_id = parse_webpage_url(url)\n        if not all([service, creator_id, post_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\", \"post_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            post_path = path / generate_post_path_name(ret.data.post)\n            job_list = await create_job_from_post(\n                post=ret.data.post,\n                post_path=post_path,\n                dump_post_data=dump_post_data\n            )\n            job_runner = JobRunner(job_list=job_list)\n            await job_runner.start()\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            service: str,\n            creator_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None\n    ):\n        ...\n\n    @staticmethod\n    async def sync_creator(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = False,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None,\n            offset: int = 0,\n            length: int = None\n    ):\n        \"\"\"\n        Sync posts from a creator\n\n        You can update the directory anytime after download finished, \\\n        such as to update after creator published new posts.\n\n        * ``start_time`` &amp; ``end_time`` example: ``2023-12-7``, ``2023-12-07``\n\n        :param url: The post URL\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param path: Download path, default is current directory\n        :param save_creator_indices: Record ``CreatorIndices`` data\n        :param mix_posts: Save all_pages files from different posts at same path, \\\n            ``save_creator_indices`` will be ignored if enabled\n        :param start_time: Start time of the published time range for posts downloading. \\\n            Set to ``0`` if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param end_time: End time of the published time range for posts downloading. \\\n            Set to latest time (infinity) if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param offset: Result offset (or start offset)\n        :param length: The number of posts to fetch, defaults to fetching all posts after ``offset``.\n        \"\"\"\n        logger.info(repr(config))\n        # Get service, creator_id\n        if url:\n            service, creator_id, _ = parse_webpage_url(url)\n        if not all([service, creator_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n\n        # Get creator name\n        creator_name = creator_id\n        creator_ret = await search_creator_action(id=creator_id, service=service)\n        if creator_ret:\n            creator = next(creator_ret.data, None)\n            if creator:\n                creator_name = creator.name\n                logger.info(\n                    generate_msg(\n                        \"Got creator information\",\n                        name=creator.name,\n                        id=creator.id\n                    )\n                )\n        else:\n            logger.error(\n                generate_msg(\n                    f\"Failed to fetch the name of creator &lt;{creator_id}&gt;\",\n                    detail=creator_ret.message\n                )\n            )\n            return creator_ret.message\n\n        creator_path = path / sanitize_filename(creator_name)\n\n        creator_path.mkdir(exist_ok=True)\n        ret = await create_job_from_creator(\n            service=service,\n            creator_id=creator_id,\n            path=creator_path,\n            all_pages=not length,\n            offset=offset,\n            length=length,\n            save_creator_indices=save_creator_indices,\n            mix_posts=mix_posts,\n            start_time=datetime.strptime(start_time, \"%Y-%m-%d\") if start_time else None,\n            end_time=datetime.strptime(end_time, \"%Y-%m-%d\") if end_time else None\n        )\n        if ret:\n            job_runner = JobRunner(job_list=ret.data)\n            await job_runner.start()\n        else:\n            return ret.message\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.config_editor","title":"<code>config_editor</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Launch graphical KToolBox configuration editor</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def config_editor():\n    \"\"\"Launch graphical KToolBox configuration editor\"\"\"\n    try:\n        from ktoolbox.editor import run_config_editor\n        run_config_editor()\n    except ModuleNotFoundError:\n        logger.error(\n            \"You need to install extra dependencies to use the editor, \"\n            \"run `pip install ktoolbox[urwid]` \"\n            \"or `pipx install ktoolbox[urwid] --force` if you are using pipx\"\n        )\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.download_post","title":"<code>download_post</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Download a specific post</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service name</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The creator's ID</p> <code>None</code> <code>post_id</code> <code>str</code> <p>The post ID</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>dump_post_data</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def download_post(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        post_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        dump_post_data=True\n):\n    \"\"\"\n    Download a specific post\n\n    :param url: The post URL\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param path: Download path, default is current directory\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    logger.info(repr(config))\n    # Get service, creator_id, post_id\n    if url:\n        service, creator_id, post_id = parse_webpage_url(url)\n    if not all([service, creator_id, post_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\", \"post_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        post_path = path / generate_post_path_name(ret.data.post)\n        job_list = await create_job_from_post(\n            post=ret.data.post,\n            post_path=post_path,\n            dump_post_data=dump_post_data\n        )\n        job_runner = JobRunner(job_list=job_list)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.example_env","title":"<code>example_env</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Generate an example configuration <code>.env</code> file.</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def example_env():\n    \"\"\"Generate an example configuration ``.env`` file.\"\"\"\n    print(\n        render(\n            OutputFormat.DOTENV,\n            class_path=(\"ktoolbox.configuration.Configuration\",)\n        )\n    )\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.get_post","title":"<code>get_post</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Get a specific post</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n    \"\"\"\n    Get a specific post\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        if dump:\n            async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                await f.write(\n                    ret.data.post.model_dump_json(indent=config.json_dump_indent)\n                )\n        return ret.data.post\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.search_creator","title":"<code>search_creator</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator(\n        name: str = None,\n        id: str = None,\n        service: str = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await search_creator_action(id=id, name=name, service=service)\n    if ret:\n        result_list = list(ret.data)\n        if dump:\n            await dump_search(result_list, dump)\n        return result_list or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.search_creator_post","title":"<code>search_creator_post</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search posts from creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: int = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search posts from creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n    if ret:\n        if dump:\n            await dump_search(ret.data, dump)\n        return ret.data or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.site_version","title":"<code>site_version</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show current Kemono site app commit hash</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def site_version():\n    # noinspection SpellCheckingInspection\n    \"\"\"Show current Kemono site app commit hash\"\"\"\n    logger.info(repr(config))\n    ret = await get_app_version()\n    return ret.data if ret else ret.message\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.sync_creator","title":"<code>sync_creator</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Sync posts from a creator</p> <p>You can update the directory anytime after download finished,         such as to update after creator published new posts.</p> <ul> <li><code>start_time</code> &amp; <code>end_time</code> example: <code>2023-12-7</code>, <code>2023-12-07</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service where the post is located</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all_pages files from different posts at same path,             <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>str</code> <p>Start time of the published time range for posts downloading.             Set to <code>0</code> if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>end_time</code> <code>str</code> <p>End time of the published time range for posts downloading.             Set to latest time (infinity) if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>int</code> <p>The number of posts to fetch, defaults to fetching all posts after <code>offset</code>.</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def sync_creator(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        save_creator_indices: bool = False,\n        mix_posts: bool = None,\n        start_time: str = None,\n        end_time: str = None,\n        offset: int = 0,\n        length: int = None\n):\n    \"\"\"\n    Sync posts from a creator\n\n    You can update the directory anytime after download finished, \\\n    such as to update after creator published new posts.\n\n    * ``start_time`` &amp; ``end_time`` example: ``2023-12-7``, ``2023-12-07``\n\n    :param url: The post URL\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: Download path, default is current directory\n    :param save_creator_indices: Record ``CreatorIndices`` data\n    :param mix_posts: Save all_pages files from different posts at same path, \\\n        ``save_creator_indices`` will be ignored if enabled\n    :param start_time: Start time of the published time range for posts downloading. \\\n        Set to ``0`` if ``None`` was given. \\\n        Time format: ``%Y-%m-%d``\n    :param end_time: End time of the published time range for posts downloading. \\\n        Set to latest time (infinity) if ``None`` was given. \\\n        Time format: ``%Y-%m-%d``\n    :param offset: Result offset (or start offset)\n    :param length: The number of posts to fetch, defaults to fetching all posts after ``offset``.\n    \"\"\"\n    logger.info(repr(config))\n    # Get service, creator_id\n    if url:\n        service, creator_id, _ = parse_webpage_url(url)\n    if not all([service, creator_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n\n    # Get creator name\n    creator_name = creator_id\n    creator_ret = await search_creator_action(id=creator_id, service=service)\n    if creator_ret:\n        creator = next(creator_ret.data, None)\n        if creator:\n            creator_name = creator.name\n            logger.info(\n                generate_msg(\n                    \"Got creator information\",\n                    name=creator.name,\n                    id=creator.id\n                )\n            )\n    else:\n        logger.error(\n            generate_msg(\n                f\"Failed to fetch the name of creator &lt;{creator_id}&gt;\",\n                detail=creator_ret.message\n            )\n        )\n        return creator_ret.message\n\n    creator_path = path / sanitize_filename(creator_name)\n\n    creator_path.mkdir(exist_ok=True)\n    ret = await create_job_from_creator(\n        service=service,\n        creator_id=creator_id,\n        path=creator_path,\n        all_pages=not length,\n        offset=offset,\n        length=length,\n        save_creator_indices=save_creator_indices,\n        mix_posts=mix_posts,\n        start_time=datetime.strptime(start_time, \"%Y-%m-%d\") if start_time else None,\n        end_time=datetime.strptime(end_time, \"%Y-%m-%d\") if end_time else None\n    )\n    if ret:\n        job_runner = JobRunner(job_list=ret.data)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.version","title":"<code>version</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show KToolBox version</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def version():\n    \"\"\"Show KToolBox version\"\"\"\n    return __version__\n</code></pre>"},{"location":"configuration/guide/","title":"Guide","text":"<p>Graphical Configuration Editor</p> UsageScreenshot <p>Run <code>ktoolbox config-editor</code> to launch,  it will make configuration editing simple and convenient.</p> <ul> <li>Press <code>&lt;Esc&gt;</code> for back, <code>&lt;Enter&gt;</code> for select</li> <li>You can also use the GUI with the mouse</li> </ul> <p> </p> <p>Generate Example <code>.env</code> File</p> <p>Run <code>ktoolbox example-env</code> to generate a complete sample configuration file.</p> <ul> <li>KToolBox load <code>.env</code> or <code>prod.env</code> file in the working directory or environment variables to store configuration</li> <li>The working directory refers to the directory where you execute the <code>ktoolbox</code> command, it is not necessarily the directory where the <code>ktoolbox</code> executable is located. It reads from where you execute it.</li> <li>Check Reference for all configuration options</li> <li>Use <code>__</code> to specify the sub option, like <code>KTOOLBOX_API__SCHEME</code> means <code>api.scheme</code></li> <li>All configuration options are optional</li> </ul>"},{"location":"configuration/guide/#env-prodenv-file-example","title":"<code>.env</code> / <code>prod.env</code> file example","text":"<pre><code># Download 10 files at the same time.\nKTOOLBOX_JOB__COUNT=10\n\n# Set post attachments directory path as `./`, it means to save all attachments files in post directory\n# without making a new sub directory to storage them\nKTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n\n# Rename attachments in numerical order, e.g. `1.png`, `2.png`, ...\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# Customize the filename format by inserting an empty `{}` to represent the basic filename.\n# Similar to `post_dirname_format`, you can use some of the properties in `Post`.\n# For example: `{title}_{}` &gt; `HelloWorld_b4b41de2-8736-480d-b5c3-ebf0d917561b`, etc.\n# You can also use it with `sequential_filename`. For instance,\n# `[{published}]_{}` &gt; `[2024-1-1]_1.png`, `[2024-1-1]_2.png`, etc.\nKTOOLBOX_JOB__FILENAME_FORMAT=[{published}]_{}\n\n# Prefix the post directory name with its release/publish date, e.g. `[2024-1-1]HelloWorld`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{title}\n</code></pre>"},{"location":"configuration/reference/","title":"Reference","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>KToolBox Configuration</p> <p>Attributes:</p> Name Type Description <code>api</code> <code>APIConfiguration</code> <p>Kemono API Configuration</p> <code>downloader</code> <code>DownloaderConfiguration</code> <p>File Downloader Configuration</p> <code>job</code> <code>JobConfiguration</code> <p>Download jobs Configuration</p> <code>logger</code> <code>LoggerConfiguration</code> <p>Logger configuration</p> <code>ssl_verify</code> <code>bool</code> <p>Enable SSL certificate verification for Kemono API server and download server</p> <code>json_dump_indent</code> <code>int</code> <p>Indent of JSON file dump</p> <code>use_uvloop</code> <code>bool</code> <p>Use uvloop for asyncio (Disabled on Windows by default)     uvloop will improve concurrent performance, but it is not compatible with Windows.     Install uvloop by <code>pip install ktoolbox[uvloop]</code> or it will not work.</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class Configuration(BaseSettings):\n    # noinspection SpellCheckingInspection,GrazieInspection\n    \"\"\"\n    KToolBox Configuration\n\n    :ivar api: Kemono API Configuration\n    :ivar downloader: File Downloader Configuration\n    :ivar job: Download jobs Configuration\n    :ivar logger: Logger configuration\n    :ivar ssl_verify: Enable SSL certificate verification for Kemono API server and download server\n    :ivar json_dump_indent: Indent of JSON file dump\n    :ivar use_uvloop: Use uvloop for asyncio (Disabled on Windows by default) \\\n    uvloop will improve concurrent performance, but it is not compatible with Windows. \\\n    Install uvloop by `pip install ktoolbox[uvloop]` or it will not work.\n    \"\"\"\n    api: APIConfiguration = APIConfiguration()\n    downloader: DownloaderConfiguration = DownloaderConfiguration()\n    job: JobConfiguration = JobConfiguration()\n    logger: LoggerConfiguration = LoggerConfiguration()\n\n    ssl_verify: bool = True\n    json_dump_indent: int = 4\n    use_uvloop: bool = True\n\n    # noinspection SpellCheckingInspection\n    model_config: ClassVar[SettingsConfigDict] = SettingsConfigDict(\n        env_prefix='ktoolbox_',\n        env_nested_delimiter='__',\n        env_file=['.env', 'prod.env'],\n        env_file_encoding='utf-8',\n        extra='ignore'\n    )\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.api","title":"<code>api: APIConfiguration = APIConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.downloader","title":"<code>downloader: DownloaderConfiguration = DownloaderConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.job","title":"<code>job: JobConfiguration = JobConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.logger","title":"<code>logger: LoggerConfiguration = LoggerConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.ssl_verify","title":"<code>ssl_verify: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.json_dump_indent","title":"<code>json_dump_indent: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.use_uvloop","title":"<code>use_uvloop: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration","title":"<code>APIConfiguration</code>","text":"<p>Kemono API Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Kemono API URL scheme</p> <code>netloc</code> <code>str</code> <p>Kemono API URL netloc</p> <code>statics_netloc</code> <code>str</code> <p>URL netloc of Kemono server for static files (e.g. images)</p> <code>files_netloc</code> <code>str</code> <p>URL netloc of Kemono server for post files</p> <code>path</code> <code>str</code> <p>Kemono API URL root path</p> <code>timeout</code> <code>float</code> <p>API request timeout</p> <code>retry_times</code> <code>int</code> <p>API request retry times (when request failed)</p> <code>retry_interval</code> <code>float</code> <p>Seconds of API request retry interval</p> <code>session_key</code> <code>str</code> <p>Session key that can be found in cookies after a successful login</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class APIConfiguration(BaseModel):\n    \"\"\"\n    Kemono API Configuration\n\n    :ivar scheme: Kemono API URL scheme\n    :ivar netloc: Kemono API URL netloc\n    :ivar statics_netloc: URL netloc of Kemono server for static files (e.g. images)\n    :ivar files_netloc: URL netloc of Kemono server for post files\n    :ivar path: Kemono API URL root path\n    :ivar timeout: API request timeout\n    :ivar retry_times: API request retry times (when request failed)\n    :ivar retry_interval: Seconds of API request retry interval\n    :ivar session_key: Session key that can be found in cookies after a successful login\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    netloc: str = \"kemono.cr\"\n    statics_netloc: str = \"img.kemono.cr\"\n    files_netloc: str = \"kemono.cr\"\n    path: str = \"/api/v1\"\n    timeout: float = 5.0\n    retry_times: int = 3\n    retry_interval: float = 2.0\n    session_key: str = \"\"\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.netloc","title":"<code>netloc: str = 'kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.statics_netloc","title":"<code>statics_netloc: str = 'img.kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.files_netloc","title":"<code>files_netloc: str = 'kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.path","title":"<code>path: str = '/api/v1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.timeout","title":"<code>timeout: float = 5.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.retry_times","title":"<code>retry_times: int = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.retry_interval","title":"<code>retry_interval: float = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.session_key","title":"<code>session_key: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration","title":"<code>DownloaderConfiguration</code>","text":"<p>File Downloader Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Downloader URL scheme</p> <code>timeout</code> <code>float</code> <p>Downloader request timeout</p> <code>encoding</code> <code>str</code> <p>Charset for filename parsing and post content text saving</p> <code>buffer_size</code> <code>int</code> <p>Number of bytes of file I/O buffer for each downloading file</p> <code>chunk_size</code> <code>int</code> <p>Number of bytes of chunk of downloader stream</p> <code>temp_suffix</code> <code>str</code> <p>Temp filename suffix of downloading files</p> <code>retry_times</code> <code>int</code> <p>Downloader retry times (when download failed)</p> <code>retry_stop_never</code> <code>bool</code> <p>Never stop downloader from retrying (when download failed)     (<code>retry_times</code> will be ignored when enabled)</p> <code>retry_interval</code> <code>float</code> <p>Seconds of downloader retry interval</p> <code>tps_limit</code> <code>float</code> <p>Maximum connections established per second</p> <code>use_bucket</code> <code>bool</code> <p>Enable local storage bucket mode</p> <code>bucket_path</code> <code>Path</code> <p>Path of local storage bucket</p> <code>reverse_proxy</code> <code>str</code> <p>Reverse proxy format for download URL.     Customize the filename format by inserting an empty <code>{}</code> to represent the original URL.     For example: <code>https://example.com/{}</code> will be <code>https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg</code>;      <code>https://example.com/?url={}</code> will be <code>https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg</code></p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class DownloaderConfiguration(BaseModel):\n    \"\"\"\n    File Downloader Configuration\n\n    :ivar scheme: Downloader URL scheme\n    :ivar timeout: Downloader request timeout\n    :ivar encoding: Charset for filename parsing and post content text saving\n    :ivar buffer_size: Number of bytes of file I/O buffer for each downloading file\n    :ivar chunk_size: Number of bytes of chunk of downloader stream\n    :ivar temp_suffix: Temp filename suffix of downloading files\n    :ivar retry_times: Downloader retry times (when download failed)\n    :ivar retry_stop_never: Never stop downloader from retrying (when download failed) \\\n    (``retry_times`` will be ignored when enabled)\n    :ivar retry_interval: Seconds of downloader retry interval\n    :ivar tps_limit: Maximum connections established per second\n    :ivar use_bucket: Enable local storage bucket mode\n    :ivar bucket_path: Path of local storage bucket\n    :ivar reverse_proxy: Reverse proxy format for download URL. \\\n    Customize the filename format by inserting an empty ``{}`` to represent the original URL. \\\n    For example: ``https://example.com/{}`` will be ``https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg``;  \\\n    ``https://example.com/?url={}`` will be ``https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg``\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    timeout: float = 30.0\n    encoding: str = \"utf-8\"\n    buffer_size: int = 20480\n    chunk_size: int = 1024\n    temp_suffix: str = \"tmp\"\n    retry_times: int = 10\n    retry_stop_never: bool = False\n    retry_interval: float = 3.0\n    tps_limit: float = 1.0\n    use_bucket: bool = False\n    bucket_path: Path = Path(\"./.ktoolbox/bucket_storage\")\n    reverse_proxy: str = \"{}\"\n\n    @model_validator(mode=\"after\")\n    def check_bucket_path(self) -&gt; \"DownloaderConfiguration\":\n        if self.use_bucket:\n            # noinspection PyBroadException\n            try:\n                bucket_path = Path(self.bucket_path)\n                bucket_path.mkdir(parents=True, exist_ok=True)\n                with tempfile.TemporaryFile(dir=bucket_path) as temp_file:\n                    temp_link_file_path = f\"{bucket_path / temp_file.name}.hlink\"\n                    os.link(temp_file.name, temp_link_file_path)\n                    os.remove(temp_link_file_path)\n            except Exception:\n                self.use_bucket = False\n                logger.exception(f\"`DownloaderConfiguration.bucket_path` is not available, \"\n                                 f\"`DownloaderConfiguration.use_bucket` has been disabled.\")\n        return self\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.timeout","title":"<code>timeout: float = 30.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.encoding","title":"<code>encoding: str = 'utf-8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.buffer_size","title":"<code>buffer_size: int = 20480</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.chunk_size","title":"<code>chunk_size: int = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.temp_suffix","title":"<code>temp_suffix: str = 'tmp'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.retry_times","title":"<code>retry_times: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.retry_stop_never","title":"<code>retry_stop_never: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.retry_interval","title":"<code>retry_interval: float = 3.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.tps_limit","title":"<code>tps_limit: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.use_bucket","title":"<code>use_bucket: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.bucket_path","title":"<code>bucket_path: Path = Path('./.ktoolbox/bucket_storage')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.reverse_proxy","title":"<code>reverse_proxy: str = '{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.check_bucket_path","title":"<code>check_bucket_path()</code>","text":"Source code in <code>ktoolbox/configuration.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_bucket_path(self) -&gt; \"DownloaderConfiguration\":\n    if self.use_bucket:\n        # noinspection PyBroadException\n        try:\n            bucket_path = Path(self.bucket_path)\n            bucket_path.mkdir(parents=True, exist_ok=True)\n            with tempfile.TemporaryFile(dir=bucket_path) as temp_file:\n                temp_link_file_path = f\"{bucket_path / temp_file.name}.hlink\"\n                os.link(temp_file.name, temp_link_file_path)\n                os.remove(temp_link_file_path)\n        except Exception:\n            self.use_bucket = False\n            logger.exception(f\"`DownloaderConfiguration.bucket_path` is not available, \"\n                             f\"`DownloaderConfiguration.use_bucket` has been disabled.\")\n    return self\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration","title":"<code>PostStructureConfiguration</code>","text":"<p>Post path structure model</p> <ul> <li> <p>Default: <pre><code>..\n\u251c\u2500 content.txt\n\u251c\u2500 &lt;Post file&gt;\n\u251c\u2500 &lt;Post data (post.json)&gt;\n\u2514\u2500 attachments\n   \u251c\u2500 1.png\n   \u2514\u2500 2.png\n</code></pre></p> </li> <li> <p>Available properties for <code>file</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> </ul> <p>Attributes:</p> Name Type Description <code>attachments</code> <code>Path</code> <p>Sub path of attachment directory</p> <code>content</code> <code>Path</code> <p>Sub path of post content file</p> <code>content_filepath</code> <code>Path</code> <p>(Deprecated, Use <code>content</code> instead) Sub path of post content file</p> <code>file</code> <code>str</code> <p>The format of the post <code>file</code> filename (<code>file</code> is not <code>attachment</code>, each post has only one <code>file</code>, usually the cover image)     Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename.     You can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_Stelle_lv5_logo.gif</code>, <code>TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code>, etc.</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class PostStructureConfiguration(BaseModel):\n    # noinspection SpellCheckingInspection\n    \"\"\"\n    Post path structure model\n\n    - Default:\n    ```\n    ..\n    \u251c\u2500 content.txt\n    \u251c\u2500 &lt;Post file&gt;\n    \u251c\u2500 &lt;Post data (post.json)&gt;\n    \u2514\u2500 attachments\n       \u251c\u2500 1.png\n       \u2514\u2500 2.png\n    ```\n\n    - Available properties for ``file``\n\n        | Property      | Type   |\n        |---------------|--------|\n        | ``id``        | String |\n        | ``user``      | String |\n        | ``service``   | String |\n        | ``title``     | String |\n        | ``added``     | Date   |\n        | ``published`` | Date   |\n        | ``edited``    | Date   |\n\n    :ivar attachments: Sub path of attachment directory\n    :ivar content: Sub path of post content file\n    :ivar content_filepath: (**Deprecated**, Use ``content`` instead) Sub path of post content file\n    :ivar file: The format of the post `file` filename (`file` is not `attachment`, each post has only one `file`, usually the cover image) \\\n    Customize the filename format by inserting an empty ``{}`` to represent the basic filename. \\\n    You can use some of the [properties][ktoolbox.configuration.JobConfiguration] \\\n    in Post. For example: ``{title}_{}`` could result in filenames like \\\n    ``TheTitle_Stelle_lv5_logo.gif``, ``TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg``, etc.\n    \"\"\"\n    attachments: Path = Path(\"attachments\")\n    content: Path = Path(\"content.txt\")\n    content_filepath: Path = Path(\"content.txt\")\n    file: str = \"{id}_{}\"\n\n    @field_validator(\"content_filepath\")\n    def content_filepath_validator(cls, v):\n        # noinspection PyUnresolvedReferences\n        if v != cls.model_fields[\"content_filepath\"].default:\n            warnings.warn(\n                \"`PostStructureConfiguration.content_filepath` is deprecated and is scheduled for removal in further version. \"\n                \"Use `PostStructureConfiguration.content` instead\",\n                FutureWarning\n            )\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration.attachments","title":"<code>attachments: Path = Path('attachments')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration.content","title":"<code>content: Path = Path('content.txt')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration.content_filepath","title":"<code>content_filepath: Path = Path('content.txt')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration.file","title":"<code>file: str = '{id}_{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration.content_filepath_validator","title":"<code>content_filepath_validator(v)</code>","text":"Source code in <code>ktoolbox/configuration.py</code> <pre><code>@field_validator(\"content_filepath\")\ndef content_filepath_validator(cls, v):\n    # noinspection PyUnresolvedReferences\n    if v != cls.model_fields[\"content_filepath\"].default:\n        warnings.warn(\n            \"`PostStructureConfiguration.content_filepath` is deprecated and is scheduled for removal in further version. \"\n            \"Use `PostStructureConfiguration.content` instead\",\n            FutureWarning\n        )\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration","title":"<code>JobConfiguration</code>","text":"<p>Download jobs Configuration</p> <ul> <li> <p>Available properties for <code>post_dirname_format</code> and <code>filename_format</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> </ul> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>Number of coroutines for concurrent download</p> <code>post_dirname_format</code> <code>str</code> <p>Customize the post directory name format, you can use some of the     properties in <code>Post</code>.     e.g. <code>[{published}]{id}</code> &gt; <code>[2024-1-1]123123</code>, <code>{user}_{published}_{title}</code> &gt; <code>234234_2024-1-1_TheTitle</code></p> <code>post_structure</code> <code>PostStructureConfiguration</code> <p>Post path structure</p> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path in creator directory.     It would not create any post directory, and <code>CreatorIndices</code> would not been recorded.</p> <code>sequential_filename</code> <code>bool</code> <p>Rename attachments in numerical order, e.g. <code>1.png</code>, <code>2.png</code>, ...</p> <code>filename_format</code> <code>str</code> <p>Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename. Similar to post_dirname_format, you can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b</code>, <code>TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90</code>, etc.     You can also use it with <code>sequential_filename</code>. For instance,     <code>[{published}]_{}</code> could result in filenames like <code>[2024-1-1]_1.png</code>, <code>[2024-1-1]_2.png</code>, etc.</p> <code>allow_list</code> <code>Set[str]</code> <p>Download files which match these patterns (Unix shell-style), e.g. <code>[\"*.png\"]</code></p> <code>block_list</code> <code>Set[str]</code> <p>Not to download files which match these patterns (Unix shell-style), e.g. <code>[\"*.psd\",\"*.zip\"]</code></p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class JobConfiguration(BaseModel):\n    \"\"\"\n    Download jobs Configuration\n\n    - Available properties for ``post_dirname_format`` and ``filename_format``\n\n        | Property      | Type   |\n        |---------------|--------|\n        | ``id``        | String |\n        | ``user``      | String |\n        | ``service``   | String |\n        | ``title``     | String |\n        | ``added``     | Date   |\n        | ``published`` | Date   |\n        | ``edited``    | Date   |\n\n    :ivar count: Number of coroutines for concurrent download\n    :ivar post_dirname_format: Customize the post directory name format, you can use some of the \\\n    [properties][ktoolbox.configuration.JobConfiguration] in ``Post``. \\\n    e.g. ``[{published}]{id}`` &gt; ``[2024-1-1]123123``, ``{user}_{published}_{title}`` &gt; ``234234_2024-1-1_TheTitle``\n    :ivar post_structure: Post path structure\n    :ivar mix_posts: Save all files from different posts at same path in creator directory. \\\n    It would not create any post directory, and ``CreatorIndices`` would not been recorded.\n    :ivar sequential_filename: Rename attachments in numerical order, e.g. ``1.png``, ``2.png``, ...\n    :ivar filename_format: Customize the filename format by inserting an empty ``{}`` to represent the basic filename.\n    Similar to post_dirname_format, you can use some of the [properties][ktoolbox.configuration.JobConfiguration] \\\n    in Post. For example: ``{title}_{}`` could result in filenames like \\\n    ``TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b``, ``TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90``, etc. \\\n    You can also use it with ``sequential_filename``. For instance, \\\n    ``[{published}]_{}`` could result in filenames like ``[2024-1-1]_1.png``, ``[2024-1-1]_2.png``, etc.\n    :ivar allow_list: Download files which match these patterns (Unix shell-style), e.g. ``[\"*.png\"]``\n    :ivar block_list: Not to download files which match these patterns (Unix shell-style), e.g. ``[\"*.psd\",\"*.zip\"]``\n    \"\"\"\n    count: int = 4\n    post_dirname_format: str = \"{title}\"\n    post_structure: PostStructureConfiguration = PostStructureConfiguration()\n    mix_posts: bool = False\n    sequential_filename: bool = False\n    filename_format: str = \"{}\"\n    # noinspection PyDataclass\n    allow_list: Set[str] = Field(default_factory=set)\n    # noinspection PyDataclass\n    block_list: Set[str] = Field(default_factory=set)\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.count","title":"<code>count: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.post_dirname_format","title":"<code>post_dirname_format: str = '{title}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.post_structure","title":"<code>post_structure: PostStructureConfiguration = PostStructureConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.mix_posts","title":"<code>mix_posts: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.sequential_filename","title":"<code>sequential_filename: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.filename_format","title":"<code>filename_format: str = '{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.allow_list","title":"<code>allow_list: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.block_list","title":"<code>block_list: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration","title":"<code>LoggerConfiguration</code>","text":"<p>Logger configuration</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Optional[Path]</code> <p>Path to save logs, <code>None</code> for disable log file output</p> <code>level</code> <code>Union[str, int]</code> <p>Log filter level</p> <code>rotation</code> <code>Union[str, int, time, timedelta]</code> <p>Log rotation</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class LoggerConfiguration(BaseModel):\n    \"\"\"\n    Logger configuration\n\n    :ivar path: Path to save logs, ``None`` for disable log file output\n    :ivar level: Log filter level\n    :ivar rotation: Log rotation\n    \"\"\"\n    path: Optional[Path] = None\n    level: Union[str, int] = logging.getLevelName(logging.DEBUG)\n    rotation: Union[str, int, datetime.time, datetime.timedelta] = \"1 week\"\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration.path","title":"<code>path: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration.level","title":"<code>level: Union[str, int] = logging.getLevelName(logging.DEBUG)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration.rotation","title":"<code>rotation: Union[str, int, datetime.time, datetime.timedelta] = '1 week'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"zh/","title":"\u6b22\u8fce\u4f7f\u7528 KToolBox","text":"KToolBox  <p>   KToolBox \u662f\u4e00\u4e2a\u7528\u4e8e\u4e0b\u8f7d   Kemono.su / Kemono.party   \u4e2d\u4f5c\u54c1\u5185\u5bb9\u7684\u5b9e\u7528\u547d\u4ee4\u884c\u5de5\u5177 </p> <p> </p>"},{"location":"zh/#_1","title":"\u529f\u80fd","text":"<ul> <li>\u652f\u6301\u5e76\u53d1\u4e0b\u8f7d</li> <li>API \u8c03\u7528\u548c\u4e0b\u8f7d\u5931\u8d25\u540e \u81ea\u52a8\u91cd\u8bd5</li> <li>\u652f\u6301\u4e0b\u8f7d\u5355\u4e2a\u4f5c\u54c1\u4ee5\u53ca\u6307\u5b9a\u7684\u753b\u5e08\u7684 \u6240\u6709\u4f5c\u54c1</li> <li>\u53ef \u66f4\u65b0\u5df2\u4e0b\u8f7d \u7684\u753b\u5e08\u76ee\u5f55\u81f3\u6700\u65b0\u72b6\u6001</li> <li>\u652f\u6301\u81ea\u5b9a\u4e49\u4e0b\u8f7d\u7684\u4f5c\u54c1/\u753b\u5e08 \u6587\u4ef6\u548c\u76ee\u5f55\u540d\u683c\u5f0f\u3001\u76ee\u5f55\u7ed3\u6784</li> <li>\u652f\u6301\u6392\u9664 \u6307\u5b9a\u683c\u5f0f \u7684\u6587\u4ef6\u6216\u4ec5\u4e0b\u8f7d\u6307\u5b9a\u683c\u5f0f\u7684\u6587\u4ef6</li> <li>\u53ef\u641c\u7d22\u753b\u5e08\u548c\u4f5c\u54c1\uff0c\u5e76\u5bfc\u51fa\u7ed3\u679c</li> <li>\u652f\u6301\u5168\u5e73\u53f0\uff0c\u5e76\u63d0\u4f9b iOS \u5feb\u6377\u6307\u4ee4</li> <li>\u5bf9\u4e8e Coomer.su / Coomer.party \u7684\u652f\u6301\uff0c\u8bf7\u67e5\u770b\u6587\u6863 Coomer</li> </ul>"},{"location":"zh/#_2","title":"\u4f7f\u7528\u65b9\u6cd5","text":""},{"location":"zh/#_3","title":"\u5b89\u88c5","text":"<p>\u4f60\u53ef\u4ee5\u4ece releases \u9875\u9762\u4e0b\u8f7d\u53ef\u6267\u884c\u6587\u4ef6\u4f7f\u7528</p> \u624b\u52a8\u5b89\u88c5 - \u4e00\u822c\u60c5\u51b5 <p>\u63a8\u8350\u4f7f\u7528 pipx    <pre><code>pip3 install pipx\npipx install ktoolbox\n</code></pre></p> \u624b\u52a8\u5b89\u88c5 - \u5bf9\u4e8e iOS a-Shell <pre><code>pip3 install ktoolbox-pure-py\n</code></pre> <p>\u5173\u4e8e a-Shell</p> <p>a-Shell \u662f\u4e00\u4e2a iOS \u7ec8\u7aef App\uff0c\u5b83\u53ea\u80fd\u8fd0\u884c\u7eaf Python \u811a\u672c</p>"},{"location":"zh/#_4","title":"\u547d\u4ee4","text":"<p>\u4f7f\u7528\u5e2e\u52a9\u547d\u4ee4\u6216\u524d\u5f80 \u547d\u4ee4 \u9875\u9762\u67e5\u770b\u66f4\u591a\u5e2e\u52a9\u3002</p>"},{"location":"zh/#_5","title":"\u2753 \u83b7\u53d6\u5e2e\u52a9\u603b\u89c8","text":"<pre><code>ktoolbox -h\n</code></pre>"},{"location":"zh/#_6","title":"\u2753 \u83b7\u53d6\u67d0\u4e2a\u547d\u4ee4\u7684\u5e2e\u52a9\u4fe1\u606f","text":"<pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"zh/#_7","title":"\u2b07\ufe0f\ud83d\uddbc\ufe0f \u4e0b\u8f7d\u6307\u5b9a\u7684\u4f5c\u54c1","text":"<pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> \u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25 <p>\u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25\uff0c\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u91cd\u65b0\u8fd0\u884c\u547d\u4ee4\uff0c\u5df2\u4e0b\u8f7d\u5b8c\u6210\u7684\u6587\u4ef6\u4f1a\u88ab \u8df3\u8fc7\u3002</p>"},{"location":"zh/#_8","title":"\u2b07\ufe0f\ud83d\udd8c\ufe0f \u4e0b\u8f7d\u4f5c\u8005\u7684\u6240\u6709\u4f5c\u54c1","text":"<pre><code># \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u7684\u6240\u6709\u4f5c\u54c1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684 10 \u4e2a\u4f5c\u54c1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684\u7b2c 11 \u81f3 15 \u4e2a\u4f5c\u54c1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u4ece 2024-1-1 \u5230 2024-3-1 \u7684\u4f5c\u54c1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --start-time=2024-1-1 --end-time=2024-3-1\n</code></pre>"},{"location":"zh/#_9","title":"\u914d\u7f6e","text":"<ul> <li>\u540c\u65f6\u4e0b\u8f7d10\u4e2a\u6587\u4ef6</li> <li>\u6309\u7167\u6570\u5b57\u987a\u5e8f\u91cd\u547d\u540d\u9644\u4ef6, \u4f8b\u5982 <code>1.png</code>, <code>2.png</code>, ...</li> <li>\u5c06\u53d1\u5e03\u65e5\u671f\u4f5c\u4e3a\u4f5c\u54c1\u76ee\u5f55\u540d\u7684\u5f00\u5934\uff0c\u4f8b\u5982 <code>[2024-1-1]HelloWorld</code></li> <li>...</li> </ul> <p>\u524d\u5f80 \u914d\u7f6e-\u5411\u5bfc \u9875\u9762\u67e5\u770b\u66f4\u591a\u8be6\u60c5\u3002</p>"},{"location":"zh/about-kemono/","title":"\u5173\u4e8e Kemono","text":"<p>\u5b98\u7f51 https://kemono.cr \u7684\u4ecb\u7ecd\uff1a</p> <p>Kemono is a public archiver for:</p> <ul> <li>Patreon</li> <li>Pixiv Fanbox</li> <li>Discord</li> <li>Fantia</li> <li>Afdian</li> <li>Boosty</li> <li>DLsite</li> <li>Gumroad</li> <li>SubscribeStar</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. \\ To get started viewing content, either search for creators on the artists page, or search for content on the posts page.</p>"},{"location":"zh/api/","title":"API \u6587\u6863","text":""},{"location":"zh/coomer/","title":"Coomer","text":"<p>KToolBox \u652f\u6301\u4ece Coomer.st / Coomer.su / Coomer.party \u4e0b\u8f7d</p> <p>\u4f60\u9700\u8981\u901a\u8fc7 dotenv\u6587\u4ef6 <code>.env</code> \u6216 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u4fee\u6539\u914d\u7f6e\uff1a <pre><code># Coomer API\nKTOOLBOX_API__NETLOC=coomer.st\n\n# \u7528\u4e8e\u4ece Coomer \u670d\u52a1\u5668\u4e0b\u8f7d\u6587\u4ef6\nKTOOLBOX_API__FILES_NETLOC=coomer.st\n</code></pre></p>"},{"location":"zh/coomer/#coomer_1","title":"\u5173\u4e8e Coomer","text":"<p>\u5b98\u7f51 https://coomer.st \u7684\u4ecb\u7ecd\uff1a</p> <p>Coomer is a public archiver for:</p> <ul> <li>OnlyFans</li> <li>Fansly</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. To get started viewing content, either search for creators on the creators page, or search for content on the posts page. If you want to contribute content, head over to the import page.</p>"},{"location":"zh/faq/","title":"\u5e38\u89c1\u95ee\u9898","text":""},{"location":"zh/faq/#uvloop","title":"\u5982\u4f55\u89e3\u51b3 uvloop \u5b89\u88c5\u5931\u8d25\u7684\u95ee\u9898\uff1f","text":"<p>\u8fd9\u662f\u53ef\u9009\u7684</p> <p>uvloop \u53ef\u4ee5\u63d0\u9ad8\u5e76\u53d1\u6027\u80fd\uff0c\u4f46\u5b83\u662f \u53ef\u9009\u7684\u3002\u5982\u679c\u4f60\u4e0d\u60f3\u5b89\u88c5 uvloop\uff0c\u4f60\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e2a\u6b65\u9aa4\u3002</p> <p>uvloop \u5728 Windows \u4e0a \u4e0d\u53d7\u652f\u6301\u3002\u5982\u679c\u4f60\u5728 Linux \u6216 macOS \u5b89\u88c5\u5931\u8d25\uff0c  \u4f60\u53ef\u4ee5\u5c1d\u8bd5\u7528\u4f8b\u5982 apt\u3001yum\u3001brew \u7684\u7cfb\u7edf\u5305\u7ba1\u7406\u5668\u5b89\u88c5\uff0c\u5305\u7ba1\u7406\u5668\u63d0\u4f9b\u6784\u5efa\u597d\u7684 uvloop \u5305\u3002</p> <ul> <li>\u4f7f\u7528 apt \u5b89\u88c5     <pre><code>sudo apt install python3-uvloop\n</code></pre></li> </ul>"},{"location":"zh/faq/#attachments","title":"\u6211\u4e0d\u9700\u8981\u4f5c\u54c1\u76ee\u5f55\u4e0b\u7684 <code>attachments</code> \u6587\u4ef6\u5939","text":"<p>\u4f60\u53ef\u4ee5\u8bbe\u7f6e\u914d\u7f6e\u9009\u9879 <code>job.post_structure.attachments</code> \u4e3a <code>./</code></p> <p>\u901a\u8fc7 dotenv \u6587\u4ef6 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u8bbe\u7f6e\u914d\u7f6e\uff1a <pre><code>KTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n</code></pre></p> <p><code>./</code> \u8868\u793a\u9644\u4ef6\u6587\u4ef6\u5c06\u4f1a\u76f4\u63a5\u4e0b\u8f7d\u5230\u4f5c\u54c1\u76ee\u5f55\u4e0b\u3002</p> <p>\u63d0\u793a</p> <p>\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u8003 \u914d\u7f6e-\u5411\u5bfc \u9875\u9762\u3002</p>"},{"location":"zh/faq/#-_","title":"\u547d\u4ee4\u548c\u6807\u5fd7\uff08\u9009\u9879\uff09\u5e94\u5f53\u4f7f\u7528 <code>-</code> \u8fd8\u662f <code>_</code> \u4f5c\u4e3a\u5206\u9694\u7b26\uff1f","text":"<p>\u4e24\u8005\u90fd\u652f\u6301\uff0c\u63a8\u8350\u4f7f\u7528 <code>-</code>\u3002</p>"},{"location":"zh/faq/#_2","title":"\u6587\u4ef6\u540d\u8fc7\u957f","text":"<p>\u5728\u4e00\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6587\u4ef6\u540d\u6216\u4f5c\u54c1\u76ee\u5f55\u540d\u8fc7\u957f\u800c\u5bfc\u81f4\u4e0b\u8f7d\u5931\u8d25\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f60\u53ef\u4ee5\u8bbe\u7f6e \u5e8f\u5217\u5316\u6587\u4ef6\u540d \u6216\u4f7f\u7528 \u81ea\u5b9a\u4e49\u4f5c\u54c1\u76ee\u5f55\u540d</p> <p>\u901a\u8fc7 dotenv \u6587\u4ef6 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u8bbe\u7f6e\u914d\u7f6e\uff1a <pre><code># \u6309\u7167\u6570\u5b57\u987a\u5e8f\u91cd\u547d\u540d\u9644\u4ef6, \u4f8b\u5982 `1.png`, `2.png`, ...\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# \u8bbe\u7f6e\u4f5c\u54c1\u76ee\u5f55\u540d\u4e3a\u5176\u53d1\u5e03\u65e5\u671f\u548cID\uff0c\u4f8b\u5982 `[2024-1-1]11223344`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{id}\n</code></pre></p>"},{"location":"zh/faq/#_3","title":"\u5982\u4f55\u914d\u7f6e\u4ee3\u7406\uff1f","text":"<p>\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e <code>HTTPS_PROXY</code>, <code>HTTP_PROXY</code>, <code>ALL_PROXY</code> \u73af\u5883\u53d8\u91cf\u5b9e\u73b0</p> <p>\u53c2\u8003\uff1aHTTPX - Environment Variables</p> <p>\u4f8b\u5982\u8fd9\u6837\u8bbe\u7f6e\uff1a</p> <pre><code># Unix Shell\nexport HTTPS_PROXY=http://127.0.0.1:7897\nexport HTTP_PROXY=http://127.0.0.1:7897\nexport ALL_PROXY=socks5://127.0.0.1:7897\n</code></pre> <pre><code># Windows PowerShell\n$env:HTTP_PROXY=\"http://127.0.0.1:7897\"; $env:HTTPS_PROXY=\"http://127.0.0.1:7897\"\n</code></pre>"},{"location":"zh/faq/#_4","title":"\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u65e0\u6cd5\u6253\u5f00","text":"<p>\u6ce8\u610f</p> <p><code>ktoolbox-pure-py</code> \u4e0d\u652f\u6301\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u7684\u76f8\u5173\u4f9d\u8d56\u4e0d\u4f1a\u88ab\u5b89\u88c5\uff0c\u53ef\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u9644\u5e26\u5b89\u88c5\uff1a</p> <pre><code>pip3 install ktoolbox[urwid]\n</code></pre> <p>\u5982\u679c\u4f60\u7528\u7684\u662f pipx\uff1a</p> <pre><code>pipx install ktoolbox[urwid] --force\n</code></pre>"},{"location":"zh/faq/#kemono-api","title":"Kemono API \u8c03\u7528\u5931\u8d25","text":"<p>\u4f8b\u5982\uff1a</p> <pre><code>ktoolbox sync-creator \"https://coomer.su/onlyfans/user/hollyharper11\" --start-time=\"2020-05-01\" --end-time=\"2025-01-01\"\n\n2024-05-12 12:52:51.477 | INFO     | ktoolbox.cli:sync_creator:271 - Got creator information - {'name': 'hollyharper11', 'id': 'hollyharper11'}\n2024-05-12 12:52:51.479 | INFO     | ktoolbox.action.job:create_job_from_creator:148 - Start fetching posts from creator hollyharper11\n2024-05-12 12:52:56.477 | ERROR    | ktoolbox.api.base:_retry_error_callback:37 - Kemono API call failed - {'ret': APIRet(code=1002, message=\"1 validation error for Response\\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\\\n&lt;html&gt;\\\\...&gt;\\\\n  &lt;/body&gt;\\\\n&lt;/html&gt;\\\\n', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\", exception=1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid, data=None)}\n1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\n</code></pre> <ol> <li> <p>\u786e\u4fdd\u66f4\u65b0\u5230\u4e86 v0.14.0 \u6216\u4ee5\u4e0a\u7248\u672c</p> </li> <li> <p>\u4e00\u822c\u53ef\u80fd\u662f\u56e0\u4e3a\u8bf7\u6c42\u9891\u7e41\u5bfc\u81f4\uff0c\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u8bbe\u7f6e\u66f4\u591a\u7684 API \u91cd\u8bd5\u6b21\u6570     <pre><code># .env / prod.env\nKTOOLBOX_API__RETRY_TIMES=10\n</code></pre></p> </li> <li> <p>\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u8bbe\u7f6e\u4e0b\u8f7d\u6240\u7528\u7684 session key \uff08\u767b\u5f55\u6210\u529f\u540e\u53ef\u5728 Cookies \u4e2d\u67e5\u770b\uff09     <pre><code># .env / prod.env\nKTOOLBOX_API__SESSION_KEY=\"xxxxxxx\"\n</code></pre></p> </li> </ol> <p>\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u8bbe\u7f6e\uff1a<code>API - retry_times</code> \u548c <code>API -&gt; session_key</code>.</p>"},{"location":"zh/faq/#403","title":"\u4e0b\u8f7d\u65f6\u9891\u7e41\u51fa\u73b0 403 \u9519\u8bef","text":"<p>\u89e3\u51b3\u65b9\u6cd5\u540c\u4e0a</p>"},{"location":"zh/faq/#_5","title":"\u5176\u4ed6","text":"<p>\u4e00\u4e2a\u793e\u533a\u5206\u4eab\u7684\u4f7f\u7528\u5411\u5bfc\uff1a#141</p>"},{"location":"zh/more/","title":"\u66f4\u591a","text":""},{"location":"zh/more/#_2","title":"\u5176\u4ed6\u5206\u652f","text":"<ul> <li>\u7eaf Python \u5206\u652f\uff1a\ud83d\udd17pure-py</li> </ul> <p>\u5173\u4e8e</p> <ul> <li>\u4f7f\u7528 pydantic v1 \u56e0\u6b64\u5b89\u88c5\u65f6\u4e0d\u9700\u8981 cargo</li> <li>\u4f8b\u5982\u4f60\u53ef\u4ee5\u5728 iOS \u7684\u7ec8\u7aef App a-Shell \u8fd0\u884c</li> <li>\ud83d\udd17PyPI</li> </ul> <ul> <li>\u5f00\u53d1\u7248\u5206\u652f\uff1a\ud83d\udd17devel</li> </ul>"},{"location":"zh/more/#_3","title":"\u4ee3\u7801\u8986\u76d6\u7387","text":""},{"location":"zh/more/#_4","title":"\u8bb8\u53ef\u8bc1","text":"<p>KToolBox \u4f7f\u7528 BSD 3-Clause \u8bb8\u53ef\u8bc1.</p> <p>Copyright \u00a9 2023 by Ljzd-PRO.</p>"},{"location":"zh/shortcut/","title":"iOS \u5feb\u6377\u6307\u4ee4","text":"<p>\u4f60\u53ef\u4ee5\u5728 iOS \u7ec8\u7aef App a-Shell \u8fd0\u884c KToolBox\uff0c\u4e0b\u5217\u5feb\u6377\u6307\u4ee4\u53ef\u4ee5\u5e2e\u52a9\u4f60\u81ea\u52a8\u5b8c\u6210 KToolBox \u7684\u5b89\u88c5\u4ee5\u53ca\u4f5c\u54c1\u4e0b\u8f7d</p>"},{"location":"zh/shortcut/#_1","title":"\u83b7\u53d6\u5feb\u6377\u6307\u4ee4","text":"<p>\u8bbf\u95ee\u4e0b\u9762\u7684\u5feb\u6377\u6307\u4ee4 URL \u6216\u524d\u5f80 <code>shortcuts/</code> \u4e0b\u8f7d\u5feb\u6377\u6307\u4ee4\u6587\u4ef6</p>"},{"location":"zh/shortcut/#_2","title":"\u82f1\u6587","text":"<ul> <li>KToolBox Manager</li> <li>Download Kemono Post</li> </ul>"},{"location":"zh/shortcut/#_3","title":"\u4e2d\u6587","text":"<ul> <li>KToolBox \u7ba1\u7406\u5668</li> <li>\u4e0b\u8f7d Kemono \u4f5c\u54c1</li> </ul>"},{"location":"zh/shortcut/#_4","title":"\u7528\u6cd5","text":"<ul> <li>\u4f7f\u7528 \u201cKToolBox \u7ba1\u7406\u5668\u201d \u4ee5\u5728 a-Shell \u4e2d \u5b89\u88c5\u3001\u66f4\u65b0\u3001\u5378\u8f7d KToolBox</li> <li>\u4f60\u53ef\u4ee5\u901a\u8fc7\u7f51\u9875\u5171\u4eab\u754c\u9762\u89e6\u53d1\u201c\u4e0b\u8f7d Kemono \u4f5c\u54c1\u201d\uff0c\u6216\u76f4\u63a5\u5728\u5feb\u6377\u6307\u4ee4 App \u8fd0\u884c</li> </ul>"},{"location":"zh/commands/guide/","title":"\u5411\u5bfc","text":"<p>\u524d\u5f80 \u53c2\u8003 \u6240\u6709\u547d\u4ee4\u4ee5\u53ca\u5b83\u4eec\u7684\u6807\u5fd7/\u53c2\u6570.</p>"},{"location":"zh/commands/guide/#_2","title":"\u83b7\u53d6\u5e2e\u52a9\u603b\u89c8","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox -h\n</code></pre>"},{"location":"zh/commands/guide/#_3","title":"\u83b7\u53d6\u67d0\u4e2a\u547d\u4ee4\u7684\u5e2e\u52a9\u4fe1\u606f","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"zh/commands/guide/#_4","title":"\u542f\u52a8\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668","text":"<p><code>config-editor</code></p> <pre><code>ktoolbox config-editor\n</code></pre>"},{"location":"zh/commands/guide/#envprodenv","title":"\u751f\u6210\u4e00\u4e2a\u914d\u7f6e\u6587\u4ef6\u6837\u4f8b (<code>.env</code>/<code>prod.env</code>)","text":"<p><code>example-env</code></p> <pre><code>ktoolbox example-env\n</code></pre>"},{"location":"zh/commands/guide/#_5","title":"\u4e0b\u8f7d\u6307\u5b9a\u7684\u4f5c\u54c1","text":"<p><code>download-post</code></p> <pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> \u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25 <p>\u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25\uff0c\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u91cd\u65b0\u8fd0\u884c\u547d\u4ee4\uff0c\u5df2\u4e0b\u8f7d\u5b8c\u6210\u7684\u6587\u4ef6\u4f1a\u88ab \u8df3\u8fc7\u3002</p>"},{"location":"zh/commands/guide/#_6","title":"\u4e0b\u8f7d\u4f5c\u8005\u7684\u6240\u6709\u4f5c\u54c1","text":"<p><code>sync-creator</code></p> <pre><code># \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u7684\u6240\u6709\u4f5c\u54c1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n</code></pre> \u5173\u4e8e <code>creator-indices.ktoolbox</code> \u6587\u4ef6 <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4f60\u4f1a\u5728\u4f5c\u8005\u76ee\u5f55\u4e0b\u5f97\u5230\u4e00\u4e2a <code>creator-indices.ktoolbox</code> \u6587\u4ef6\uff0c\u5b83\u5305\u542b\u76ee\u5f55\u4e0b\u7684\u6240\u6709\u4f5c\u54c1\u7684\u4fe1\u606f\u548c\u8def\u5f84\u3002</p> \u66f4\u65b0\u4f5c\u8005\u76ee\u5f55 <p>\u4f60\u53ef\u4ee5\u518d\u6b21\u8fd0\u884c\u547d\u4ee4\uff0c\u6587\u4ef6\u540d\u76f8\u540c\u7684\u6587\u4ef6\u5c06\u4f1a\u88ab\u8df3\u8fc7\u3002</p>"},{"location":"zh/commands/guide/#_7","title":"\u4e0b\u8f7d\u6307\u5b9a\u6570\u91cf\u7684\u4f5c\u54c1","text":"<p><code>sync-creator</code></p> <ul> <li><code>--offset</code>\uff1a\u4f5c\u54c1\u7ed3\u679c\u504f\u79fb\u91cf\uff08\u6216\u8d77\u59cb\u504f\u79fb\u91cf\uff09</li> <li><code>--length</code>\uff1a\u8981\u83b7\u53d6\u7684\u4f5c\u54c1\u6570\u91cf\uff0c\u9ed8\u8ba4\u83b7\u53d6\u6240\u6709\u4f5c\u54c1</li> </ul> <pre><code># \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684 10 \u4e2a\u4f5c\u54c1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684\u7b2c 11 \u81f3 15 \u4e2a\u4f5c\u54c1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n</code></pre>"},{"location":"zh/commands/guide/#_8","title":"\u4e0b\u8f7d\u5728\u6307\u5b9a\u65f6\u95f4\u8303\u56f4\u5185\u53d1\u5e03\u7684\u4f5c\u54c1","text":"<p><code>sync-creator</code></p> <ul> <li><code>--start-time</code>\uff1a\u4e0b\u8f7d\u6307\u5b9a\u5f00\u59cb\u65f6\u95f4\u8303\u56f4\u5185\u7684\u4f5c\u54c1</li> <li><code>--end-time</code>\uff1a\u4e0b\u8f7d\u6307\u5b9a\u7ed3\u675f\u65f6\u95f4\u8303\u56f4\u5185\u7684\u4f5c\u54c1</li> </ul> <pre><code># \u4ece 2023-8-5 \u5230 2023-12-6\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5 --end-time=2023-12-6\n\n# \u4ece 2023-8-5 \u5230 \u73b0\u5728\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5\n\n# 2023-8-5 \u4e4b\u524d\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --end-time=2023-8-5\n</code></pre>"},{"location":"zh/commands/guide/#_9","title":"\u65f6\u95f4\u683c\u5f0f","text":"<p>\u65f6\u95f4\u503c\u5e94\u5f53\u7b26\u5408 <code>%Y-%m-%d</code> \u683c\u5f0f\uff0c\u4f8b\u5982\uff1a</p> <ul> <li><code>2023-12-7</code></li> <li><code>2023-12-07</code></li> <li><code>2023-12-31</code></li> </ul>"},{"location":"zh/commands/reference/","title":"\u53c2\u8003","text":"Source code in <code>ktoolbox/cli.py</code> <pre><code>class KToolBoxCli:\n    @staticmethod\n    async def version():\n        \"\"\"Show KToolBox version\"\"\"\n        return __version__\n\n    @staticmethod\n    async def site_version():\n        # noinspection SpellCheckingInspection\n        \"\"\"Show current Kemono site app commit hash\"\"\"\n        logger.info(repr(config))\n        ret = await get_app_version()\n        return ret.data if ret else ret.message\n\n    @staticmethod\n    async def config_editor():\n        \"\"\"Launch graphical KToolBox configuration editor\"\"\"\n        try:\n            from ktoolbox.editor import run_config_editor\n            run_config_editor()\n        except ModuleNotFoundError:\n            logger.error(\n                \"You need to install extra dependencies to use the editor, \"\n                \"run `pip install ktoolbox[urwid]` \"\n                \"or `pipx install ktoolbox[urwid] --force` if you are using pipx\"\n            )\n\n    @staticmethod\n    async def example_env():\n        \"\"\"Generate an example configuration ``.env`` file.\"\"\"\n        print(\n            render(\n                OutputFormat.DOTENV,\n                class_path=(\"ktoolbox.configuration.Configuration\",)\n            )\n        )\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator(\n            name: str = None,\n            id: str = None,\n            service: str = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_action(id=id, name=name, service=service)\n        if ret:\n            result_list = list(ret.data)\n            if dump:\n                await dump_search(result_list, dump)\n            return result_list or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator_post(\n            id: str = None,\n            name: str = None,\n            service: str = None,\n            q: str = None,\n            o: int = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search posts from creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n        if ret:\n            if dump:\n                await dump_search(ret.data, dump)\n            return ret.data or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    @staticmethod\n    async def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n        \"\"\"\n        Get a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            if dump:\n                async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                    await f.write(\n                        ret.data.post.model_dump_json(indent=config.json_dump_indent)\n                    )\n            return ret.data.post\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def download_post(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def download_post(\n            service: str,\n            creator_id: str,\n            post_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    async def download_post(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            post_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        \"\"\"\n        Download a specific post\n\n        :param url: The post URL\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param path: Download path, default is current directory\n        :param dump_post_data: Whether to dump post data (post.json) in post directory\n        \"\"\"\n        logger.info(repr(config))\n        # Get service, creator_id, post_id\n        if url:\n            service, creator_id, post_id = parse_webpage_url(url)\n        if not all([service, creator_id, post_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\", \"post_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            post_path = path / generate_post_path_name(ret.data.post)\n            job_list = await create_job_from_post(\n                post=ret.data.post,\n                post_path=post_path,\n                dump_post_data=dump_post_data\n            )\n            job_runner = JobRunner(job_list=job_list)\n            await job_runner.start()\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            service: str,\n            creator_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None\n    ):\n        ...\n\n    @staticmethod\n    async def sync_creator(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = False,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None,\n            offset: int = 0,\n            length: int = None\n    ):\n        \"\"\"\n        Sync posts from a creator\n\n        You can update the directory anytime after download finished, \\\n        such as to update after creator published new posts.\n\n        * ``start_time`` &amp; ``end_time`` example: ``2023-12-7``, ``2023-12-07``\n\n        :param url: The post URL\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param path: Download path, default is current directory\n        :param save_creator_indices: Record ``CreatorIndices`` data\n        :param mix_posts: Save all_pages files from different posts at same path, \\\n            ``save_creator_indices`` will be ignored if enabled\n        :param start_time: Start time of the published time range for posts downloading. \\\n            Set to ``0`` if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param end_time: End time of the published time range for posts downloading. \\\n            Set to latest time (infinity) if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param offset: Result offset (or start offset)\n        :param length: The number of posts to fetch, defaults to fetching all posts after ``offset``.\n        \"\"\"\n        logger.info(repr(config))\n        # Get service, creator_id\n        if url:\n            service, creator_id, _ = parse_webpage_url(url)\n        if not all([service, creator_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n\n        # Get creator name\n        creator_name = creator_id\n        creator_ret = await search_creator_action(id=creator_id, service=service)\n        if creator_ret:\n            creator = next(creator_ret.data, None)\n            if creator:\n                creator_name = creator.name\n                logger.info(\n                    generate_msg(\n                        \"Got creator information\",\n                        name=creator.name,\n                        id=creator.id\n                    )\n                )\n        else:\n            logger.error(\n                generate_msg(\n                    f\"Failed to fetch the name of creator &lt;{creator_id}&gt;\",\n                    detail=creator_ret.message\n                )\n            )\n            return creator_ret.message\n\n        creator_path = path / sanitize_filename(creator_name)\n\n        creator_path.mkdir(exist_ok=True)\n        ret = await create_job_from_creator(\n            service=service,\n            creator_id=creator_id,\n            path=creator_path,\n            all_pages=not length,\n            offset=offset,\n            length=length,\n            save_creator_indices=save_creator_indices,\n            mix_posts=mix_posts,\n            start_time=datetime.strptime(start_time, \"%Y-%m-%d\") if start_time else None,\n            end_time=datetime.strptime(end_time, \"%Y-%m-%d\") if end_time else None\n        )\n        if ret:\n            job_runner = JobRunner(job_list=ret.data)\n            await job_runner.start()\n        else:\n            return ret.message\n</code></pre>"},{"location":"zh/configuration/guide/","title":"\u5411\u5bfc","text":"<p>\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668</p> \u7528\u6cd5\u622a\u56fe <p>\u8fd0\u884c <code>ktoolbox config-editor</code> \u6765\u542f\u52a8\uff0c\u8fd9\u4f1a\u4f7f\u914d\u7f6e\u7f16\u8f91\u53d8\u5f97\u7b80\u5355\u65b9\u4fbf\u3002</p> <ul> <li>\u6309\u4e0b <code>&lt;Esc&gt;</code> \u6765\u8fd4\u56de\uff0c\u6309 <code>&lt;Enter&gt;</code> \u6765\u9009\u62e9 </li> <li>\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u9f20\u6807\u4f7f\u7528\u8fd9\u4e2a GUI</li> </ul> <p> </p> <p>\u751f\u6210\u793a\u4f8b <code>.env</code> \u6587\u4ef6</p> <p>\u8fd0\u884c <code>ktoolbox example-env</code> \u6765\u751f\u6210\u5b8c\u6574\u7684\u914d\u7f6e\u6587\u4ef6\u6837\u4f8b\u3002</p> <ul> <li>KToolBox \u8bfb\u53d6 \u5de5\u4f5c\u76ee\u5f55 \u4e0b\u7684 <code>.env</code> \u6216 <code>prod.env</code> \u6587\u4ef6 \u6216 \u73af\u5883\u53d8\u91cf \u6765\u8bbe\u5b9a\u914d\u7f6e</li> <li>\u5de5\u4f5c\u76ee\u5f55\u6307\u7684\u662f\u4f60\u6267\u884c <code>ktoolbox</code> \u547d\u4ee4\u7684\u76ee\u5f55\u4f4d\u7f6e\uff0c\u4e0d\u4e00\u5b9a\u662f <code>ktoolbox</code> \u53ef\u6267\u884c\u6587\u4ef6\u6240\u5728\u7684\u76ee\u5f55\u3002\u5728\u54ea\u91cc\u6267\u884c\u5c31\u5728\u54ea\u91cc\u8bfb\u53d6\u3002</li> <li>\u524d\u5f80 \u53c2\u8003 \u67e5\u770b\u6240\u6709\u914d\u7f6e\u9009\u9879</li> <li>\u7528 <code>__</code> \u6765\u6307\u5b9a\u5b50\u9009\u9879, \u4f8b\u5982 <code>KTOOLBOX_API__SCHEME</code> \u76f8\u5f53\u4e8e <code>api.scheme</code></li> <li>\u6240\u6709\u914d\u7f6e\u9009\u9879\u90fd\u662f\u53ef\u9009\u7684</li> </ul>"},{"location":"zh/configuration/guide/#env-prodenv","title":"<code>.env</code> / <code>prod.env</code> \u6587\u4ef6\u793a\u4f8b","text":"<pre><code># \u53ef\u540c\u65f6\u4e0b\u8f7d10\u4e2a\u6587\u4ef6\nKTOOLBOX_JOB__COUNT=10\n\n# \u8bbe\u7f6e\u4f5c\u54c1\u9644\u4ef6\u76ee\u5f55\u4e3a `./`, \u8fd9\u610f\u5473\u7740\u6240\u6709\u9644\u4ef6\u5c06\u76f4\u63a5\u4fdd\u5b58\u5728\u4f5c\u54c1\u76ee\u5f55\u4e0b\n# \u800c\u4e0d\u4f1a\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\u6765\u50a8\u5b58\nKTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n\n# \u6309\u7167\u6570\u5b57\u987a\u5e8f\u91cd\u547d\u540d\u9644\u4ef6, \u4f8b\u5982 `1.png`, `2.png`, ...\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# \u901a\u8fc7\u63d2\u5165\u4e00\u4e2a\u4ee3\u8868\u4e86\u57fa\u672c\u6587\u4ef6\u540d\u7684\u7a7a\u767d\u7684 `{}` \u4ee5\u81ea\u5b9a\u4e49\u6587\u4ef6\u540d\u683c\u5f0f \n# \u4e0e `post_dirname_format` \u7c7b\u4f3c\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e9b `Post` \u7c7b\u91cc\u7684\u5c5e\u6027\n# \u4f8b\u5982 `{title}_{}` &gt; `HelloWorld_b4b41de2-8736-480d-b5c3-ebf0d917561b`\n# \u4f60\u4e5f\u53ef\u4ee5\u548c `sequential_filename` \u642d\u914d\u4f7f\u7528\n# \u4f8b\u5982 `[{published}]_{}` &gt; `[2024-1-1]_1.png`, `[2024-1-1]_2.png`\nKTOOLBOX_JOB__FILENAME_FORMAT=[{published}]_{}\n\n# \u5c06\u53d1\u5e03\u65e5\u671f\u4f5c\u4e3a\u4f5c\u54c1\u76ee\u5f55\u540d\u7684\u5f00\u5934\uff0c\u4f8b\u5982 `[2024-1-1]HelloWorld`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{title}\n</code></pre>"},{"location":"zh/configuration/reference/","title":"\u53c2\u8003","text":""}]}