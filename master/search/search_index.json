{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to KToolBox","text":"KToolBox  <p>   KToolBox is a useful CLI tool for downloading posts content in   Kemono.party / Kemono.su </p> <p> </p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Support concurrent downloading of multiple files</li> <li>Automatically retry on API call or download failure</li> <li>Support downloading a single post or all posts of a specified artist</li> <li>Can update downloaded artist directories to the latest state</li> <li>Support customizing the file and directory name format and directory structure for downloaded posts/artists</li> <li>For example, the post directory can be set to the format <code>[2025-01-02]_TheTitle</code>, and image files can be named sequentially as <code>1.jpg</code>, <code>2.jpg</code>, etc.</li> <li>If you want to store all images from an artist's posts in a single directory for preview, you can use the <code>job.mix_posts</code> config option with a custom filename format to get a directory with hundreds or thousands of images<ul> <li>Such as <code>[2025-01-02]_TheTitle_1.jpg</code>, <code>[2025-01-02]_TheTitle_2.jpg</code>, <code>[2025-01-02]_TheTitle_3.jpg</code>, etc.</li> </ul> </li> <li>Support excluding specified file formats or downloading only specified formats</li> <li>For example, if you don't want to download large and duplicate PSD or archive files, you can exclude <code>.psd</code> and <code>.zip</code> files in the config</li> <li>Support filtering downloads by file size</li> <li>For example, if you want to avoid downloading large video files when running out of disk space, you can set a maximum file size limit in the config</li> <li>You can also set a minimum file size to skip downloading thumbnail or preview images</li> <li>Support filtering downloads by post title keywords</li> <li>For example, if you only want to download posts whose titles contain \"\u8868\u60c5\" or \"\u52b9\u679c\u97f3\u5dee\u5206\", you can use the <code>sync-creator</code> command with the <code>--keywords</code> option</li> <li>You can also exclude posts with specific keywords in the title using the <code>--keywords-exclude</code> option</li> <li>Support filtering downloads by post publish date range</li> <li>Can parse and download images contained in the multi-info text of the post page HTML</li> <li>These posts are characterized by images not loading immediately when the browser enters the page, and no preview images</li> <li>Can collect cloud drive links listed on the post page and save them to a text file</li> <li>Can search for artists and posts, and export results</li> <li>If you want to process artist and post data yourself, you can use this feature to export JSON data</li> <li>Cross-platform support, with iOS shortcuts provided</li> <li>The pure Python branch can run on iOS a-Shell or in the browser via Pyodide</li> <li>For Coomer.st / Coomer.su / Coomer.party support, please refer to the documentation Coomer</li> </ul>"},{"location":"#tutorial","title":"Tutorial","text":""},{"location":"#installation","title":"Installation","text":"<p>You can use executables from releases page</p> NormalPure PythonFor iOS a-Shell <p>Recommend to use pipx <pre><code>pip3 install pipx\n# Windows\npipx install ktoolbox[urwid,winloop]\n# Linux / macOS\npipx install ktoolbox[urwid,uvloop]\n</code></pre></p> <p>If you are using pyodide, or you can only use pure Python and you cannot compile pydantic v2.x.x <pre><code>pip3 install pipx\npipx install ktoolbox-pure-py\n</code></pre></p> <pre><code>pip3 install ktoolbox-pure-py\n</code></pre> <p>About a-Shell</p> <p>a-Shell is an iOS terminal App,  it can only run pure python scripts.</p>"},{"location":"#command","title":"Command","text":"<p>For more information, use the help command or goto Commands page.</p>"},{"location":"#get-general-help","title":"\u2753 Get general help","text":"<pre><code>ktoolbox -h\n</code></pre>"},{"location":"#get-help-of-a-command","title":"\u2753 Get help of a command","text":"<pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"#download-a-specific-post","title":"\u2b07\ufe0f\ud83d\uddbc\ufe0f Download a specific post","text":"<pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> If some files failed to download <p>If some files failed to download, you can try to execute the command line again,  the downloaded files will be skipped.</p>"},{"location":"#download-posts-from-a-creator","title":"\u2b07\ufe0f\ud83d\udd8c\ufe0f Download posts from a creator","text":"<pre><code># Download all posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016\n\n# Download latest 10 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# Download latest No.11-No.15 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n\n# Download posts from the creator/artist from 2024-1-1 to 2024-3-1\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --start-time=2024-1-1 --end-time=2024-3-1\n\n# Download posts from the creator/artist whose title contains \"\u8868\u60c5\"\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --keywords \"\u8868\u60c5\"\n\n# Download posts from the creator/artist whose title contains \"\u8868\u60c5\" or \"\u52b9\u679c\u97f3\u5dee\u5206\"\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --keywords \"\u8868\u60c5,\u52b9\u679c\u97f3\u5dee\u5206\"\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Download 10 files at the same time</li> <li>Rename attachments in numerical order, e.g. <code>1.png</code>, <code>2.png</code>, ...</li> <li>Prefix the post directory name with its release/publish date, e.g. <code>[2024-1-1]HelloWorld</code></li> <li>Use the post title as the prefix for file names, e.g. <code>HelloWorld_1.png</code>, <code>HelloWorld_2.png</code>, ...</li> <li>Download revisions of posts</li> <li>Exclude <code>.psd</code> and <code>.zip</code> files</li> <li>Extract cloud drive links from posts and save them to a text file</li> <li>...</li> </ul> <p>Goto Configuration-Guide page for more details.</p>"},{"location":"about-kemono/","title":"About Kemono","text":"<p>Description from https://kemono.cr :</p> <p>Kemono is a public archiver for:</p> <ul> <li>Patreon</li> <li>Pixiv Fanbox</li> <li>Discord</li> <li>Fantia</li> <li>Afdian</li> <li>Boosty</li> <li>DLsite</li> <li>Gumroad</li> <li>SubscribeStar</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. \\ To get started viewing content, either search for creators on the artists page, or search for content on the posts page.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#ktoolbox.__description__","title":"<code>__description__ = 'A useful CLI tool for downloading posts in Kemono.cr / .su / .party'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__title__","title":"<code>__title__ = 'KToolBox'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__version__","title":"<code>__version__ = 'v0.24.0'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__main__","title":"<code>__main__</code>","text":""},{"location":"api/#ktoolbox.__main__.main","title":"<code>main()</code>","text":"Source code in <code>ktoolbox/__main__.py</code> <pre><code>def main():\n    try:\n        # Handle -v flag before Fire takes over\n        if len(sys.argv) &gt; 1 and sys.argv[1] in ['-v', '--version']:\n            print(__version__)\n            return\n\n        logger_init(cli_use=True)\n        uvloop_init()\n        fire.Fire(KToolBoxCli)\n    except KeyboardInterrupt:\n        logger.error(\"KToolBox was interrupted by the user\")\n</code></pre>"},{"location":"api/#ktoolbox.action","title":"<code>action</code>","text":""},{"location":"api/#ktoolbox.action.ActionRet","title":"<code>ActionRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/action/base.py</code> <pre><code>class ActionRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.action.FetchInterruptError","title":"<code>FetchInterruptError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>class FetchInterruptError(Exception):\n    \"\"\"Exception for interrupt of data fetching\"\"\"\n\n    def __init__(self, *args, ret: BaseRet = None):\n        super().__init__(*args)\n        self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.FetchInterruptError.ret","title":"<code>ret = ret</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.action.FetchInterruptError.__init__","title":"<code>__init__(*args, ret=None)</code>","text":"Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>def __init__(self, *args, ret: BaseRet = None):\n    super().__init__(*args)\n    self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.create_job_from_creator","title":"<code>create_job_from_creator(service, creator_id, path, *, all_pages=False, offset=0, length=50, save_creator_indices=False, mix_posts=None, start_time, end_time, keywords=None, keywords_exclude=None)</code>  <code>async</code>","text":"<p>Create a list of download job from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>path</code> <code>Path</code> <p>The path for downloading posts, which needs to be sanitized</p> required <code>all_pages</code> <code>bool</code> <p>Fetch all posts, <code>offset</code> and <code>length</code> will be ignored if enabled</p> <code>False</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>Optional[int]</code> <p>The number of posts to fetch</p> <code>50</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data.</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path,      <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_time</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required <code>keywords</code> <code>Optional[Set[str]]</code> <p>Set of keywords to filter posts by title (case-insensitive)</p> <code>None</code> <code>keywords_exclude</code> <code>Optional[Set[str]]</code> <p>Set of keywords to exclude posts by title (case-insensitive)</p> <code>None</code> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_creator(\n        service: str,\n        creator_id: str,\n        path: Path,\n        *,\n        all_pages: bool = False,\n        offset: int = 0,\n        length: Optional[int] = 50,\n        save_creator_indices: bool = False,\n        mix_posts: bool = None,\n        start_time: Optional[datetime],\n        end_time: Optional[datetime],\n        keywords: Optional[Set[str]] = None,\n        keywords_exclude: Optional[Set[str]] = None\n) -&gt; ActionRet[List[Job]]:\n    \"\"\"\n    Create a list of download job from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: The path for downloading posts, which needs to be sanitized\n    :param all_pages: Fetch all posts, ``offset`` and ``length`` will be ignored if enabled\n    :param offset: Result offset (or start offset)\n    :param length: The number of posts to fetch\n    :param save_creator_indices: Record ``CreatorIndices`` data.\n    :param mix_posts: Save all files from different posts at same path, \\\n     ``save_creator_indices`` will be ignored if enabled\n    :param start_time: Start time of the time range\n    :param end_time: End time of the time range\n    :param keywords: Set of keywords to filter posts by title (case-insensitive)\n    :param keywords_exclude: Set of keywords to exclude posts by title (case-insensitive)\n    \"\"\"\n    mix_posts = config.job.mix_posts if mix_posts is None else mix_posts\n\n    # Get posts\n    logger.info(f\"Start fetching posts from creator {creator_id}\")\n    post_list: List[Post] = []\n    start_offset = offset - offset % 50\n    if all_pages:\n        page_counter = count()\n    else:\n        page_num = length // 50 + 1\n        page_counter = iter(range(page_num))\n\n    try:\n        async for part in fetch_creator_posts(service=service, creator_id=creator_id, o=start_offset):\n            if next(page_counter, None) is not None:\n                post_list += part\n            else:\n                break\n    except FetchInterruptError as e:\n        return ActionRet(**e.ret.model_dump(mode=\"python\"))\n\n    if not all_pages:\n        post_list = post_list[offset % 50:][:length]\n    else:\n        post_list = post_list[offset % 50:]\n\n    # Filter posts by publish time\n    if start_time or end_time:\n        post_list = list(filter_posts_by_date(post_list, start_time, end_time))\n\n    # Filter posts by keywords\n    if keywords:\n        post_list = list(filter_posts_by_keywords(post_list, keywords))\n\n    # Filter out posts by exclude keywords\n    if keywords_exclude:\n        post_list = list(filter_posts_by_keywords_exclude(post_list, keywords_exclude))\n\n    logger.info(f\"Get {len(post_list)} posts after filtering, start creating jobs\")\n\n    # Filter posts and generate ``CreatorIndices``\n    if not mix_posts:\n        if save_creator_indices:\n            # Generate posts_path with year/month grouping if enabled\n            posts_path = {}\n            for post in post_list:\n                grouped_base_path = generate_grouped_post_path(post, path)\n                posts_path[post.id] = grouped_base_path / sanitize_filename(post.title)\n\n            indices = CreatorIndices(\n                creator_id=creator_id,\n                service=service,\n                posts={post.id: post for post in post_list},\n                posts_path=posts_path\n            )\n            async with aiofiles.open(\n                    path / DataStorageNameEnum.CreatorIndicesData.value,\n                    \"w\",\n                    encoding=\"utf-8\"\n            ) as f:\n                await f.write(indices.model_dump_json(indent=config.json_dump_indent))\n\n    if config.job.include_revisions:\n        logger.warning(\"`job.include_revisions` is enabled and will fetch post revisions, \"\n                       \"which may take time. Disable if not needed.\")\n    if config.job.extract_content or config.job.extract_external_links or config.job.extract_content_images:\n        logger.warning(\n            \"`job.extract_content` or `job.extract_external_links` or `job.extract_content_images` is enabled \"\n            \"and will fetch post content one by one, which may take time. Disable if not needed.\")\n\n    job_list: List[Job] = []\n    for post in post_list:\n        # Get post path\n        if mix_posts:\n            post_path = path\n        else:\n            # Apply year/month grouping if enabled\n            grouped_base_path = generate_grouped_post_path(post, path)\n            post_path = grouped_base_path / generate_post_path_name(post)\n\n        # Generate jobs for the main post\n        try:\n            job_list += await create_job_from_post(\n                post=post,\n                post_path=post_path,\n                post_dir=not mix_posts,\n                dump_post_data=not mix_posts\n            )\n        except FetchInterruptError as e:\n            return ActionRet(**e.ret.model_dump(mode=\"python\"))\n\n        # If include_revisions is enabled, fetch and download revisions for this post\n        if config.job.include_revisions and not mix_posts:\n            try:\n                revisions_ret = await get_post_revisions_api(\n                    service=service,\n                    creator_id=creator_id,\n                    post_id=post.id\n                )\n                if revisions_ret and revisions_ret.data:\n                    for revision in revisions_ret.data:\n                        if revision.revision_id:  # Only process actual revisions\n                            revision_path = post_path / config.job.post_structure.revisions / generate_post_path_name(\n                                revision)\n                            try:\n                                revision_jobs = await create_job_from_post(\n                                    post=revision,\n                                    post_path=revision_path,\n                                    dump_post_data=True\n                                )\n                            except FetchInterruptError as e:\n                                return ActionRet(**e.ret.model_dump(mode=\"python\"))\n                            job_list += revision_jobs\n            except Exception as e:\n                logger.warning(f\"Failed to fetch revisions for post {post.id}: {e}\")\n\n    return ActionRet(data=job_list)\n</code></pre>"},{"location":"api/#ktoolbox.action.create_job_from_post","title":"<code>create_job_from_post(post, post_path, *, post_dir=True, dump_post_data=True)</code>  <code>async</code>","text":"<p>Create a list of download job from a post data</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Union[Post, Revision]</code> <p>post data</p> required <code>post_path</code> <code>Path</code> <p>Path of the post directory, which needs to be sanitized</p> required <code>post_dir</code> <code>bool</code> <p>Whether to create post directory</p> <code>True</code> <code>dump_post_data</code> <code>bool</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> <p>Raises:</p> Type Description <code>FetchInterruptError</code> <p>If fetching post content fails</p> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_post(\n        post: Union[Post, Revision],\n        post_path: Path,\n        *,\n        post_dir: bool = True,\n        dump_post_data: bool = True\n) -&gt; List[Job]:\n    \"\"\"\n    Create a list of download job from a post data\n\n    :param post: post data\n    :param post_path: Path of the post directory, which needs to be sanitized\n    :param post_dir: Whether to create post directory\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    :raise FetchInterruptError: If fetching post content fails\n    \"\"\"\n    post_path.mkdir(parents=True, exist_ok=True)\n\n    # Load ``PostStructureConfiguration``\n    if post_dir:\n        attachments_path = post_path / config.job.post_structure.attachments  # attachments\n        attachments_path.mkdir(exist_ok=True)\n        content_path = post_path / config.job.post_structure.content  # content\n        content_path.parent.mkdir(exist_ok=True)\n        external_links_path = post_path / config.job.post_structure.external_links  # external_links\n        external_links_path.parent.mkdir(exist_ok=True)\n    else:\n        attachments_path = post_path\n        content_path = None\n        external_links_path = None\n\n    if dump_post_data:\n        async with aiofiles.open(str(post_path / DataStorageNameEnum.PostData.value), \"w\", encoding=\"utf-8\") as f:\n            await f.write(\n                post.model_dump_json(indent=config.json_dump_indent)\n            )\n\n    # Filter and create jobs for ``Post.attachment``\n    jobs: List[Job] = []\n    sequential_counter = 1  # Counter for sequential filenames\n    if config.job.download_attachments:\n        for i, attachment in enumerate(post.attachments):  # type: int, Attachment\n            if not attachment.path:\n                continue\n            file_path_obj = Path(attachment.name) if is_valid_filename(attachment.name) else Path(\n                urlparse(attachment.path).path\n            )\n            if (not config.job.allow_list or any(\n                    map(\n                        lambda x: fnmatch(file_path_obj.name, x),\n                        config.job.allow_list\n                    )\n            )) and not any(\n                map(\n                    lambda x: fnmatch(file_path_obj.name, x),\n                    config.job.block_list\n                )\n            ):\n                # Check if file extension should be excluded from sequential naming\n                should_use_sequential = (config.job.sequential_filename and\n                                         file_path_obj.suffix.lower() not in config.job.sequential_filename_excludes)\n                if should_use_sequential:\n                    basic_filename = f\"{sequential_counter}{file_path_obj.suffix}\"\n                    sequential_counter += 1\n                else:\n                    basic_filename = file_path_obj.name\n                alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n                jobs.append(\n                    Job(\n                        path=attachments_path,\n                        alt_filename=alt_filename,\n                        server_path=attachment.path,\n                        type=PostFileTypeEnum.Attachment,\n                        post=post\n                    )\n                )\n\n    # Filter and create jobs for ``Post.file``\n    if config.job.download_file and post.file and post.file.path:\n        post_file_name = Path(post.file.name) if is_valid_filename(post.file.name) else Path(\n            urlparse(post.file.path).path\n        )\n        post_file_name = Path(generate_filename(post, post_file_name.name, config.job.post_structure.file))\n        if (not config.job.allow_list or any(\n                map(\n                    lambda x: fnmatch(post_file_name.name, x),\n                    config.job.allow_list\n                )\n        )) and not any(\n            map(\n                lambda x: fnmatch(post_file_name.name, x),\n                config.job.block_list\n            )\n        ):\n            jobs.append(\n                Job(\n                    path=post_path,\n                    alt_filename=post_file_name.name,\n                    server_path=post.file.path,\n                    type=PostFileTypeEnum.File,\n                    post=post\n                )\n            )\n    # ``post.substring`` is used to determine if the post has content, but it's only partial\n    if (post.content or post.substring) and post_dir and (\n            config.job.extract_content or config.job.extract_external_links or config.job.extract_content_images\n    ):\n        # If post has no content, fetch it from get_post API\n        if not post.content:\n            get_post_ret = await get_post_api(\n                service=post.service,\n                creator_id=post.user,\n                post_id=post.id,\n                revision_id=post.revision_id if isinstance(post, Revision) else None\n            )\n            if get_post_ret:\n                post = get_post_ret.data.post\n            else:\n                logger.error(\n                    generate_msg(\n                        \"Failed to fetch post content\",\n                        post_name=post.title or \"Unknown\",\n                        post_id=post.id,\n                        creator_id=post.user,\n                        service=post.service\n                    )\n                )\n                raise FetchInterruptError(ret=get_post_ret)\n\n        # If post content is still empty, skip content extraction\n        if post.content:\n            # Write content file\n            if config.job.extract_content:\n                async with aiofiles.open(content_path, \"w\", encoding=config.downloader.encoding) as f:\n                    await f.write(post.content)\n\n            # Extract and write external links file\n            if config.job.extract_external_links:\n                external_links = extract_external_links(post.content, config.job.external_link_patterns)\n                if external_links:\n                    async with aiofiles.open(external_links_path, \"w\", encoding=config.downloader.encoding) as f:\n                        # Write each link on a separate line\n                        for link in sorted(external_links):\n                            await f.write(f\"{link}\\n\")\n\n            # Extract content images\n            if config.job.extract_content_images:\n                content_image_sources = extract_content_images(post.content)\n                for image_src in content_image_sources:\n                    if not image_src or not image_src.strip():\n                        continue\n\n                    # Handle relative paths by making them absolute\n                    # noinspection HttpUrlsUsage\n                    if image_src.startswith('/') and not image_src.startswith('//'):\n                        # Relative path - construct full URL\n                        image_path = image_src\n                    elif image_src.startswith('http://') or image_src.startswith('https://'):\n                        # Absolute URL - extract path\n                        image_path = urlparse(image_src).path\n                    else:\n                        # Skip data URLs, protocol-relative URLs, or other non-path sources\n                        continue\n\n                    if not image_path or not image_path.strip():\n                        continue\n\n                    # Generate filename from the image path\n                    image_file_path = Path(image_path)\n\n                    # Apply \"allow/block list\" filtering first (before incrementing counter)\n                    if config.job.sequential_filename:\n                        basic_filename = f\"{sequential_counter + 1}{image_file_path.suffix}\"\n                    else:\n                        basic_filename = image_file_path.name\n\n                    alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n\n                    if (not config.job.allow_list or any(\n                            map(\n                                lambda x: fnmatch(alt_filename, x),\n                                config.job.allow_list\n                            )\n                    )) and not any(\n                        map(\n                            lambda x: fnmatch(alt_filename, x),\n                            config.job.block_list\n                        )\n                    ):\n                        # Regenerate filename with correct counter\n                        should_use_sequential = (config.job.sequential_filename and\n                                                 image_file_path.suffix.lower() not in config.job.sequential_filename_excludes)\n                        if should_use_sequential:\n                            basic_filename = f\"{sequential_counter}{image_file_path.suffix}\"\n                            alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n                            sequential_counter += 1\n\n                        jobs.append(\n                            Job(\n                                path=attachments_path,\n                                alt_filename=alt_filename,\n                                server_path=image_path,\n                                type=PostFileTypeEnum.Attachment\n                            )\n                        )\n\n    return jobs\n</code></pre>"},{"location":"api/#ktoolbox.action.extract_content_images","title":"<code>extract_content_images(content)</code>","text":"<p>Extract image sources from HTML content</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>HTML content string</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of image source URLs/paths</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def extract_content_images(content: str) -&gt; List[str]:\n    \"\"\"\n    Extract image sources from HTML content\n\n    :param content: HTML content string\n    :return: List of image source URLs/paths\n    \"\"\"\n    if not content:\n        return []\n\n    parser = _ContentImageParser()\n    try:\n        parser.feed(content)\n    except Exception as e:\n        logger.warning(f\"Failed to parse HTML content for images: {e}\")\n        return []\n\n    return parser.image_sources\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch_creator_posts","title":"<code>fetch_creator_posts(service, creator_id, o=0)</code>  <code>async</code>","text":"<p>Fetch posts from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>0</code> <p>Returns:</p> Type Description <code>AsyncGenerator[List[Post], Any]</code> <p>Async generator of several list of posts</p> <p>Raises:</p> Type Description <code>FetchInterruptError</code> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>async def fetch_creator_posts(service: str, creator_id: str, o: int = 0) -&gt; AsyncGenerator[List[Post], Any]:\n    \"\"\"\n    Fetch posts from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param o: Result offset, stepping of 50 is enforced\n    :return: Async generator of several list of posts\n    :raise FetchInterruptError: Exception for interrupt of data fetching\n    \"\"\"\n    while True:\n        ret = await get_creator_post(service=service, creator_id=creator_id, o=o)\n        if ret:\n            yield ret.data\n            if len(ret.data) &lt; SEARCH_STEP:\n                break\n            else:\n                o += SEARCH_STEP\n        else:\n            raise FetchInterruptError(ret=ret)\n</code></pre>"},{"location":"api/#ktoolbox.action.filter_posts_by_date","title":"<code>filter_posts_by_date(post_list, start_date, end_date)</code>","text":"<p>Filter posts by publish date range</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>start_date</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_date</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_date(\n        post_list: List[Post],\n        start_date: Optional[datetime],\n        end_date: Optional[datetime]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter posts by publish date range\n\n    :param post_list: List of posts\n    :param start_date: Start time of the time range\n    :param end_date: End time of the time range\n    \"\"\"\n    post_filter = filter(lambda x: _match_post_date(x, start_date, end_date), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.filter_posts_by_indices","title":"<code>filter_posts_by_indices(posts, indices)</code>","text":"<p>Compare and filter posts by <code>CreatorIndices</code> data</p> <p>Only keep posts that was edited after last download.</p> <p>Parameters:</p> Name Type Description Default <code>posts</code> <code>List[Post]</code> <p>Posts to filter</p> required <code>indices</code> <code>CreatorIndices</code> <p><code>CreatorIndices</code> data to use</p> required <p>Returns:</p> Type Description <code>Tuple[List[Post], CreatorIndices]</code> <p>A updated <code>List[Post]</code> and updated new <code>CreatorIndices</code> instance</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_indices(posts: List[Post], indices: CreatorIndices) -&gt; Tuple[List[Post], CreatorIndices]:\n    \"\"\"\n    Compare and filter posts by ``CreatorIndices`` data\n\n    Only keep posts that was edited after last download.\n\n    :param posts: Posts to filter\n    :param indices: ``CreatorIndices`` data to use\n    :return: A updated ``List[Post]`` and updated **new** ``CreatorIndices`` instance\n    \"\"\"\n    new_list = list(\n        filter(\n            lambda x: x.id not in indices.posts or x.edited &gt; indices.posts[x.id].edited, posts\n        )\n    )\n    new_indices = indices.model_copy(deep=True)\n    for post in new_list:\n        new_indices.posts[post.id] = post\n    return new_list, new_indices\n</code></pre>"},{"location":"api/#ktoolbox.action.filter_posts_by_keywords","title":"<code>filter_posts_by_keywords(post_list, keywords)</code>","text":"<p>Filter posts by keywords in title</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>keywords</code> <code>Optional[Set[str]]</code> <p>Set of keywords to search for (case-insensitive), None means no filtering</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_keywords(\n        post_list: List[Post],\n        keywords: Optional[Set[str]]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter posts by keywords in title\n\n    :param post_list: List of posts\n    :param keywords: Set of keywords to search for (case-insensitive), None means no filtering\n    \"\"\"\n    if not keywords:\n        yield from post_list\n        return\n\n    post_filter = filter(lambda x: match_post_keywords(x, keywords), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.filter_posts_by_keywords_exclude","title":"<code>filter_posts_by_keywords_exclude(post_list, keywords_exclude)</code>","text":"<p>Filter out posts that contain any of the specified keywords in title</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>keywords_exclude</code> <code>Optional[Set[str]]</code> <p>Set of keywords to exclude (case-insensitive), None means no filtering</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_keywords_exclude(\n        post_list: List[Post],\n        keywords_exclude: Optional[Set[str]]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter out posts that contain any of the specified keywords in title\n\n    :param post_list: List of posts\n    :param keywords_exclude: Set of keywords to exclude (case-insensitive), None means no filtering\n    \"\"\"\n    if not keywords_exclude:\n        yield from post_list\n        return\n\n    # Exclude posts that match any of the exclude keywords\n    post_filter = filter(lambda x: not match_post_keywords(x, keywords_exclude), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.generate_filename","title":"<code>generate_filename(post, basic_name, filename_format)</code>","text":"<p>Generate download filename</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_filename(post: Post, basic_name: str, filename_format: str) -&gt; str:\n    \"\"\"Generate download filename\"\"\"\n    basic_name_path = Path(basic_name)\n    basic_name_filename = basic_name.replace(basic_name_path.suffix, \"\")\n    try:\n        return sanitize_filename(\n            filename_format.format(\n                basic_name_filename,\n                id=post.id,\n                user=post.user,\n                service=post.service,\n                title=post.title,\n                added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n            ) + basic_name_path.suffix\n        )\n    except KeyError as e:\n        logger.error(\n            f\"`JobConfiguration.filename_format` or `PostStructureConfiguration.file` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.generate_grouped_post_path","title":"<code>generate_grouped_post_path(post, base_path)</code>","text":"<p>Generate the full path for a post considering year/month grouping.</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Post</code> <p>Post object</p> required <code>base_path</code> <code>Path</code> <p>Base path (usually creator directory)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Full path where the post should be saved</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_grouped_post_path(post: Post, base_path: Path) -&gt; Path:\n    \"\"\"\n    Generate the full path for a post considering year/month grouping.\n\n    :param post: Post object\n    :param base_path: Base path (usually creator directory)\n    :return: Full path where the post should be saved\n    \"\"\"\n    result_path = base_path\n\n    if config.job.group_by_year:\n        year_dirname = generate_year_dirname(post)\n        result_path = result_path / year_dirname\n\n        if config.job.group_by_month:\n            month_dirname = generate_month_dirname(post)\n            result_path = result_path / month_dirname\n\n    return result_path\n</code></pre>"},{"location":"api/#ktoolbox.action.generate_month_dirname","title":"<code>generate_month_dirname(post)</code>","text":"<p>Generate month directory name for post grouping.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_month_dirname(post: Post) -&gt; str:\n    \"\"\"Generate month directory name for post grouping.\"\"\"\n    # Use published date, fall back to added date\n    post_date = post.published or post.added\n    if not post_date:\n        return \"unknown\"\n\n    try:\n        return sanitize_filename(\n            config.job.month_dirname_format.format(\n                year=post_date.year,\n                month=post_date.month\n            )\n        )\n    except KeyError as e:\n        logger.error(f\"`JobConfiguration.month_dirname_format` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.generate_post_path_name","title":"<code>generate_post_path_name(post)</code>","text":"<p>Generate directory name for post to save.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_post_path_name(post: Post) -&gt; str:\n    \"\"\"Generate directory name for post to save.\"\"\"\n    if not post.title:\n        return post.id\n    else:\n        try:\n            return sanitize_filename(\n                config.job.post_dirname_format.format(\n                    id=post.id,\n                    user=post.user,\n                    service=post.service,\n                    title=post.title,\n                    added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                    published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                    edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n                )\n            )\n        except KeyError as e:\n            logger.error(f\"`JobConfiguration.post_dirname_format` contains invalid key: {e}\")\n            exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.generate_year_dirname","title":"<code>generate_year_dirname(post)</code>","text":"<p>Generate year directory name for post grouping.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_year_dirname(post: Post) -&gt; str:\n    \"\"\"Generate year directory name for post grouping.\"\"\"\n    # Use published date, fall back to added date\n    post_date = post.published or post.added\n    if not post_date:\n        return \"unknown\"\n\n    try:\n        return sanitize_filename(\n            config.job.year_dirname_format.format(\n                year=post_date.year\n            )\n        )\n    except KeyError as e:\n        logger.error(f\"`JobConfiguration.year_dirname_format` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.match_post_keywords","title":"<code>match_post_keywords(post, keywords)</code>","text":"<p>Check if the post contains any of the specified keywords.</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Post</code> <p>Target post object</p> required <code>keywords</code> <code>Set[str]</code> <p>Set of keywords to search for (case-insensitive)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the post contains any of the keywords in title</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def match_post_keywords(post: Post, keywords: Set[str]) -&gt; bool:\n    \"\"\"\n    Check if the post contains any of the specified keywords.\n\n    :param post: Target post object\n    :param keywords: Set of keywords to search for (case-insensitive)\n    :return: Whether the post contains any of the keywords in title\n    \"\"\"\n    if not keywords:\n        return True\n\n    # Only search in post title\n    searchable_text = \"\"\n    if post.title:\n        searchable_text = post.title.lower()\n\n    # Check if any keyword is found in the title\n    return any(keyword.lower() in searchable_text for keyword in keywords)\n</code></pre>"},{"location":"api/#ktoolbox.action.search_creator","title":"<code>search_creator(id=None, name=None, service=None)</code>  <code>async</code>","text":"<p>Search creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator(id: str = None, name: str = None, service: str = None) -&gt; BaseRet[Iterator[Creator]]:\n    \"\"\"\n    Search creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    \"\"\"\n\n    def filter_func(creator: Creator):\n        \"\"\"Filter creators with attributes\"\"\"\n        if id is not None and creator.id != id:\n            return False\n        if name is not None and name not in creator.name:\n            return False\n        if service is not None and creator.service != service:\n            return False\n        return True\n\n    ret = await get_creators()\n    if not ret:\n        base_ret = BaseRet.model_validate(ret.model_dump())\n        base_ret.data = iter([])\n        return base_ret\n    creators = ret.data\n    return ActionRet(data=iter(filter(filter_func, creators)))\n</code></pre>"},{"location":"api/#ktoolbox.action.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None)</code>  <code>async</code>","text":"<p>Search posts from creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>str</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: str = None\n) -&gt; BaseRet[List[Post]]:\n    \"\"\"\n    Search posts from creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    \"\"\"\n\n    async def inner(**kwargs):\n        posts: List[Post] = []\n        if any([id, name, service]):\n            if id is not None and service:  # ``get_creator_post`` required\n                ret = await get_creator_post(\n                    service=service,\n                    creator_id=id,\n                    q=q,\n                    o=o\n                )\n                return ActionRet(data=ret.data) if ret else ret\n            else:  # else need to get ``id`` and ``service``\n                creators_ret = await search_creator(id=id, name=name, service=service)\n                if not creators_ret:\n                    return ActionRet(**creators_ret.model_dump(mode=\"python\"))\n                else:\n                    for creator in creators_ret.data:\n                        ret = await get_creator_post(\n                            service=creator.service,\n                            creator_id=creator.id,\n                            q=q,\n                            o=o\n                        )\n                        if ret:\n                            posts += ret.data\n                    return ActionRet(data=posts)\n        else:\n            return ActionRet(\n                code=RetCodeEnum.MissingParameter,\n                message=generate_msg(\n                    \"Missing `id`, `name`, `service` parameter, at least given one of them.\",\n                    **kwargs\n                )\n            )\n\n    return await inner(id=id, name=name, service=service, q=q, o=o)\n</code></pre>"},{"location":"api/#ktoolbox.action.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.action.base.__all__","title":"<code>__all__ = ['ActionRet']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.base.ActionRet","title":"<code>ActionRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/action/base.py</code> <pre><code>class ActionRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch","title":"<code>fetch</code>","text":""},{"location":"api/#ktoolbox.action.fetch.__all__","title":"<code>__all__ = ['FetchInterruptError', 'fetch_creator_posts']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError","title":"<code>FetchInterruptError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>class FetchInterruptError(Exception):\n    \"\"\"Exception for interrupt of data fetching\"\"\"\n\n    def __init__(self, *args, ret: BaseRet = None):\n        super().__init__(*args)\n        self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError.ret","title":"<code>ret = ret</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError.__init__","title":"<code>__init__(*args, ret=None)</code>","text":"Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>def __init__(self, *args, ret: BaseRet = None):\n    super().__init__(*args)\n    self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch.fetch_creator_posts","title":"<code>fetch_creator_posts(service, creator_id, o=0)</code>  <code>async</code>","text":"<p>Fetch posts from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>0</code> <p>Returns:</p> Type Description <code>AsyncGenerator[List[Post], Any]</code> <p>Async generator of several list of posts</p> <p>Raises:</p> Type Description <code>FetchInterruptError</code> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>async def fetch_creator_posts(service: str, creator_id: str, o: int = 0) -&gt; AsyncGenerator[List[Post], Any]:\n    \"\"\"\n    Fetch posts from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param o: Result offset, stepping of 50 is enforced\n    :return: Async generator of several list of posts\n    :raise FetchInterruptError: Exception for interrupt of data fetching\n    \"\"\"\n    while True:\n        ret = await get_creator_post(service=service, creator_id=creator_id, o=o)\n        if ret:\n            yield ret.data\n            if len(ret.data) &lt; SEARCH_STEP:\n                break\n            else:\n                o += SEARCH_STEP\n        else:\n            raise FetchInterruptError(ret=ret)\n</code></pre>"},{"location":"api/#ktoolbox.action.job","title":"<code>job</code>","text":""},{"location":"api/#ktoolbox.action.job.__all__","title":"<code>__all__ = ['create_job_from_post', 'create_job_from_creator']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.job.create_job_from_creator","title":"<code>create_job_from_creator(service, creator_id, path, *, all_pages=False, offset=0, length=50, save_creator_indices=False, mix_posts=None, start_time, end_time, keywords=None, keywords_exclude=None)</code>  <code>async</code>","text":"<p>Create a list of download job from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>path</code> <code>Path</code> <p>The path for downloading posts, which needs to be sanitized</p> required <code>all_pages</code> <code>bool</code> <p>Fetch all posts, <code>offset</code> and <code>length</code> will be ignored if enabled</p> <code>False</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>Optional[int]</code> <p>The number of posts to fetch</p> <code>50</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data.</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path,      <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_time</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required <code>keywords</code> <code>Optional[Set[str]]</code> <p>Set of keywords to filter posts by title (case-insensitive)</p> <code>None</code> <code>keywords_exclude</code> <code>Optional[Set[str]]</code> <p>Set of keywords to exclude posts by title (case-insensitive)</p> <code>None</code> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_creator(\n        service: str,\n        creator_id: str,\n        path: Path,\n        *,\n        all_pages: bool = False,\n        offset: int = 0,\n        length: Optional[int] = 50,\n        save_creator_indices: bool = False,\n        mix_posts: bool = None,\n        start_time: Optional[datetime],\n        end_time: Optional[datetime],\n        keywords: Optional[Set[str]] = None,\n        keywords_exclude: Optional[Set[str]] = None\n) -&gt; ActionRet[List[Job]]:\n    \"\"\"\n    Create a list of download job from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: The path for downloading posts, which needs to be sanitized\n    :param all_pages: Fetch all posts, ``offset`` and ``length`` will be ignored if enabled\n    :param offset: Result offset (or start offset)\n    :param length: The number of posts to fetch\n    :param save_creator_indices: Record ``CreatorIndices`` data.\n    :param mix_posts: Save all files from different posts at same path, \\\n     ``save_creator_indices`` will be ignored if enabled\n    :param start_time: Start time of the time range\n    :param end_time: End time of the time range\n    :param keywords: Set of keywords to filter posts by title (case-insensitive)\n    :param keywords_exclude: Set of keywords to exclude posts by title (case-insensitive)\n    \"\"\"\n    mix_posts = config.job.mix_posts if mix_posts is None else mix_posts\n\n    # Get posts\n    logger.info(f\"Start fetching posts from creator {creator_id}\")\n    post_list: List[Post] = []\n    start_offset = offset - offset % 50\n    if all_pages:\n        page_counter = count()\n    else:\n        page_num = length // 50 + 1\n        page_counter = iter(range(page_num))\n\n    try:\n        async for part in fetch_creator_posts(service=service, creator_id=creator_id, o=start_offset):\n            if next(page_counter, None) is not None:\n                post_list += part\n            else:\n                break\n    except FetchInterruptError as e:\n        return ActionRet(**e.ret.model_dump(mode=\"python\"))\n\n    if not all_pages:\n        post_list = post_list[offset % 50:][:length]\n    else:\n        post_list = post_list[offset % 50:]\n\n    # Filter posts by publish time\n    if start_time or end_time:\n        post_list = list(filter_posts_by_date(post_list, start_time, end_time))\n\n    # Filter posts by keywords\n    if keywords:\n        post_list = list(filter_posts_by_keywords(post_list, keywords))\n\n    # Filter out posts by exclude keywords\n    if keywords_exclude:\n        post_list = list(filter_posts_by_keywords_exclude(post_list, keywords_exclude))\n\n    logger.info(f\"Get {len(post_list)} posts after filtering, start creating jobs\")\n\n    # Filter posts and generate ``CreatorIndices``\n    if not mix_posts:\n        if save_creator_indices:\n            # Generate posts_path with year/month grouping if enabled\n            posts_path = {}\n            for post in post_list:\n                grouped_base_path = generate_grouped_post_path(post, path)\n                posts_path[post.id] = grouped_base_path / sanitize_filename(post.title)\n\n            indices = CreatorIndices(\n                creator_id=creator_id,\n                service=service,\n                posts={post.id: post for post in post_list},\n                posts_path=posts_path\n            )\n            async with aiofiles.open(\n                    path / DataStorageNameEnum.CreatorIndicesData.value,\n                    \"w\",\n                    encoding=\"utf-8\"\n            ) as f:\n                await f.write(indices.model_dump_json(indent=config.json_dump_indent))\n\n    if config.job.include_revisions:\n        logger.warning(\"`job.include_revisions` is enabled and will fetch post revisions, \"\n                       \"which may take time. Disable if not needed.\")\n    if config.job.extract_content or config.job.extract_external_links or config.job.extract_content_images:\n        logger.warning(\n            \"`job.extract_content` or `job.extract_external_links` or `job.extract_content_images` is enabled \"\n            \"and will fetch post content one by one, which may take time. Disable if not needed.\")\n\n    job_list: List[Job] = []\n    for post in post_list:\n        # Get post path\n        if mix_posts:\n            post_path = path\n        else:\n            # Apply year/month grouping if enabled\n            grouped_base_path = generate_grouped_post_path(post, path)\n            post_path = grouped_base_path / generate_post_path_name(post)\n\n        # Generate jobs for the main post\n        try:\n            job_list += await create_job_from_post(\n                post=post,\n                post_path=post_path,\n                post_dir=not mix_posts,\n                dump_post_data=not mix_posts\n            )\n        except FetchInterruptError as e:\n            return ActionRet(**e.ret.model_dump(mode=\"python\"))\n\n        # If include_revisions is enabled, fetch and download revisions for this post\n        if config.job.include_revisions and not mix_posts:\n            try:\n                revisions_ret = await get_post_revisions_api(\n                    service=service,\n                    creator_id=creator_id,\n                    post_id=post.id\n                )\n                if revisions_ret and revisions_ret.data:\n                    for revision in revisions_ret.data:\n                        if revision.revision_id:  # Only process actual revisions\n                            revision_path = post_path / config.job.post_structure.revisions / generate_post_path_name(\n                                revision)\n                            try:\n                                revision_jobs = await create_job_from_post(\n                                    post=revision,\n                                    post_path=revision_path,\n                                    dump_post_data=True\n                                )\n                            except FetchInterruptError as e:\n                                return ActionRet(**e.ret.model_dump(mode=\"python\"))\n                            job_list += revision_jobs\n            except Exception as e:\n                logger.warning(f\"Failed to fetch revisions for post {post.id}: {e}\")\n\n    return ActionRet(data=job_list)\n</code></pre>"},{"location":"api/#ktoolbox.action.job.create_job_from_post","title":"<code>create_job_from_post(post, post_path, *, post_dir=True, dump_post_data=True)</code>  <code>async</code>","text":"<p>Create a list of download job from a post data</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Union[Post, Revision]</code> <p>post data</p> required <code>post_path</code> <code>Path</code> <p>Path of the post directory, which needs to be sanitized</p> required <code>post_dir</code> <code>bool</code> <p>Whether to create post directory</p> <code>True</code> <code>dump_post_data</code> <code>bool</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> <p>Raises:</p> Type Description <code>FetchInterruptError</code> <p>If fetching post content fails</p> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_post(\n        post: Union[Post, Revision],\n        post_path: Path,\n        *,\n        post_dir: bool = True,\n        dump_post_data: bool = True\n) -&gt; List[Job]:\n    \"\"\"\n    Create a list of download job from a post data\n\n    :param post: post data\n    :param post_path: Path of the post directory, which needs to be sanitized\n    :param post_dir: Whether to create post directory\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    :raise FetchInterruptError: If fetching post content fails\n    \"\"\"\n    post_path.mkdir(parents=True, exist_ok=True)\n\n    # Load ``PostStructureConfiguration``\n    if post_dir:\n        attachments_path = post_path / config.job.post_structure.attachments  # attachments\n        attachments_path.mkdir(exist_ok=True)\n        content_path = post_path / config.job.post_structure.content  # content\n        content_path.parent.mkdir(exist_ok=True)\n        external_links_path = post_path / config.job.post_structure.external_links  # external_links\n        external_links_path.parent.mkdir(exist_ok=True)\n    else:\n        attachments_path = post_path\n        content_path = None\n        external_links_path = None\n\n    if dump_post_data:\n        async with aiofiles.open(str(post_path / DataStorageNameEnum.PostData.value), \"w\", encoding=\"utf-8\") as f:\n            await f.write(\n                post.model_dump_json(indent=config.json_dump_indent)\n            )\n\n    # Filter and create jobs for ``Post.attachment``\n    jobs: List[Job] = []\n    sequential_counter = 1  # Counter for sequential filenames\n    if config.job.download_attachments:\n        for i, attachment in enumerate(post.attachments):  # type: int, Attachment\n            if not attachment.path:\n                continue\n            file_path_obj = Path(attachment.name) if is_valid_filename(attachment.name) else Path(\n                urlparse(attachment.path).path\n            )\n            if (not config.job.allow_list or any(\n                    map(\n                        lambda x: fnmatch(file_path_obj.name, x),\n                        config.job.allow_list\n                    )\n            )) and not any(\n                map(\n                    lambda x: fnmatch(file_path_obj.name, x),\n                    config.job.block_list\n                )\n            ):\n                # Check if file extension should be excluded from sequential naming\n                should_use_sequential = (config.job.sequential_filename and\n                                         file_path_obj.suffix.lower() not in config.job.sequential_filename_excludes)\n                if should_use_sequential:\n                    basic_filename = f\"{sequential_counter}{file_path_obj.suffix}\"\n                    sequential_counter += 1\n                else:\n                    basic_filename = file_path_obj.name\n                alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n                jobs.append(\n                    Job(\n                        path=attachments_path,\n                        alt_filename=alt_filename,\n                        server_path=attachment.path,\n                        type=PostFileTypeEnum.Attachment,\n                        post=post\n                    )\n                )\n\n    # Filter and create jobs for ``Post.file``\n    if config.job.download_file and post.file and post.file.path:\n        post_file_name = Path(post.file.name) if is_valid_filename(post.file.name) else Path(\n            urlparse(post.file.path).path\n        )\n        post_file_name = Path(generate_filename(post, post_file_name.name, config.job.post_structure.file))\n        if (not config.job.allow_list or any(\n                map(\n                    lambda x: fnmatch(post_file_name.name, x),\n                    config.job.allow_list\n                )\n        )) and not any(\n            map(\n                lambda x: fnmatch(post_file_name.name, x),\n                config.job.block_list\n            )\n        ):\n            jobs.append(\n                Job(\n                    path=post_path,\n                    alt_filename=post_file_name.name,\n                    server_path=post.file.path,\n                    type=PostFileTypeEnum.File,\n                    post=post\n                )\n            )\n    # ``post.substring`` is used to determine if the post has content, but it's only partial\n    if (post.content or post.substring) and post_dir and (\n            config.job.extract_content or config.job.extract_external_links or config.job.extract_content_images\n    ):\n        # If post has no content, fetch it from get_post API\n        if not post.content:\n            get_post_ret = await get_post_api(\n                service=post.service,\n                creator_id=post.user,\n                post_id=post.id,\n                revision_id=post.revision_id if isinstance(post, Revision) else None\n            )\n            if get_post_ret:\n                post = get_post_ret.data.post\n            else:\n                logger.error(\n                    generate_msg(\n                        \"Failed to fetch post content\",\n                        post_name=post.title or \"Unknown\",\n                        post_id=post.id,\n                        creator_id=post.user,\n                        service=post.service\n                    )\n                )\n                raise FetchInterruptError(ret=get_post_ret)\n\n        # If post content is still empty, skip content extraction\n        if post.content:\n            # Write content file\n            if config.job.extract_content:\n                async with aiofiles.open(content_path, \"w\", encoding=config.downloader.encoding) as f:\n                    await f.write(post.content)\n\n            # Extract and write external links file\n            if config.job.extract_external_links:\n                external_links = extract_external_links(post.content, config.job.external_link_patterns)\n                if external_links:\n                    async with aiofiles.open(external_links_path, \"w\", encoding=config.downloader.encoding) as f:\n                        # Write each link on a separate line\n                        for link in sorted(external_links):\n                            await f.write(f\"{link}\\n\")\n\n            # Extract content images\n            if config.job.extract_content_images:\n                content_image_sources = extract_content_images(post.content)\n                for image_src in content_image_sources:\n                    if not image_src or not image_src.strip():\n                        continue\n\n                    # Handle relative paths by making them absolute\n                    # noinspection HttpUrlsUsage\n                    if image_src.startswith('/') and not image_src.startswith('//'):\n                        # Relative path - construct full URL\n                        image_path = image_src\n                    elif image_src.startswith('http://') or image_src.startswith('https://'):\n                        # Absolute URL - extract path\n                        image_path = urlparse(image_src).path\n                    else:\n                        # Skip data URLs, protocol-relative URLs, or other non-path sources\n                        continue\n\n                    if not image_path or not image_path.strip():\n                        continue\n\n                    # Generate filename from the image path\n                    image_file_path = Path(image_path)\n\n                    # Apply \"allow/block list\" filtering first (before incrementing counter)\n                    if config.job.sequential_filename:\n                        basic_filename = f\"{sequential_counter + 1}{image_file_path.suffix}\"\n                    else:\n                        basic_filename = image_file_path.name\n\n                    alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n\n                    if (not config.job.allow_list or any(\n                            map(\n                                lambda x: fnmatch(alt_filename, x),\n                                config.job.allow_list\n                            )\n                    )) and not any(\n                        map(\n                            lambda x: fnmatch(alt_filename, x),\n                            config.job.block_list\n                        )\n                    ):\n                        # Regenerate filename with correct counter\n                        should_use_sequential = (config.job.sequential_filename and\n                                                 image_file_path.suffix.lower() not in config.job.sequential_filename_excludes)\n                        if should_use_sequential:\n                            basic_filename = f\"{sequential_counter}{image_file_path.suffix}\"\n                            alt_filename = generate_filename(post, basic_filename, config.job.filename_format)\n                            sequential_counter += 1\n\n                        jobs.append(\n                            Job(\n                                path=attachments_path,\n                                alt_filename=alt_filename,\n                                server_path=image_path,\n                                type=PostFileTypeEnum.Attachment\n                            )\n                        )\n\n    return jobs\n</code></pre>"},{"location":"api/#ktoolbox.action.search","title":"<code>search</code>","text":""},{"location":"api/#ktoolbox.action.search.__all__","title":"<code>__all__ = ['search_creator', 'search_creator_post']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.search.search_creator","title":"<code>search_creator(id=None, name=None, service=None)</code>  <code>async</code>","text":"<p>Search creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator(id: str = None, name: str = None, service: str = None) -&gt; BaseRet[Iterator[Creator]]:\n    \"\"\"\n    Search creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    \"\"\"\n\n    def filter_func(creator: Creator):\n        \"\"\"Filter creators with attributes\"\"\"\n        if id is not None and creator.id != id:\n            return False\n        if name is not None and name not in creator.name:\n            return False\n        if service is not None and creator.service != service:\n            return False\n        return True\n\n    ret = await get_creators()\n    if not ret:\n        base_ret = BaseRet.model_validate(ret.model_dump())\n        base_ret.data = iter([])\n        return base_ret\n    creators = ret.data\n    return ActionRet(data=iter(filter(filter_func, creators)))\n</code></pre>"},{"location":"api/#ktoolbox.action.search.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None)</code>  <code>async</code>","text":"<p>Search posts from creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>str</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: str = None\n) -&gt; BaseRet[List[Post]]:\n    \"\"\"\n    Search posts from creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    \"\"\"\n\n    async def inner(**kwargs):\n        posts: List[Post] = []\n        if any([id, name, service]):\n            if id is not None and service:  # ``get_creator_post`` required\n                ret = await get_creator_post(\n                    service=service,\n                    creator_id=id,\n                    q=q,\n                    o=o\n                )\n                return ActionRet(data=ret.data) if ret else ret\n            else:  # else need to get ``id`` and ``service``\n                creators_ret = await search_creator(id=id, name=name, service=service)\n                if not creators_ret:\n                    return ActionRet(**creators_ret.model_dump(mode=\"python\"))\n                else:\n                    for creator in creators_ret.data:\n                        ret = await get_creator_post(\n                            service=creator.service,\n                            creator_id=creator.id,\n                            q=q,\n                            o=o\n                        )\n                        if ret:\n                            posts += ret.data\n                    return ActionRet(data=posts)\n        else:\n            return ActionRet(\n                code=RetCodeEnum.MissingParameter,\n                message=generate_msg(\n                    \"Missing `id`, `name`, `service` parameter, at least given one of them.\",\n                    **kwargs\n                )\n            )\n\n    return await inner(id=id, name=name, service=service, q=q, o=o)\n</code></pre>"},{"location":"api/#ktoolbox.action.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.action.utils.TIME_FORMAT","title":"<code>TIME_FORMAT = '%Y-%m-%d'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.utils.__all__","title":"<code>__all__ = ['generate_post_path_name', 'generate_filename', 'generate_year_dirname', 'generate_month_dirname', 'generate_grouped_post_path', 'filter_posts_by_date', 'filter_posts_by_indices', 'match_post_keywords', 'filter_posts_by_keywords', 'filter_posts_by_keywords_exclude', 'extract_content_images']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.utils.extract_content_images","title":"<code>extract_content_images(content)</code>","text":"<p>Extract image sources from HTML content</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>HTML content string</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of image source URLs/paths</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def extract_content_images(content: str) -&gt; List[str]:\n    \"\"\"\n    Extract image sources from HTML content\n\n    :param content: HTML content string\n    :return: List of image source URLs/paths\n    \"\"\"\n    if not content:\n        return []\n\n    parser = _ContentImageParser()\n    try:\n        parser.feed(content)\n    except Exception as e:\n        logger.warning(f\"Failed to parse HTML content for images: {e}\")\n        return []\n\n    return parser.image_sources\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.filter_posts_by_date","title":"<code>filter_posts_by_date(post_list, start_date, end_date)</code>","text":"<p>Filter posts by publish date range</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>start_date</code> <code>Optional[datetime]</code> <p>Start time of the time range</p> required <code>end_date</code> <code>Optional[datetime]</code> <p>End time of the time range</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_date(\n        post_list: List[Post],\n        start_date: Optional[datetime],\n        end_date: Optional[datetime]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter posts by publish date range\n\n    :param post_list: List of posts\n    :param start_date: Start time of the time range\n    :param end_date: End time of the time range\n    \"\"\"\n    post_filter = filter(lambda x: _match_post_date(x, start_date, end_date), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.filter_posts_by_indices","title":"<code>filter_posts_by_indices(posts, indices)</code>","text":"<p>Compare and filter posts by <code>CreatorIndices</code> data</p> <p>Only keep posts that was edited after last download.</p> <p>Parameters:</p> Name Type Description Default <code>posts</code> <code>List[Post]</code> <p>Posts to filter</p> required <code>indices</code> <code>CreatorIndices</code> <p><code>CreatorIndices</code> data to use</p> required <p>Returns:</p> Type Description <code>Tuple[List[Post], CreatorIndices]</code> <p>A updated <code>List[Post]</code> and updated new <code>CreatorIndices</code> instance</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_indices(posts: List[Post], indices: CreatorIndices) -&gt; Tuple[List[Post], CreatorIndices]:\n    \"\"\"\n    Compare and filter posts by ``CreatorIndices`` data\n\n    Only keep posts that was edited after last download.\n\n    :param posts: Posts to filter\n    :param indices: ``CreatorIndices`` data to use\n    :return: A updated ``List[Post]`` and updated **new** ``CreatorIndices`` instance\n    \"\"\"\n    new_list = list(\n        filter(\n            lambda x: x.id not in indices.posts or x.edited &gt; indices.posts[x.id].edited, posts\n        )\n    )\n    new_indices = indices.model_copy(deep=True)\n    for post in new_list:\n        new_indices.posts[post.id] = post\n    return new_list, new_indices\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.filter_posts_by_keywords","title":"<code>filter_posts_by_keywords(post_list, keywords)</code>","text":"<p>Filter posts by keywords in title</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>keywords</code> <code>Optional[Set[str]]</code> <p>Set of keywords to search for (case-insensitive), None means no filtering</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_keywords(\n        post_list: List[Post],\n        keywords: Optional[Set[str]]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter posts by keywords in title\n\n    :param post_list: List of posts\n    :param keywords: Set of keywords to search for (case-insensitive), None means no filtering\n    \"\"\"\n    if not keywords:\n        yield from post_list\n        return\n\n    post_filter = filter(lambda x: match_post_keywords(x, keywords), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.filter_posts_by_keywords_exclude","title":"<code>filter_posts_by_keywords_exclude(post_list, keywords_exclude)</code>","text":"<p>Filter out posts that contain any of the specified keywords in title</p> <p>Parameters:</p> Name Type Description Default <code>post_list</code> <code>List[Post]</code> <p>List of posts</p> required <code>keywords_exclude</code> <code>Optional[Set[str]]</code> <p>Set of keywords to exclude (case-insensitive), None means no filtering</p> required Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def filter_posts_by_keywords_exclude(\n        post_list: List[Post],\n        keywords_exclude: Optional[Set[str]]\n) -&gt; Generator[Post, Any, Any]:\n    \"\"\"\n    Filter out posts that contain any of the specified keywords in title\n\n    :param post_list: List of posts\n    :param keywords_exclude: Set of keywords to exclude (case-insensitive), None means no filtering\n    \"\"\"\n    if not keywords_exclude:\n        yield from post_list\n        return\n\n    # Exclude posts that match any of the exclude keywords\n    post_filter = filter(lambda x: not match_post_keywords(x, keywords_exclude), post_list)\n    yield from post_filter\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.generate_filename","title":"<code>generate_filename(post, basic_name, filename_format)</code>","text":"<p>Generate download filename</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_filename(post: Post, basic_name: str, filename_format: str) -&gt; str:\n    \"\"\"Generate download filename\"\"\"\n    basic_name_path = Path(basic_name)\n    basic_name_filename = basic_name.replace(basic_name_path.suffix, \"\")\n    try:\n        return sanitize_filename(\n            filename_format.format(\n                basic_name_filename,\n                id=post.id,\n                user=post.user,\n                service=post.service,\n                title=post.title,\n                added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n            ) + basic_name_path.suffix\n        )\n    except KeyError as e:\n        logger.error(\n            f\"`JobConfiguration.filename_format` or `PostStructureConfiguration.file` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.generate_grouped_post_path","title":"<code>generate_grouped_post_path(post, base_path)</code>","text":"<p>Generate the full path for a post considering year/month grouping.</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Post</code> <p>Post object</p> required <code>base_path</code> <code>Path</code> <p>Base path (usually creator directory)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Full path where the post should be saved</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_grouped_post_path(post: Post, base_path: Path) -&gt; Path:\n    \"\"\"\n    Generate the full path for a post considering year/month grouping.\n\n    :param post: Post object\n    :param base_path: Base path (usually creator directory)\n    :return: Full path where the post should be saved\n    \"\"\"\n    result_path = base_path\n\n    if config.job.group_by_year:\n        year_dirname = generate_year_dirname(post)\n        result_path = result_path / year_dirname\n\n        if config.job.group_by_month:\n            month_dirname = generate_month_dirname(post)\n            result_path = result_path / month_dirname\n\n    return result_path\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.generate_month_dirname","title":"<code>generate_month_dirname(post)</code>","text":"<p>Generate month directory name for post grouping.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_month_dirname(post: Post) -&gt; str:\n    \"\"\"Generate month directory name for post grouping.\"\"\"\n    # Use published date, fall back to added date\n    post_date = post.published or post.added\n    if not post_date:\n        return \"unknown\"\n\n    try:\n        return sanitize_filename(\n            config.job.month_dirname_format.format(\n                year=post_date.year,\n                month=post_date.month\n            )\n        )\n    except KeyError as e:\n        logger.error(f\"`JobConfiguration.month_dirname_format` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.generate_post_path_name","title":"<code>generate_post_path_name(post)</code>","text":"<p>Generate directory name for post to save.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_post_path_name(post: Post) -&gt; str:\n    \"\"\"Generate directory name for post to save.\"\"\"\n    if not post.title:\n        return post.id\n    else:\n        try:\n            return sanitize_filename(\n                config.job.post_dirname_format.format(\n                    id=post.id,\n                    user=post.user,\n                    service=post.service,\n                    title=post.title,\n                    added=post.added.strftime(TIME_FORMAT) if post.added else \"\",\n                    published=post.published.strftime(TIME_FORMAT) if post.published else \"\",\n                    edited=post.edited.strftime(TIME_FORMAT) if post.edited else \"\"\n                )\n            )\n        except KeyError as e:\n            logger.error(f\"`JobConfiguration.post_dirname_format` contains invalid key: {e}\")\n            exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.generate_year_dirname","title":"<code>generate_year_dirname(post)</code>","text":"<p>Generate year directory name for post grouping.</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def generate_year_dirname(post: Post) -&gt; str:\n    \"\"\"Generate year directory name for post grouping.\"\"\"\n    # Use published date, fall back to added date\n    post_date = post.published or post.added\n    if not post_date:\n        return \"unknown\"\n\n    try:\n        return sanitize_filename(\n            config.job.year_dirname_format.format(\n                year=post_date.year\n            )\n        )\n    except KeyError as e:\n        logger.error(f\"`JobConfiguration.year_dirname_format` contains invalid key: {e}\")\n        exit(1)\n</code></pre>"},{"location":"api/#ktoolbox.action.utils.match_post_keywords","title":"<code>match_post_keywords(post, keywords)</code>","text":"<p>Check if the post contains any of the specified keywords.</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Post</code> <p>Target post object</p> required <code>keywords</code> <code>Set[str]</code> <p>Set of keywords to search for (case-insensitive)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the post contains any of the keywords in title</p> Source code in <code>ktoolbox/action/utils.py</code> <pre><code>def match_post_keywords(post: Post, keywords: Set[str]) -&gt; bool:\n    \"\"\"\n    Check if the post contains any of the specified keywords.\n\n    :param post: Target post object\n    :param keywords: Set of keywords to search for (case-insensitive)\n    :return: Whether the post contains any of the keywords in title\n    \"\"\"\n    if not keywords:\n        return True\n\n    # Only search in post title\n    searchable_text = \"\"\n    if post.title:\n        searchable_text = post.title.lower()\n\n    # Check if any keyword is found in the title\n    return any(keyword.lower() in searchable_text for keyword in keywords)\n</code></pre>"},{"location":"api/#ktoolbox.api","title":"<code>api</code>","text":"<ul> <li> <p>Kemono API version: <code>1.0.0</code></p> </li> <li> <p>current App commit hash: <code>7ee4a7b18ee92a442c13950c05dc8236cfb14a60</code></p> </li> </ul>"},{"location":"api/#ktoolbox.api.APIRet","title":"<code>APIRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of API call</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APIRet(BaseRet[_T]):\n    \"\"\"Return data model of API call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.api.APITenacityStop","title":"<code>APITenacityStop</code>","text":"<p>               Bases: <code>stop_base</code></p> <p>APIs Stop strategies</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APITenacityStop(stop_base):\n    \"\"\"APIs Stop strategies\"\"\"\n\n    def __call__(self, retry_state: RetryCallState) -&gt; bool:\n        if config.api.retry_times is None:\n            return stop_never(retry_state)\n        else:\n            return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.APITenacityStop.__call__","title":"<code>__call__(retry_state)</code>","text":"Source code in <code>ktoolbox/api/base.py</code> <pre><code>def __call__(self, retry_state: RetryCallState) -&gt; bool:\n    if config.api.retry_times is None:\n        return stop_never(retry_state)\n    else:\n        return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI","title":"<code>BaseAPI</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_T]</code></p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class BaseAPI(ABC, Generic[_T]):\n    path: str = \"/\"\n    method: Literal[\"get\", \"post\"]\n    extra_validator: Optional[Callable[[str], BaseModel]] = None\n    client = httpx.AsyncClient(\n        verify=config.ssl_verify,\n        headers={\"Accept\": \"text/css\"},\n        cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    )\n\n    Response = BaseModel\n    \"\"\"API response model\"\"\"\n\n    @classmethod\n    def handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n        \"\"\"Handle API response\"\"\"\n        try:\n            if cls.extra_validator:\n                res_model = cls.extra_validator(res.text)\n            else:\n                res_model = cls.Response.model_validate_json(res.text)\n        except (ValueError, ValidationError) as e:\n            return APIRet(\n                code=RetCodeEnum.JsonDecodeError if isinstance(e, ValueError) else RetCodeEnum.ValidationError,\n                message=generate_msg(url=res.url, status_code=res.status_code, response=res.text),\n                exception=e\n            )\n        else:\n            data = res_model.root if isinstance(res_model, RootModel) else res_model\n            return APIRet(data=data)\n\n    @classmethod\n    @_retry\n    async def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n        \"\"\"\n        Make a request to the API\n        :param path: Fully initialed URL path\n        :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n        \"\"\"\n        if path is None:\n            path = cls.path\n        url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n        url = str(urlunparse(url_parts))\n        try:\n            res = await cls.client.request(\n                method=cls.method,\n                url=url,\n                timeout=config.api.timeout,\n                follow_redirects=True,\n                **kwargs\n            )\n        except Exception as e:\n            return APIRet(\n                code=RetCodeEnum.NetWorkError,\n                message=generate_msg(url=url),\n                exception=e\n            )\n        else:\n            return cls.handle_res(res)\n\n    @classmethod\n    @abstractmethod\n    async def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n        \"\"\"Function to call API\"\"\"\n        ...\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI.Response","title":"<code>Response = BaseModel</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>API response model</p>"},{"location":"api/#ktoolbox.api.BaseAPI.client","title":"<code>client = httpx.AsyncClient(verify=config.ssl_verify, headers={'Accept': 'text/css'}, cookies={'session': config.api.session_key} if config.api.session_key else None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.extra_validator","title":"<code>extra_validator: Optional[Callable[[str], BaseModel]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.method","title":"<code>method: Literal['get', 'post']</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.path","title":"<code>path: str = '/'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.BaseAPI.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Function to call API</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@abstractmethod\nasync def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n    \"\"\"Function to call API\"\"\"\n    ...\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI.handle_res","title":"<code>handle_res(res)</code>  <code>classmethod</code>","text":"<p>Handle API response</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\ndef handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n    \"\"\"Handle API response\"\"\"\n    try:\n        if cls.extra_validator:\n            res_model = cls.extra_validator(res.text)\n        else:\n            res_model = cls.Response.model_validate_json(res.text)\n    except (ValueError, ValidationError) as e:\n        return APIRet(\n            code=RetCodeEnum.JsonDecodeError if isinstance(e, ValueError) else RetCodeEnum.ValidationError,\n            message=generate_msg(url=res.url, status_code=res.status_code, response=res.text),\n            exception=e\n        )\n    else:\n        data = res_model.root if isinstance(res_model, RootModel) else res_model\n        return APIRet(data=data)\n</code></pre>"},{"location":"api/#ktoolbox.api.BaseAPI.request","title":"<code>request(path=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Make a request to the API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Fully initialed URL path</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments of <code>httpx._client.AsyncClient.request</code></p> <code>{}</code> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@_retry\nasync def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n    \"\"\"\n    Make a request to the API\n    :param path: Fully initialed URL path\n    :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n    \"\"\"\n    if path is None:\n        path = cls.path\n    url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n    url = str(urlunparse(url_parts))\n    try:\n        res = await cls.client.request(\n            method=cls.method,\n            url=url,\n            timeout=config.api.timeout,\n            follow_redirects=True,\n            **kwargs\n        )\n    except Exception as e:\n        return APIRet(\n            code=RetCodeEnum.NetWorkError,\n            message=generate_msg(url=url),\n            exception=e\n        )\n    else:\n        return cls.handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.api.base.__all__","title":"<code>__all__ = ['APITenacityStop', 'APIRet', 'BaseAPI']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.APIRet","title":"<code>APIRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of API call</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APIRet(BaseRet[_T]):\n    \"\"\"Return data model of API call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.api.base.APITenacityStop","title":"<code>APITenacityStop</code>","text":"<p>               Bases: <code>stop_base</code></p> <p>APIs Stop strategies</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APITenacityStop(stop_base):\n    \"\"\"APIs Stop strategies\"\"\"\n\n    def __call__(self, retry_state: RetryCallState) -&gt; bool:\n        if config.api.retry_times is None:\n            return stop_never(retry_state)\n        else:\n            return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.APITenacityStop.__call__","title":"<code>__call__(retry_state)</code>","text":"Source code in <code>ktoolbox/api/base.py</code> <pre><code>def __call__(self, retry_state: RetryCallState) -&gt; bool:\n    if config.api.retry_times is None:\n        return stop_never(retry_state)\n    else:\n        return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI","title":"<code>BaseAPI</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_T]</code></p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class BaseAPI(ABC, Generic[_T]):\n    path: str = \"/\"\n    method: Literal[\"get\", \"post\"]\n    extra_validator: Optional[Callable[[str], BaseModel]] = None\n    client = httpx.AsyncClient(\n        verify=config.ssl_verify,\n        headers={\"Accept\": \"text/css\"},\n        cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    )\n\n    Response = BaseModel\n    \"\"\"API response model\"\"\"\n\n    @classmethod\n    def handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n        \"\"\"Handle API response\"\"\"\n        try:\n            if cls.extra_validator:\n                res_model = cls.extra_validator(res.text)\n            else:\n                res_model = cls.Response.model_validate_json(res.text)\n        except (ValueError, ValidationError) as e:\n            return APIRet(\n                code=RetCodeEnum.JsonDecodeError if isinstance(e, ValueError) else RetCodeEnum.ValidationError,\n                message=generate_msg(url=res.url, status_code=res.status_code, response=res.text),\n                exception=e\n            )\n        else:\n            data = res_model.root if isinstance(res_model, RootModel) else res_model\n            return APIRet(data=data)\n\n    @classmethod\n    @_retry\n    async def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n        \"\"\"\n        Make a request to the API\n        :param path: Fully initialed URL path\n        :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n        \"\"\"\n        if path is None:\n            path = cls.path\n        url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n        url = str(urlunparse(url_parts))\n        try:\n            res = await cls.client.request(\n                method=cls.method,\n                url=url,\n                timeout=config.api.timeout,\n                follow_redirects=True,\n                **kwargs\n            )\n        except Exception as e:\n            return APIRet(\n                code=RetCodeEnum.NetWorkError,\n                message=generate_msg(url=url),\n                exception=e\n            )\n        else:\n            return cls.handle_res(res)\n\n    @classmethod\n    @abstractmethod\n    async def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n        \"\"\"Function to call API\"\"\"\n        ...\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.Response","title":"<code>Response = BaseModel</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>API response model</p>"},{"location":"api/#ktoolbox.api.base.BaseAPI.client","title":"<code>client = httpx.AsyncClient(verify=config.ssl_verify, headers={'Accept': 'text/css'}, cookies={'session': config.api.session_key} if config.api.session_key else None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.extra_validator","title":"<code>extra_validator: Optional[Callable[[str], BaseModel]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.method","title":"<code>method: Literal['get', 'post']</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.path","title":"<code>path: str = '/'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Function to call API</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@abstractmethod\nasync def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n    \"\"\"Function to call API\"\"\"\n    ...\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.handle_res","title":"<code>handle_res(res)</code>  <code>classmethod</code>","text":"<p>Handle API response</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\ndef handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n    \"\"\"Handle API response\"\"\"\n    try:\n        if cls.extra_validator:\n            res_model = cls.extra_validator(res.text)\n        else:\n            res_model = cls.Response.model_validate_json(res.text)\n    except (ValueError, ValidationError) as e:\n        return APIRet(\n            code=RetCodeEnum.JsonDecodeError if isinstance(e, ValueError) else RetCodeEnum.ValidationError,\n            message=generate_msg(url=res.url, status_code=res.status_code, response=res.text),\n            exception=e\n        )\n    else:\n        data = res_model.root if isinstance(res_model, RootModel) else res_model\n        return APIRet(data=data)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.request","title":"<code>request(path=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Make a request to the API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Fully initialed URL path</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments of <code>httpx._client.AsyncClient.request</code></p> <code>{}</code> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@_retry\nasync def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n    \"\"\"\n    Make a request to the API\n    :param path: Fully initialed URL path\n    :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n    \"\"\"\n    if path is None:\n        path = cls.path\n    url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n    url = str(urlunparse(url_parts))\n    try:\n        res = await cls.client.request(\n            method=cls.method,\n            url=url,\n            timeout=config.api.timeout,\n            follow_redirects=True,\n            **kwargs\n        )\n    except Exception as e:\n        return APIRet(\n            code=RetCodeEnum.NetWorkError,\n            message=generate_msg(url=url),\n            exception=e\n        )\n    else:\n        return cls.handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.misc","title":"<code>misc</code>","text":""},{"location":"api/#ktoolbox.api.misc.get_app_version","title":"<code>get_app_version = GetAppVersion.__call__</code>  <code>module-attribute</code>","text":"<p>Show current App commit hash</p>"},{"location":"api/#ktoolbox.api.misc.GetAppVersion","title":"<code>GetAppVersion</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/misc/get_app_version.py</code> <pre><code>class GetAppVersion(BaseAPI):\n    path = \"/app_version\"\n    method = \"get\"\n\n    class Response(RootModel[str]):\n        root: str\n\n    extra_validator = Response.model_validate_strings\n\n    @classmethod\n    async def __call__(cls) -&gt; APIRet[str]:\n        return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.misc.GetAppVersion.extra_validator","title":"<code>extra_validator = Response.model_validate_strings</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.path","title":"<code>path = '/app_version'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[str]</code></p> Source code in <code>ktoolbox/api/misc/get_app_version.py</code> <pre><code>class Response(RootModel[str]):\n    root: str\n</code></pre>"},{"location":"api/#ktoolbox.api.misc.GetAppVersion.Response.root","title":"<code>root: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.misc.GetAppVersion.__call__","title":"<code>__call__()</code>  <code>async</code> <code>classmethod</code>","text":"Source code in <code>ktoolbox/api/misc/get_app_version.py</code> <pre><code>@classmethod\nasync def __call__(cls) -&gt; APIRet[str]:\n    return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.api.model.Announcement","title":"<code>Announcement</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/announcement.py</code> <pre><code>class Announcement(BaseModel):\n    service: Optional[str] = None\n    user_id: Optional[str] = None\n    hash: Optional[str] = None\n    \"\"\"sha256\"\"\"\n    content: Optional[str] = None\n    added: Optional[datetime] = None\n    # noinspection SpellCheckingInspection\n    \"\"\"isoformat UTC\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Announcement.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>isoformat UTC</p>"},{"location":"api/#ktoolbox.api.model.Announcement.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Announcement.hash","title":"<code>hash: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sha256</p>"},{"location":"api/#ktoolbox.api.model.Announcement.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Announcement.user_id","title":"<code>user_id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Attachment(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Attachment.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Attachment.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Creator","title":"<code>Creator</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/creator.py</code> <pre><code>class Creator(BaseModel):\n    # noinspection SpellCheckingInspection\n    favorited: int\n    # noinspection SpellCheckingInspection\n    \"\"\"The number of times this creator has been favorited\"\"\"\n    id: str\n    \"\"\"The ID of the creator\"\"\"\n    indexed: datetime\n    \"\"\"Timestamp when the creator was indexed, Unix time as integer\"\"\"\n    name: str\n    \"\"\"The name of the creator\"\"\"\n    service: str\n    \"\"\"The service for the creator\"\"\"\n    updated: datetime\n    \"\"\"Timestamp when the creator was last updated, Unix time as integer\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Creator.favorited","title":"<code>favorited: int</code>  <code>instance-attribute</code>","text":"<p>The number of times this creator has been favorited</p>"},{"location":"api/#ktoolbox.api.model.Creator.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>The ID of the creator</p>"},{"location":"api/#ktoolbox.api.model.Creator.indexed","title":"<code>indexed: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was indexed, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.Creator.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the creator</p>"},{"location":"api/#ktoolbox.api.model.Creator.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>The service for the creator</p>"},{"location":"api/#ktoolbox.api.model.Creator.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was last updated, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.File","title":"<code>File</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class File(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.File.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.File.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post","title":"<code>Post</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Post(BaseModel):\n    id: Optional[str] = None\n    user: Optional[str] = None\n    service: Optional[str] = None\n    title: Optional[str] = None\n    content: Optional[str] = None\n    substring: Optional[str] = None\n    embed: Optional[Dict[str, Any]] = None\n    shared_file: Optional[bool] = None\n    added: Optional[datetime] = None\n    published: Optional[datetime] = None\n    edited: Optional[datetime] = None\n    file: Optional[File] = None\n    attachments: Optional[List[Attachment]] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Post.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.attachments","title":"<code>attachments: Optional[List[Attachment]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.edited","title":"<code>edited: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.embed","title":"<code>embed: Optional[Dict[str, Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.file","title":"<code>file: Optional[File] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.id","title":"<code>id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.published","title":"<code>published: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.shared_file","title":"<code>shared_file: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.substring","title":"<code>substring: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.title","title":"<code>title: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Post.user","title":"<code>user: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.Revision","title":"<code>Revision</code>","text":"<p>               Bases: <code>Post</code></p> <p>Revision model that extends Post with revision_id field</p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Revision(Post):\n    \"\"\"Revision model that extends Post with revision_id field\"\"\"\n    revision_id: Optional[int] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.Revision.revision_id","title":"<code>revision_id: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement","title":"<code>announcement</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.__all__","title":"<code>__all__ = ['Announcement']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement","title":"<code>Announcement</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/announcement.py</code> <pre><code>class Announcement(BaseModel):\n    service: Optional[str] = None\n    user_id: Optional[str] = None\n    hash: Optional[str] = None\n    \"\"\"sha256\"\"\"\n    content: Optional[str] = None\n    added: Optional[datetime] = None\n    # noinspection SpellCheckingInspection\n    \"\"\"isoformat UTC\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>isoformat UTC</p>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement.hash","title":"<code>hash: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sha256</p>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement.user_id","title":"<code>user_id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.creator","title":"<code>creator</code>","text":""},{"location":"api/#ktoolbox.api.model.creator.__all__","title":"<code>__all__ = ['Creator']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.creator.Creator","title":"<code>Creator</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/creator.py</code> <pre><code>class Creator(BaseModel):\n    # noinspection SpellCheckingInspection\n    favorited: int\n    # noinspection SpellCheckingInspection\n    \"\"\"The number of times this creator has been favorited\"\"\"\n    id: str\n    \"\"\"The ID of the creator\"\"\"\n    indexed: datetime\n    \"\"\"Timestamp when the creator was indexed, Unix time as integer\"\"\"\n    name: str\n    \"\"\"The name of the creator\"\"\"\n    service: str\n    \"\"\"The service for the creator\"\"\"\n    updated: datetime\n    \"\"\"Timestamp when the creator was last updated, Unix time as integer\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.creator.Creator.favorited","title":"<code>favorited: int</code>  <code>instance-attribute</code>","text":"<p>The number of times this creator has been favorited</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>The ID of the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.indexed","title":"<code>indexed: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was indexed, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>The service for the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was last updated, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.post","title":"<code>post</code>","text":""},{"location":"api/#ktoolbox.api.model.post.__all__","title":"<code>__all__ = ['File', 'Attachment', 'Post', 'Revision']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Attachment(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.Attachment.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Attachment.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.File","title":"<code>File</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class File(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.File.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.File.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post","title":"<code>Post</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Post(BaseModel):\n    id: Optional[str] = None\n    user: Optional[str] = None\n    service: Optional[str] = None\n    title: Optional[str] = None\n    content: Optional[str] = None\n    substring: Optional[str] = None\n    embed: Optional[Dict[str, Any]] = None\n    shared_file: Optional[bool] = None\n    added: Optional[datetime] = None\n    published: Optional[datetime] = None\n    edited: Optional[datetime] = None\n    file: Optional[File] = None\n    attachments: Optional[List[Attachment]] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.Post.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.attachments","title":"<code>attachments: Optional[List[Attachment]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.edited","title":"<code>edited: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.embed","title":"<code>embed: Optional[Dict[str, Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.file","title":"<code>file: Optional[File] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.id","title":"<code>id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.published","title":"<code>published: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.shared_file","title":"<code>shared_file: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.substring","title":"<code>substring: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.title","title":"<code>title: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.user","title":"<code>user: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Revision","title":"<code>Revision</code>","text":"<p>               Bases: <code>Post</code></p> <p>Revision model that extends Post with revision_id field</p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Revision(Post):\n    \"\"\"Revision model that extends Post with revision_id field\"\"\"\n    revision_id: Optional[int] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.Revision.revision_id","title":"<code>revision_id: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts","title":"<code>posts</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_announcement","title":"<code>get_announcement = GetAnnouncement.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_creator_post","title":"<code>get_creator_post = GetCreatorPost.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_creators","title":"<code>get_creators = GetCreators.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_post","title":"<code>get_post = GetPost.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.get_post_revisions","title":"<code>get_post_revisions = GetPostRevisions.__call__</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement","title":"<code>GetAnnouncement</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/posts/get_announcement.py</code> <pre><code>class GetAnnouncement(BaseAPI):\n    path = \"/{service}/user/{creator_id}/announcements\"\n    method = \"get\"\n\n    class Response(RootModel[List[Announcement]]):\n        root: List[Announcement]\n\n    @classmethod\n    async def __call__(cls, service: str, creator_id: str) -&gt; APIRet[List[Announcement]]:\n        \"\"\"\n        Get creator announcements\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        \"\"\"\n        return await cls.request(path=cls.path.format(service=service, creator_id=creator_id))\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.path","title":"<code>path = '/{service}/user/{creator_id}/announcements'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[List[Announcement]]</code></p> Source code in <code>ktoolbox/api/posts/get_announcement.py</code> <pre><code>class Response(RootModel[List[Announcement]]):\n    root: List[Announcement]\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.Response.root","title":"<code>root: List[Announcement]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetAnnouncement.__call__","title":"<code>__call__(service, creator_id)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get creator announcements</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required Source code in <code>ktoolbox/api/posts/get_announcement.py</code> <pre><code>@classmethod\nasync def __call__(cls, service: str, creator_id: str) -&gt; APIRet[List[Announcement]]:\n    \"\"\"\n    Get creator announcements\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    \"\"\"\n    return await cls.request(path=cls.path.format(service=service, creator_id=creator_id))\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreatorPost","title":"<code>GetCreatorPost</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/posts/get_creator_post.py</code> <pre><code>class GetCreatorPost(BaseAPI):\n    path = \"/{service}/user/{creator_id}/posts\"\n    method = \"get\"\n\n    class Response(RootModel[List[Post]]):\n        root: List[Post]\n\n    @classmethod\n    async def __call__(cls, service: str, creator_id: str, *, q: str = None, o: int = None) -&gt; APIRet[List[Post]]:\n        \"\"\"\n        Get a list of creator posts\n\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        \"\"\"\n        return await cls.request(\n            path=cls.path.format(service=service, creator_id=creator_id),\n            params={\n                \"q\": q,\n                \"o\": o\n            }\n        )\n\n    @classmethod\n    def handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n        return APIRet(data=[]) if res.status_code == 404 else super().handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.path","title":"<code>path = '/{service}/user/{creator_id}/posts'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[List[Post]]</code></p> Source code in <code>ktoolbox/api/posts/get_creator_post.py</code> <pre><code>class Response(RootModel[List[Post]]):\n    root: List[Post]\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.Response.root","title":"<code>root: List[Post]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.__call__","title":"<code>__call__(service, creator_id, *, q=None, o=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get a list of creator posts</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> Source code in <code>ktoolbox/api/posts/get_creator_post.py</code> <pre><code>@classmethod\nasync def __call__(cls, service: str, creator_id: str, *, q: str = None, o: int = None) -&gt; APIRet[List[Post]]:\n    \"\"\"\n    Get a list of creator posts\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    \"\"\"\n    return await cls.request(\n        path=cls.path.format(service=service, creator_id=creator_id),\n        params={\n            \"q\": q,\n            \"o\": o\n        }\n    )\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreatorPost.handle_res","title":"<code>handle_res(res)</code>  <code>classmethod</code>","text":"Source code in <code>ktoolbox/api/posts/get_creator_post.py</code> <pre><code>@classmethod\ndef handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n    return APIRet(data=[]) if res.status_code == 404 else super().handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreators","title":"<code>GetCreators</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>List All Creators</p> Source code in <code>ktoolbox/api/posts/get_creators.py</code> <pre><code>class GetCreators(BaseAPI):\n    \"\"\"List All Creators\"\"\"\n    path = \"/creators\"\n    method = \"get\"\n\n    class Response(RootModel[List[Creator]]):\n        root: List[Creator]\n\n    @classmethod\n    async def __call__(cls) -&gt; APIRet[List[Creator]]:\n        \"\"\"\n        List of all creators\n\n        List all creators with details. I blame DDG for .txt.\n        \"\"\"\n        return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreators.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreators.path","title":"<code>path = '/creators'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreators.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel[List[Creator]]</code></p> Source code in <code>ktoolbox/api/posts/get_creators.py</code> <pre><code>class Response(RootModel[List[Creator]]):\n    root: List[Creator]\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetCreators.Response.root","title":"<code>root: List[Creator]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetCreators.__call__","title":"<code>__call__()</code>  <code>async</code> <code>classmethod</code>","text":"<p>List of all creators</p> <p>List all creators with details. I blame DDG for .txt.</p> Source code in <code>ktoolbox/api/posts/get_creators.py</code> <pre><code>@classmethod\nasync def __call__(cls) -&gt; APIRet[List[Creator]]:\n    \"\"\"\n    List of all creators\n\n    List all creators with details. I blame DDG for .txt.\n    \"\"\"\n    return await cls.request()\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPost","title":"<code>GetPost</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/posts/get_post.py</code> <pre><code>class GetPost(BaseAPI):\n    path = \"/{service}/user/{creator_id}/post/{post_id}\"\n    method = \"get\"\n\n    class Response(BaseModel):\n        post: Post\n        props: Optional[PostProps] = None\n\n    @classmethod\n    async def __call__(cls, service: str, creator_id: str, post_id: str, revision_id: Optional[str] = None) -&gt; APIRet[Response]:\n        \"\"\"\n        Get a specific post or revision\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param revision_id: The revision ID (optional, for revision posts)\n        \"\"\"\n        if revision_id:\n            path = f\"/{service}/user/{creator_id}/post/{post_id}/revision/{revision_id}\"\n        else:\n            path = cls.path.format(\n                service=service,\n                creator_id=creator_id,\n                post_id=post_id\n            )\n\n        return await cls.request(path=path)\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPost.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPost.path","title":"<code>path = '/{service}/user/{creator_id}/post/{post_id}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPost.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/posts/get_post.py</code> <pre><code>class Response(BaseModel):\n    post: Post\n    props: Optional[PostProps] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPost.Response.post","title":"<code>post: Post</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPost.Response.props","title":"<code>props: Optional[PostProps] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPost.__call__","title":"<code>__call__(service, creator_id, post_id, revision_id=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get a specific post or revision</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required <code>revision_id</code> <code>Optional[str]</code> <p>The revision ID (optional, for revision posts)</p> <code>None</code> Source code in <code>ktoolbox/api/posts/get_post.py</code> <pre><code>@classmethod\nasync def __call__(cls, service: str, creator_id: str, post_id: str, revision_id: Optional[str] = None) -&gt; APIRet[Response]:\n    \"\"\"\n    Get a specific post or revision\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param revision_id: The revision ID (optional, for revision posts)\n    \"\"\"\n    if revision_id:\n        path = f\"/{service}/user/{creator_id}/post/{post_id}/revision/{revision_id}\"\n    else:\n        path = cls.path.format(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n\n    return await cls.request(path=path)\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPostRevisions","title":"<code>GetPostRevisions</code>","text":"<p>               Bases: <code>BaseAPI</code></p> Source code in <code>ktoolbox/api/posts/get_post_revisions.py</code> <pre><code>class GetPostRevisions(BaseAPI):\n    path = \"/{service}/user/{creator_id}/post/{post_id}/revisions\"\n    method = \"get\"\n\n    class Response(RootModel):\n        root: List[Revision]\n\n    @classmethod\n    async def __call__(cls, service: str, creator_id: str, post_id: str) -&gt; APIRet[Response]:\n        \"\"\"\n        Get all revisions of a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        \"\"\"\n        path = cls.path.format(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n\n        return await cls.request(path=path)\n\n    @classmethod\n    def handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n        return APIRet(data=[]) if res.status_code == 404 else super().handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPostRevisions.method","title":"<code>method = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPostRevisions.path","title":"<code>path = '/{service}/user/{creator_id}/post/{post_id}/revisions'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPostRevisions.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>RootModel</code></p> Source code in <code>ktoolbox/api/posts/get_post_revisions.py</code> <pre><code>class Response(RootModel):\n    root: List[Revision]\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPostRevisions.Response.root","title":"<code>root: List[Revision]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts.GetPostRevisions.__call__","title":"<code>__call__(service, creator_id, post_id)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get all revisions of a specific post</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required Source code in <code>ktoolbox/api/posts/get_post_revisions.py</code> <pre><code>@classmethod\nasync def __call__(cls, service: str, creator_id: str, post_id: str) -&gt; APIRet[Response]:\n    \"\"\"\n    Get all revisions of a specific post\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    \"\"\"\n    path = cls.path.format(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n\n    return await cls.request(path=path)\n</code></pre>"},{"location":"api/#ktoolbox.api.posts.GetPostRevisions.handle_res","title":"<code>handle_res(res)</code>  <code>classmethod</code>","text":"Source code in <code>ktoolbox/api/posts/get_post_revisions.py</code> <pre><code>@classmethod\ndef handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n    return APIRet(data=[]) if res.status_code == 404 else super().handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.api.utils.SEARCH_STEP","title":"<code>SEARCH_STEP = 50</code>  <code>module-attribute</code>","text":"<p>Searching APIs result steps</p>"},{"location":"api/#ktoolbox.api.utils.__all__","title":"<code>__all__ = ['SEARCH_STEP', 'get_creator_icon', 'get_creator_banner']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.utils.get_creator_banner","title":"<code>get_creator_banner(creator_id, service)</code>","text":"<p>Get the creator banner for a given creator ID and service.</p> <p>Returns:</p> Type Description <code>str</code> <p>The banner URL.</p> Source code in <code>ktoolbox/api/utils.py</code> <pre><code>def get_creator_banner(creator_id: str, service: str) -&gt; str:\n    \"\"\"\n    Get the creator banner for a given creator ID and service.\n\n    :return: The banner URL.\n    \"\"\"\n    url_parts = [config.api.scheme, config.api.statics_netloc, f\"/banners/{service}/{creator_id}\", '', '', '']\n    return str(urlunparse(url_parts))\n</code></pre>"},{"location":"api/#ktoolbox.api.utils.get_creator_icon","title":"<code>get_creator_icon(creator_id, service)</code>","text":"<p>Get the creator icon for a given creator ID and service.</p> <p>Returns:</p> Type Description <code>str</code> <p>The icon URL.</p> Source code in <code>ktoolbox/api/utils.py</code> <pre><code>def get_creator_icon(creator_id: str, service: str) -&gt; str:\n    \"\"\"\n    Get the creator icon for a given creator ID and service.\n\n    :return: The icon URL.\n    \"\"\"\n    url_parts = [config.api.scheme, config.api.statics_netloc, f\"/icons/{service}/{creator_id}\", '', '', '']\n    return str(urlunparse(url_parts))\n</code></pre>"},{"location":"api/#ktoolbox.cli","title":"<code>cli</code>","text":""},{"location":"api/#ktoolbox.cli.__all__","title":"<code>__all__ = ['KToolBoxCli']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.cli.KToolBoxCli","title":"<code>KToolBoxCli</code>","text":"Source code in <code>ktoolbox/cli.py</code> <pre><code>class KToolBoxCli:\n    _update_checked = False  # Class variable to track if update check was performed\n\n    @classmethod\n    async def _ensure_update_check(cls):\n        \"\"\"Ensure update check is performed once per session\"\"\"\n        if not cls._update_checked:\n            try:\n                await check_for_updates()\n            except Exception:\n                # Silently fail update check to not interfere with main functionality\n                pass\n            finally:\n                cls._update_checked = True\n\n    @staticmethod\n    async def version():\n        \"\"\"Show KToolBox version\"\"\"\n        # Always check for updates when version is explicitly requested\n        await check_for_updates()\n        return __version__\n\n    @staticmethod\n    async def site_version():\n        # noinspection SpellCheckingInspection\n        \"\"\"Show current Kemono site app commit hash\"\"\"\n        logger.info(repr(config))\n        ret = await get_app_version()\n        return ret.data if ret else ret.message\n\n    @staticmethod\n    async def config_editor():\n        \"\"\"Launch graphical KToolBox configuration editor\"\"\"\n        try:\n            from ktoolbox.editor import run_config_editor\n            run_config_editor()\n        except ModuleNotFoundError:\n            logger.error(\n                \"You need to install extra dependencies to use the editor, \"\n                \"run `pip install ktoolbox[urwid]` \"\n                \"or `pipx install ktoolbox[urwid] --force` if you are using pipx\"\n            )\n\n    @staticmethod\n    async def example_env():\n        \"\"\"Generate an example configuration ``.env`` file.\"\"\"\n        print(\n            render(\n                OutputFormat.DOTENV,\n                class_path=(\"ktoolbox.configuration.Configuration\",)\n            )\n        )\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator(\n            name: str = None,\n            id: str = None,\n            service: str = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_action(id=id, name=name, service=service)\n        if ret:\n            result_list = list(ret.data)\n            if dump:\n                await dump_search(result_list, dump)\n            return result_list or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator_post(\n            id: str = None,\n            name: str = None,\n            service: str = None,\n            q: str = None,\n            o: int = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search posts from creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n        if ret:\n            if dump:\n                await dump_search(ret.data, dump)\n            return ret.data or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    @staticmethod\n    async def get_post(service: str, creator_id: str, post_id: str, revision_id: str = None, *, dump: Path = None):\n        \"\"\"\n        Get a specific post or revision\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param revision_id: The revision ID (optional, for revision posts)\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        logger.info(repr(config))\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id,\n            revision_id=revision_id\n        )\n        if ret:\n            if dump:\n                async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                    await f.write(\n                        ret.data.post.model_dump_json(indent=config.json_dump_indent)\n                    )\n            return ret.data.post\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def download_post(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def download_post(\n            service: str,\n            creator_id: str,\n            post_id: str,\n            revision_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    async def download_post(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            post_id: str = None,\n            revision_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        \"\"\"\n        Download a specific post or revision\n\n        :param url: The post URL\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param revision_id: The revision ID (optional, for revision posts)\n        :param path: Download path, default is current directory\n        :param dump_post_data: Whether to dump post data (post.json) in post directory\n        \"\"\"\n        # Check for updates on first command run\n        await KToolBoxCli._ensure_update_check()\n\n        logger.info(repr(config))\n        # Get service, creator_id, post_id, revision_id\n        if url:\n            service, creator_id, post_id, revision_id = parse_webpage_url(url)\n        if not all([service, creator_id, post_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\", \"post_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id,\n            revision_id=revision_id\n        )\n        if ret:\n            post_path = path / generate_post_path_name(ret.data.post)\n\n            # For revision posts, create a revision subfolder\n            if revision_id:\n                post_path = post_path / \"revision\" / revision_id\n\n            # Download the main post\n            try:\n                job_list = await create_job_from_post(\n                    post=ret.data.post,\n                    post_path=post_path,\n                    dump_post_data=dump_post_data\n                )\n            except FetchInterruptError:\n                return None\n\n            # If include_revisions is enabled and we have revisions data\n            if (config.job.include_revisions and\n                    ret.data.props and\n                    ret.data.props.revisions and\n                    not revision_id):  # Don't process revisions if we're already downloading a specific revision\n\n                for revision_order, revision_data in ret.data.props.revisions:\n                    if revision_data.revision_id:  # Only process actual revisions, not the main post\n                        revision_path = post_path / config.job.post_structure.revisions / generate_post_path_name(\n                            revision_data)\n                        try:\n                            revision_jobs = await create_job_from_post(\n                                post=revision_data,\n                                post_path=revision_path,\n                                dump_post_data=dump_post_data\n                            )\n                        except FetchInterruptError:\n                            return None\n                        job_list.extend(revision_jobs)\n\n            job_runner = JobRunner(job_list=job_list)\n            await job_runner.start()\n            return None\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = False,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None,\n            offset: int = 0,\n            length: int = None,\n            keywords: Tuple[str] = None,\n            keywords_exclude: Tuple[str] = None\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            service: str,\n            creator_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = False,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None,\n            offset: int = 0,\n            length: int = None,\n            keywords: Tuple[str] = None,\n            keywords_exclude: Tuple[str] = None\n    ):\n        ...\n\n    @staticmethod\n    async def sync_creator(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            save_creator_indices: bool = False,\n            mix_posts: bool = None,\n            start_time: str = None,\n            end_time: str = None,\n            offset: int = 0,\n            length: int = None,\n            keywords: Tuple[str] = None,\n            keywords_exclude: Tuple[str] = None\n    ):\n        \"\"\"\n        Sync posts from a creator\n\n        You can update the directory anytime after download finished, \\\n        such as to update after creator published new posts.\n\n        * ``start_time`` &amp; ``end_time`` example: ``2023-12-7``, ``2023-12-07``\n\n        :param url: The post URL\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param path: Download path, default is current directory\n        :param save_creator_indices: Record ``CreatorIndices`` data\n        :param mix_posts: Save all_pages files from different posts at same path, \\\n            ``save_creator_indices`` will be ignored if enabled\n        :param start_time: Start time of the published time range for posts downloading. \\\n            Set to ``0`` if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param end_time: End time of the published time range for posts downloading. \\\n            Set to latest time (infinity) if ``None`` was given. \\\n            Time format: ``%Y-%m-%d``\n        :param offset: Result offset (or start offset)\n        :param length: The number of posts to fetch, defaults to fetching all posts after ``offset``.\n        :param keywords: Comma-separated keywords to filter posts by title (case-insensitive)\n        :param keywords_exclude: Comma-separated keywords to exclude posts by title (case-insensitive)\n        \"\"\"\n        # Check for updates on first command run\n        await KToolBoxCli._ensure_update_check()\n        logger.info(repr(config))\n        # Get service, creator_id\n        if url:\n            service, creator_id, _, _ = parse_webpage_url(url)\n        if not all([service, creator_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n\n        # Get creator name\n        creator_name = creator_id\n        creator_ret = await search_creator_action(id=creator_id, service=service)\n        if creator_ret:\n            creator = next(creator_ret.data, None)\n            if creator:\n                creator_name = creator.name\n                logger.info(\n                    generate_msg(\n                        \"Got creator information\",\n                        name=creator.name,\n                        id=creator.id\n                    )\n                )\n        else:\n            logger.error(\n                generate_msg(\n                    f\"Failed to fetch the name of creator &lt;{creator_id}&gt;\",\n                    detail=creator_ret.message\n                )\n            )\n            return creator_ret.message\n\n        creator_path = path / sanitize_filename(creator_name)\n        creator_path.mkdir(exist_ok=True)\n\n        keywords = [keywords] if isinstance(keywords, str) else keywords\n        keyword_set = set(keywords) if keywords else config.job.keywords\n        if keywords:\n            logger.info(f\"Filtering posts by keywords: {', '.join(keyword_set)}\")\n\n        keywords_exclude = [keywords_exclude] if isinstance(keywords_exclude, str) else keywords_exclude\n        keyword_exclude_set = set(keywords_exclude) if keywords_exclude else config.job.keywords_exclude\n        if keywords_exclude:\n            logger.info(f\"Excluding posts by keywords: {', '.join(keyword_exclude_set)}\")\n\n        ret = await create_job_from_creator(\n            service=service,\n            creator_id=creator_id,\n            path=creator_path,\n            all_pages=not length,\n            offset=offset,\n            length=length,\n            save_creator_indices=save_creator_indices,\n            mix_posts=mix_posts,\n            start_time=datetime.strptime(start_time, \"%Y-%m-%d\") if start_time else None,\n            end_time=datetime.strptime(end_time, \"%Y-%m-%d\") if end_time else None,\n            keywords=keyword_set,\n            keywords_exclude=keyword_exclude_set\n        )\n        if ret:\n            job_runner = JobRunner(job_list=ret.data)\n            await job_runner.start()\n            return None\n        else:\n            return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.config_editor","title":"<code>config_editor()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Launch graphical KToolBox configuration editor</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def config_editor():\n    \"\"\"Launch graphical KToolBox configuration editor\"\"\"\n    try:\n        from ktoolbox.editor import run_config_editor\n        run_config_editor()\n    except ModuleNotFoundError:\n        logger.error(\n            \"You need to install extra dependencies to use the editor, \"\n            \"run `pip install ktoolbox[urwid]` \"\n            \"or `pipx install ktoolbox[urwid] --force` if you are using pipx\"\n        )\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.download_post","title":"<code>download_post(url=None, service=None, creator_id=None, post_id=None, revision_id=None, path=Path('.'), *, dump_post_data=True)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Download a specific post or revision</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service name</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The creator's ID</p> <code>None</code> <code>post_id</code> <code>str</code> <p>The post ID</p> <code>None</code> <code>revision_id</code> <code>str</code> <p>The revision ID (optional, for revision posts)</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>dump_post_data</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def download_post(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        post_id: str = None,\n        revision_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        dump_post_data=True\n):\n    \"\"\"\n    Download a specific post or revision\n\n    :param url: The post URL\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param revision_id: The revision ID (optional, for revision posts)\n    :param path: Download path, default is current directory\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    # Check for updates on first command run\n    await KToolBoxCli._ensure_update_check()\n\n    logger.info(repr(config))\n    # Get service, creator_id, post_id, revision_id\n    if url:\n        service, creator_id, post_id, revision_id = parse_webpage_url(url)\n    if not all([service, creator_id, post_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\", \"post_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id,\n        revision_id=revision_id\n    )\n    if ret:\n        post_path = path / generate_post_path_name(ret.data.post)\n\n        # For revision posts, create a revision subfolder\n        if revision_id:\n            post_path = post_path / \"revision\" / revision_id\n\n        # Download the main post\n        try:\n            job_list = await create_job_from_post(\n                post=ret.data.post,\n                post_path=post_path,\n                dump_post_data=dump_post_data\n            )\n        except FetchInterruptError:\n            return None\n\n        # If include_revisions is enabled and we have revisions data\n        if (config.job.include_revisions and\n                ret.data.props and\n                ret.data.props.revisions and\n                not revision_id):  # Don't process revisions if we're already downloading a specific revision\n\n            for revision_order, revision_data in ret.data.props.revisions:\n                if revision_data.revision_id:  # Only process actual revisions, not the main post\n                    revision_path = post_path / config.job.post_structure.revisions / generate_post_path_name(\n                        revision_data)\n                    try:\n                        revision_jobs = await create_job_from_post(\n                            post=revision_data,\n                            post_path=revision_path,\n                            dump_post_data=dump_post_data\n                        )\n                    except FetchInterruptError:\n                        return None\n                    job_list.extend(revision_jobs)\n\n        job_runner = JobRunner(job_list=job_list)\n        await job_runner.start()\n        return None\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.example_env","title":"<code>example_env()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Generate an example configuration <code>.env</code> file.</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def example_env():\n    \"\"\"Generate an example configuration ``.env`` file.\"\"\"\n    print(\n        render(\n            OutputFormat.DOTENV,\n            class_path=(\"ktoolbox.configuration.Configuration\",)\n        )\n    )\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.get_post","title":"<code>get_post(service, creator_id, post_id, revision_id=None, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Get a specific post or revision</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required <code>revision_id</code> <code>str</code> <p>The revision ID (optional, for revision posts)</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def get_post(service: str, creator_id: str, post_id: str, revision_id: str = None, *, dump: Path = None):\n    \"\"\"\n    Get a specific post or revision\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param revision_id: The revision ID (optional, for revision posts)\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id,\n        revision_id=revision_id\n    )\n    if ret:\n        if dump:\n            async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                await f.write(\n                    ret.data.post.model_dump_json(indent=config.json_dump_indent)\n                )\n        return ret.data.post\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.search_creator","title":"<code>search_creator(name=None, id=None, service=None, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator(\n        name: str = None,\n        id: str = None,\n        service: str = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await search_creator_action(id=id, name=name, service=service)\n    if ret:\n        result_list = list(ret.data)\n        if dump:\n            await dump_search(result_list, dump)\n        return result_list or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search posts from creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: int = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search posts from creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    logger.info(repr(config))\n    ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n    if ret:\n        if dump:\n            await dump_search(ret.data, dump)\n        return ret.data or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.site_version","title":"<code>site_version()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show current Kemono site app commit hash</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def site_version():\n    # noinspection SpellCheckingInspection\n    \"\"\"Show current Kemono site app commit hash\"\"\"\n    logger.info(repr(config))\n    ret = await get_app_version()\n    return ret.data if ret else ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.sync_creator","title":"<code>sync_creator(url=None, service=None, creator_id=None, path=Path('.'), *, save_creator_indices=False, mix_posts=None, start_time=None, end_time=None, offset=0, length=None, keywords=None, keywords_exclude=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Sync posts from a creator</p> <p>You can update the directory anytime after download finished,         such as to update after creator published new posts.</p> <ul> <li><code>start_time</code> &amp; <code>end_time</code> example: <code>2023-12-7</code>, <code>2023-12-07</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service where the post is located</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all_pages files from different posts at same path,             <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>str</code> <p>Start time of the published time range for posts downloading.             Set to <code>0</code> if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>end_time</code> <code>str</code> <p>End time of the published time range for posts downloading.             Set to latest time (infinity) if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>int</code> <p>The number of posts to fetch, defaults to fetching all posts after <code>offset</code>.</p> <code>None</code> <code>keywords</code> <code>Tuple[str]</code> <p>Comma-separated keywords to filter posts by title (case-insensitive)</p> <code>None</code> <code>keywords_exclude</code> <code>Tuple[str]</code> <p>Comma-separated keywords to exclude posts by title (case-insensitive)</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def sync_creator(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        save_creator_indices: bool = False,\n        mix_posts: bool = None,\n        start_time: str = None,\n        end_time: str = None,\n        offset: int = 0,\n        length: int = None,\n        keywords: Tuple[str] = None,\n        keywords_exclude: Tuple[str] = None\n):\n    \"\"\"\n    Sync posts from a creator\n\n    You can update the directory anytime after download finished, \\\n    such as to update after creator published new posts.\n\n    * ``start_time`` &amp; ``end_time`` example: ``2023-12-7``, ``2023-12-07``\n\n    :param url: The post URL\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: Download path, default is current directory\n    :param save_creator_indices: Record ``CreatorIndices`` data\n    :param mix_posts: Save all_pages files from different posts at same path, \\\n        ``save_creator_indices`` will be ignored if enabled\n    :param start_time: Start time of the published time range for posts downloading. \\\n        Set to ``0`` if ``None`` was given. \\\n        Time format: ``%Y-%m-%d``\n    :param end_time: End time of the published time range for posts downloading. \\\n        Set to latest time (infinity) if ``None`` was given. \\\n        Time format: ``%Y-%m-%d``\n    :param offset: Result offset (or start offset)\n    :param length: The number of posts to fetch, defaults to fetching all posts after ``offset``.\n    :param keywords: Comma-separated keywords to filter posts by title (case-insensitive)\n    :param keywords_exclude: Comma-separated keywords to exclude posts by title (case-insensitive)\n    \"\"\"\n    # Check for updates on first command run\n    await KToolBoxCli._ensure_update_check()\n    logger.info(repr(config))\n    # Get service, creator_id\n    if url:\n        service, creator_id, _, _ = parse_webpage_url(url)\n    if not all([service, creator_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n\n    # Get creator name\n    creator_name = creator_id\n    creator_ret = await search_creator_action(id=creator_id, service=service)\n    if creator_ret:\n        creator = next(creator_ret.data, None)\n        if creator:\n            creator_name = creator.name\n            logger.info(\n                generate_msg(\n                    \"Got creator information\",\n                    name=creator.name,\n                    id=creator.id\n                )\n            )\n    else:\n        logger.error(\n            generate_msg(\n                f\"Failed to fetch the name of creator &lt;{creator_id}&gt;\",\n                detail=creator_ret.message\n            )\n        )\n        return creator_ret.message\n\n    creator_path = path / sanitize_filename(creator_name)\n    creator_path.mkdir(exist_ok=True)\n\n    keywords = [keywords] if isinstance(keywords, str) else keywords\n    keyword_set = set(keywords) if keywords else config.job.keywords\n    if keywords:\n        logger.info(f\"Filtering posts by keywords: {', '.join(keyword_set)}\")\n\n    keywords_exclude = [keywords_exclude] if isinstance(keywords_exclude, str) else keywords_exclude\n    keyword_exclude_set = set(keywords_exclude) if keywords_exclude else config.job.keywords_exclude\n    if keywords_exclude:\n        logger.info(f\"Excluding posts by keywords: {', '.join(keyword_exclude_set)}\")\n\n    ret = await create_job_from_creator(\n        service=service,\n        creator_id=creator_id,\n        path=creator_path,\n        all_pages=not length,\n        offset=offset,\n        length=length,\n        save_creator_indices=save_creator_indices,\n        mix_posts=mix_posts,\n        start_time=datetime.strptime(start_time, \"%Y-%m-%d\") if start_time else None,\n        end_time=datetime.strptime(end_time, \"%Y-%m-%d\") if end_time else None,\n        keywords=keyword_set,\n        keywords_exclude=keyword_exclude_set\n    )\n    if ret:\n        job_runner = JobRunner(job_list=ret.data)\n        await job_runner.start()\n        return None\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.version","title":"<code>version()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show KToolBox version</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def version():\n    \"\"\"Show KToolBox version\"\"\"\n    # Always check for updates when version is explicitly requested\n    await check_for_updates()\n    return __version__\n</code></pre>"},{"location":"api/#ktoolbox.configuration","title":"<code>configuration</code>","text":""},{"location":"api/#ktoolbox.configuration.__all__","title":"<code>__all__ = ['config', 'APIConfiguration', 'DownloaderConfiguration', 'PostStructureConfiguration', 'JobConfiguration', 'LoggerConfiguration', 'Configuration']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.config","title":"<code>config = Configuration()</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration","title":"<code>APIConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Kemono API Configuration</p> <p>Attributes:</p> Name Type Description Default <code>scheme</code> <code>Literal['http', 'https']</code> <p>Kemono API URL scheme</p> <code>                       'https'               </code> <code>netloc</code> <code>str</code> <p>Kemono API URL netloc</p> <code>                       'kemono.cr'               </code> <code>statics_netloc</code> <code>str</code> <p>URL netloc of Kemono server for static files (e.g. images)</p> <code>                       'img.kemono.cr'               </code> <code>files_netloc</code> <code>str</code> <p>URL netloc of Kemono server for post files</p> <code>                       'kemono.cr'               </code> <code>path</code> <code>str</code> <p>Kemono API URL root path</p> <code>                       '/api/v1'               </code> <code>timeout</code> <code>float</code> <p>API request timeout</p> <code>                       5.0               </code> <code>retry_times</code> <code>int</code> <p>API request retry times (when request failed)</p> <code>                       3               </code> <code>retry_interval</code> <code>float</code> <p>Seconds of API request retry interval</p> <code>                       2.0               </code> <code>session_key</code> <code>str</code> <p>Session key that can be found in cookies after a successful login</p> <code>                       ''               </code> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class APIConfiguration(BaseModel):\n    \"\"\"\n    Kemono API Configuration\n\n    :ivar scheme: Kemono API URL scheme\n    :ivar netloc: Kemono API URL netloc\n    :ivar statics_netloc: URL netloc of Kemono server for static files (e.g. images)\n    :ivar files_netloc: URL netloc of Kemono server for post files\n    :ivar path: Kemono API URL root path\n    :ivar timeout: API request timeout\n    :ivar retry_times: API request retry times (when request failed)\n    :ivar retry_interval: Seconds of API request retry interval\n    :ivar session_key: Session key that can be found in cookies after a successful login\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    netloc: str = \"kemono.cr\"\n    statics_netloc: str = \"img.kemono.cr\"\n    files_netloc: str = \"kemono.cr\"\n    path: str = \"/api/v1\"\n    timeout: float = 5.0\n    retry_times: int = 3\n    retry_interval: float = 2.0\n    session_key: str = \"\"\n</code></pre>"},{"location":"api/#ktoolbox.configuration.APIConfiguration.files_netloc","title":"<code>files_netloc: str = 'kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.netloc","title":"<code>netloc: str = 'kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.path","title":"<code>path: str = '/api/v1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.retry_interval","title":"<code>retry_interval: float = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.retry_times","title":"<code>retry_times: int = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.session_key","title":"<code>session_key: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.statics_netloc","title":"<code>statics_netloc: str = 'img.kemono.cr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.timeout","title":"<code>timeout: float = 5.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>KToolBox Configuration</p> <p>Attributes:</p> Name Type Description Default <code>api</code> <code>APIConfiguration</code> <p>Kemono API Configuration</p> <code>                       APIConfiguration()               </code> <code>downloader</code> <code>DownloaderConfiguration</code> <p>File Downloader Configuration</p> <code>                       DownloaderConfiguration()               </code> <code>job</code> <code>JobConfiguration</code> <p>Download jobs Configuration</p> <code>                       JobConfiguration()               </code> <code>logger</code> <code>LoggerConfiguration</code> <p>Logger configuration</p> <code>                       LoggerConfiguration()               </code> <code>ssl_verify</code> <code>bool</code> <p>Enable SSL certificate verification for Kemono API server and download server</p> <code>                       True               </code> <code>json_dump_indent</code> <code>int</code> <p>Indent of JSON file dump</p> <code>                       4               </code> <code>use_uvloop</code> <code>bool</code> <p>Use uvloop/winloop for asyncio performance optimization     Uses winloop on Windows and uvloop on Unix-like systems for better concurrent performance.     Install winloop on Windows with <code>pip install ktoolbox[winloop]</code>     or uvloop on Unix with <code>pip install ktoolbox[uvloop]</code>.</p> <code>                       True               </code> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class Configuration(BaseSettings):\n    # noinspection SpellCheckingInspection,GrazieInspection\n    \"\"\"\n    KToolBox Configuration\n\n    :ivar api: Kemono API Configuration\n    :ivar downloader: File Downloader Configuration\n    :ivar job: Download jobs Configuration\n    :ivar logger: Logger configuration\n    :ivar ssl_verify: Enable SSL certificate verification for Kemono API server and download server\n    :ivar json_dump_indent: Indent of JSON file dump\n    :ivar use_uvloop: Use uvloop/winloop for asyncio performance optimization \\\n    Uses winloop on Windows and uvloop on Unix-like systems for better concurrent performance. \\\n    Install winloop on Windows with `pip install ktoolbox[winloop]` \\\n    or uvloop on Unix with `pip install ktoolbox[uvloop]`.\n    \"\"\"\n    api: APIConfiguration = APIConfiguration()\n    downloader: DownloaderConfiguration = DownloaderConfiguration()\n    job: JobConfiguration = JobConfiguration()\n    logger: LoggerConfiguration = LoggerConfiguration()\n\n    ssl_verify: bool = True\n    json_dump_indent: int = 4\n    use_uvloop: bool = True\n\n    # noinspection SpellCheckingInspection\n    model_config: ClassVar[SettingsConfigDict] = SettingsConfigDict(\n        env_prefix='ktoolbox_',\n        env_nested_delimiter='__',\n        env_file=['.env', 'prod.env'],\n        env_file_encoding='utf-8',\n        extra='ignore'\n    )\n</code></pre>"},{"location":"api/#ktoolbox.configuration.Configuration.api","title":"<code>api: APIConfiguration = APIConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.downloader","title":"<code>downloader: DownloaderConfiguration = DownloaderConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.job","title":"<code>job: JobConfiguration = JobConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.json_dump_indent","title":"<code>json_dump_indent: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.logger","title":"<code>logger: LoggerConfiguration = LoggerConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.model_config","title":"<code>model_config: SettingsConfigDict = SettingsConfigDict(env_prefix='ktoolbox_', env_nested_delimiter='__', env_file=['.env', 'prod.env'], env_file_encoding='utf-8', extra='ignore')</code>  <code>class-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.ssl_verify","title":"<code>ssl_verify: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.use_uvloop","title":"<code>use_uvloop: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration","title":"<code>DownloaderConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>File Downloader Configuration</p> <p>Attributes:</p> Name Type Description Default <code>scheme</code> <code>Literal['http', 'https']</code> <p>Downloader URL scheme</p> <code>                       'https'               </code> <code>timeout</code> <code>float</code> <p>Downloader request timeout</p> <code>                       30.0               </code> <code>encoding</code> <code>str</code> <p>Charset for filename parsing and post <code>content</code>, <code>external_links</code> saving</p> <code>                       'utf-8'               </code> <code>buffer_size</code> <code>int</code> <p>Number of bytes of file I/O buffer for each downloading file</p> <code>                       20480               </code> <code>chunk_size</code> <code>int</code> <p>Number of bytes of chunk of downloader stream</p> <code>                       1024               </code> <code>temp_suffix</code> <code>str</code> <p>Temp filename suffix of downloading files</p> <code>                       'tmp'               </code> <code>retry_times</code> <code>int</code> <p>Downloader retry times (when download failed)</p> <code>                       10               </code> <code>retry_stop_never</code> <code>bool</code> <p>Never stop downloader from retrying (when download failed)     (<code>retry_times</code> will be ignored when enabled)</p> <code>                       False               </code> <code>retry_interval</code> <code>float</code> <p>Seconds of downloader retry interval</p> <code>                       3.0               </code> <code>tps_limit</code> <code>float</code> <p>Maximum connections established per second</p> <code>                       5.0               </code> <code>use_bucket</code> <code>bool</code> <p>Enable local storage bucket mode</p> <code>                       False               </code> <code>bucket_path</code> <code>Path</code> <p>Path of local storage bucket</p> <code>                       Path('./.ktoolbox/bucket_storage')               </code> <code>reverse_proxy</code> <code>str</code> <p>Reverse proxy format for download URL.     Customize the filename format by inserting an empty <code>{}</code> to represent the original URL.     For example: <code>https://example.com/{}</code> will be <code>https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg</code>;      <code>https://example.com/?url={}</code> will be <code>https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg</code></p> <code>                       '{}'               </code> <code>keep_metadata</code> <code>bool</code> <p>Keep the file metadata when downloading files (e.g. last modified time, etc.)</p> <code>                       True               </code> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class DownloaderConfiguration(BaseModel):\n    \"\"\"\n    File Downloader Configuration\n\n    :ivar scheme: Downloader URL scheme\n    :ivar timeout: Downloader request timeout\n    :ivar encoding: Charset for filename parsing and post ``content``, ``external_links`` saving\n    :ivar buffer_size: Number of bytes of file I/O buffer for each downloading file\n    :ivar chunk_size: Number of bytes of chunk of downloader stream\n    :ivar temp_suffix: Temp filename suffix of downloading files\n    :ivar retry_times: Downloader retry times (when download failed)\n    :ivar retry_stop_never: Never stop downloader from retrying (when download failed) \\\n    (``retry_times`` will be ignored when enabled)\n    :ivar retry_interval: Seconds of downloader retry interval\n    :ivar tps_limit: Maximum connections established per second\n    :ivar use_bucket: Enable local storage bucket mode\n    :ivar bucket_path: Path of local storage bucket\n    :ivar reverse_proxy: Reverse proxy format for download URL. \\\n    Customize the filename format by inserting an empty ``{}`` to represent the original URL. \\\n    For example: ``https://example.com/{}`` will be ``https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg``;  \\\n    ``https://example.com/?url={}`` will be ``https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg``\n    :ivar keep_metadata: Keep the file metadata when downloading files (e.g. last modified time, etc.)\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    timeout: float = 30.0\n    encoding: str = \"utf-8\"\n    buffer_size: int = 20480\n    chunk_size: int = 1024\n    temp_suffix: str = \"tmp\"\n    retry_times: int = 10\n    retry_stop_never: bool = False\n    retry_interval: float = 3.0\n    tps_limit: float = 5.0\n    use_bucket: bool = False\n    bucket_path: Path = Path(\"./.ktoolbox/bucket_storage\")\n    reverse_proxy: str = \"{}\"\n    keep_metadata: bool = True\n\n    @model_validator(mode=\"after\")\n    def check_bucket_path(self) -&gt; \"DownloaderConfiguration\":\n        if self.use_bucket:\n            # noinspection PyBroadException\n            try:\n                bucket_path = Path(self.bucket_path)\n                bucket_path.mkdir(parents=True, exist_ok=True)\n                with tempfile.TemporaryFile(dir=bucket_path) as temp_file:\n                    temp_link_file_path = f\"{bucket_path / temp_file.name}.hlink\"\n                    os.link(temp_file.name, temp_link_file_path)\n                    os.remove(temp_link_file_path)\n            except Exception:\n                self.use_bucket = False\n                logger.exception(f\"`DownloaderConfiguration.bucket_path` is not available, \"\n                                 f\"`DownloaderConfiguration.use_bucket` has been disabled.\")\n        return self\n</code></pre>"},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.bucket_path","title":"<code>bucket_path: Path = Path('./.ktoolbox/bucket_storage')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.buffer_size","title":"<code>buffer_size: int = 20480</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.chunk_size","title":"<code>chunk_size: int = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.encoding","title":"<code>encoding: str = 'utf-8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.keep_metadata","title":"<code>keep_metadata: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.retry_interval","title":"<code>retry_interval: float = 3.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.retry_stop_never","title":"<code>retry_stop_never: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.retry_times","title":"<code>retry_times: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.reverse_proxy","title":"<code>reverse_proxy: str = '{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.temp_suffix","title":"<code>temp_suffix: str = 'tmp'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.timeout","title":"<code>timeout: float = 30.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.tps_limit","title":"<code>tps_limit: float = 5.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.use_bucket","title":"<code>use_bucket: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.check_bucket_path","title":"<code>check_bucket_path()</code>","text":"Source code in <code>ktoolbox/configuration.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_bucket_path(self) -&gt; \"DownloaderConfiguration\":\n    if self.use_bucket:\n        # noinspection PyBroadException\n        try:\n            bucket_path = Path(self.bucket_path)\n            bucket_path.mkdir(parents=True, exist_ok=True)\n            with tempfile.TemporaryFile(dir=bucket_path) as temp_file:\n                temp_link_file_path = f\"{bucket_path / temp_file.name}.hlink\"\n                os.link(temp_file.name, temp_link_file_path)\n                os.remove(temp_link_file_path)\n        except Exception:\n            self.use_bucket = False\n            logger.exception(f\"`DownloaderConfiguration.bucket_path` is not available, \"\n                             f\"`DownloaderConfiguration.use_bucket` has been disabled.\")\n    return self\n</code></pre>"},{"location":"api/#ktoolbox.configuration.JobConfiguration","title":"<code>JobConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Download jobs Configuration</p> <ul> <li> <p>Available properties for <code>post_dirname_format</code> and <code>filename_format</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> <li> <p>Available properties for <code>year_dirname_format</code> and <code>month_dirname_format</code></p> Property Type <code>year</code> String <code>month</code> String </li> <li> <p>Python Format Specification Mini-Language reference:</p> <p>https://docs.python.org/3.13/library/string.html#format-specification-mini-language</p> </li> </ul> <p>Attributes:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of coroutines for concurrent download</p> <code>                       4               </code> <code>include_revisions</code> <code>bool</code> <p>Include and download revision posts when available</p> <code>                       False               </code> <code>post_dirname_format</code> <code>str</code> <p>Customize the post directory name format, you can use some of the     properties in <code>Post</code>.     e.g. <code>[{published}]{id}</code> could result dirname <code>[2024-1-1]123123</code>,     <code>{user}_{published}_{title}</code> could result dirname like <code>234234_2024-1-1_TheTitle</code>.     Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example:     <code>{title:.6}</code> could shorten the title length to 6 characters like <code>HiEveryoneThisIsALongTitle</code> to <code>HiEver</code></p> <code>                       '{title}'               </code> <code>post_structure</code> <code>PostStructureConfiguration</code> <p>Post path structure</p> <code>                       PostStructureConfiguration()               </code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path in creator directory.     It would not create any post directory, and <code>CreatorIndices</code> would not been recorded.</p> <code>                       False               </code> <code>sequential_filename</code> <code>bool</code> <p>Rename attachments in numerical order, e.g. <code>1.png</code>, <code>2.png</code>, ...</p> <code>                       False               </code> <code>sequential_filename_excludes</code> <code>Set[str]</code> <p>File extensions to exclude from sequential naming when <code>sequential_filename</code> is enabled.     Files with these extensions will keep their original names. e.g. <code>[\".psd\", \".zip\", \".mp4\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>filename_format</code> <code>str</code> <p>Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename. Similar to post_dirname_format, you can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b</code>, <code>TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90</code>, etc.     You can also use it with <code>sequential_filename</code>. For instance,     <code>[{published}]_{}</code> could result in filenames like <code>[2024-1-1]_1.png</code>, <code>[2024-1-1]_2.png</code>, etc.     Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example:     <code>{title:.6}</code> could shorten the title length to 6 characters like <code>HiEveryoneThisIsALongTitle</code> to <code>HiEver</code></p> <code>                       '{}'               </code> <code>allow_list</code> <code>Set[str]</code> <p>Download files which match these patterns (Unix shell-style), e.g. <code>[\"*.png\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>block_list</code> <code>Set[str]</code> <p>Not to download files which match these patterns (Unix shell-style), e.g. <code>[\"*.psd\",\"*.zip\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>extract_content</code> <code>bool</code> <p>Extract post content and save to separate file (filename was defined in <code>config.job.post_structure.content</code>)</p> <code>                       False               </code> <code>extract_content_images</code> <code>bool</code> <p>Extract images from post content and download them.</p> <code>                       False               </code> <code>extract_external_links</code> <code>bool</code> <p>Extract external file sharing links from post content and save to separate file     (filename was defined in <code>config.job.post_structure.external_links</code>)</p> <code>                       False               </code> <code>external_link_patterns</code> <code>List[str]</code> <p>Regex patterns for extracting external links.</p> <code>                       ['https?://drive\\\\.google\\\\.com/[^\\\\s]+', 'https?://docs\\\\.google\\\\.com/[^\\\\s]+', 'https?://mega\\\\.nz/[^\\\\s]+', 'https?://mega\\\\.co\\\\.nz/[^\\\\s]+', 'https?://(?:www\\\\.)?dropbox\\\\.com/[^\\\\s]+', 'https?://db\\\\.tt/[^\\\\s]+', 'https?://onedrive\\\\.live\\\\.com/[^\\\\s]+', 'https?://1drv\\\\.ms/[^\\\\s]+', 'https?://(?:www\\\\.)?mediafire\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?wetransfer\\\\.com/[^\\\\s]+', 'https?://we\\\\.tl/[^\\\\s]+', 'https?://(?:www\\\\.)?sendspace\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?4shared\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?zippyshare\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?uploadfiles\\\\.io/[^\\\\s]+', 'https?://(?:www\\\\.)?box\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?pcloud\\\\.com/[^\\\\s]+', 'https?://disk\\\\.yandex\\\\.[a-z]+/[^\\\\s]+', 'https?://[^\\\\s]*(?:file|upload|share|download|drive|storage)[^\\\\s]*\\\\.[a-z]{2,4}/[^\\\\s]+']               </code> <code>group_by_year</code> <code>bool</code> <p>Group posts by year in separate directories based on published date</p> <code>                       False               </code> <code>group_by_month</code> <code>bool</code> <p>Group posts by month in separate directories based on published date (requires group_by_year)</p> <code>                       False               </code> <code>year_dirname_format</code> <code>str</code> <p>Customize the year directory name format. Available properties: <code>year</code>.     e.g. <code>{year}</code> &gt; <code>2024</code>, <code>Year_{year}</code> &gt; <code>Year_2024</code></p> <code>                       '{year}'               </code> <code>month_dirname_format</code> <code>str</code> <p>Customize the month directory name format. Available properties: <code>year</code>, <code>month</code>.     e.g. <code>{year}-{month}</code> &gt; <code>2024-01</code>, <code>{year}_{month}</code> &gt; <code>2024_01</code></p> <code>                       '{year}-{month:02d}'               </code> <code>keywords</code> <code>Set[str]</code> <p>keywords to filter posts by title (case-insensitive)</p> <code>                       Field(default_factory=set)               </code> <code>keywords_exclude</code> <code>Set[str]</code> <p>keywords to exclude posts by title (case-insensitive)</p> <code>                       Field(default_factory=set)               </code> <code>download_file</code> <code>bool</code> <p>Download post file (usually cover image). Set to False to skip file downloads.</p> <code>                       True               </code> <code>download_attachments</code> <code>bool</code> <p>Download post attachments. Set to False to skip attachment downloads.</p> <code>                       True               </code> <code>min_file_size</code> <code>Optional[int]</code> <p>Minimum file size in bytes to download. Files smaller than this will be skipped.     Set to None to disable minimum size filtering.</p> <code>                       None               </code> <code>max_file_size</code> <code>Optional[int]</code> <p>Maximum file size in bytes to download. Files larger than this will be skipped.     Set to None to disable maximum size filtering.</p> <code>                       None               </code> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class JobConfiguration(BaseModel):\n    \"\"\"\n    Download jobs Configuration\n\n    - Available properties for ``post_dirname_format`` and ``filename_format``\n\n        | Property      | Type   |\n        |---------------|--------|\n        | ``id``        | String |\n        | ``user``      | String |\n        | ``service``   | String |\n        | ``title``     | String |\n        | ``added``     | Date   |\n        | ``published`` | Date   |\n        | ``edited``    | Date   |\n\n    - Available properties for ``year_dirname_format`` and ``month_dirname_format``\n\n        | Property      | Type   |\n        |---------------|--------|\n        | ``year``      | String |\n        | ``month``     | String |\n\n    - Python Format Specification Mini-Language reference:\n\n        https://docs.python.org/3.13/library/string.html#format-specification-mini-language\n\n    :ivar count: Number of coroutines for concurrent download\n    :ivar include_revisions: Include and download revision posts when available\n    :ivar post_dirname_format: Customize the post directory name format, you can use some of the \\\n    [properties][ktoolbox.configuration.JobConfiguration] in ``Post``. \\\n    e.g. ``[{published}]{id}`` could result dirname ``[2024-1-1]123123``, \\\n    ``{user}_{published}_{title}`` could result dirname like ``234234_2024-1-1_TheTitle``. \\\n    Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example: \\\n    ``{title:.6}`` could shorten the title length to 6 characters like ``HiEveryoneThisIsALongTitle`` to ``HiEver``\n    :ivar post_structure: Post path structure\n    :ivar mix_posts: Save all files from different posts at same path in creator directory. \\\n    It would not create any post directory, and ``CreatorIndices`` would not been recorded.\n    :ivar sequential_filename: Rename attachments in numerical order, e.g. ``1.png``, ``2.png``, ...\n    :ivar sequential_filename_excludes: File extensions to exclude from sequential naming when ``sequential_filename`` is enabled. \\\n    Files with these extensions will keep their original names. e.g. ``[\".psd\", \".zip\", \".mp4\"]``\n    :ivar filename_format: Customize the filename format by inserting an empty ``{}`` to represent the basic filename.\n    Similar to post_dirname_format, you can use some of the [properties][ktoolbox.configuration.JobConfiguration] \\\n    in Post. For example: ``{title}_{}`` could result in filenames like \\\n    ``TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b``, ``TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90``, etc. \\\n    You can also use it with ``sequential_filename``. For instance, \\\n    ``[{published}]_{}`` could result in filenames like ``[2024-1-1]_1.png``, ``[2024-1-1]_2.png``, etc. \\\n    Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example: \\\n    ``{title:.6}`` could shorten the title length to 6 characters like ``HiEveryoneThisIsALongTitle`` to ``HiEver``\n    :ivar allow_list: Download files which match these patterns (Unix shell-style), e.g. ``[\"*.png\"]``\n    :ivar block_list: Not to download files which match these patterns (Unix shell-style), e.g. ``[\"*.psd\",\"*.zip\"]``\n    :ivar extract_content: Extract post content and save to separate file (filename was defined in ``config.job.post_structure.content``)\n    :ivar extract_content_images: Extract images from post content and download them.\n    :ivar extract_external_links: Extract external file sharing links from post content and save to separate file \\\n    (filename was defined in ``config.job.post_structure.external_links``)\n    :ivar external_link_patterns: Regex patterns for extracting external links.\n    :ivar group_by_year: Group posts by year in separate directories based on published date\n    :ivar group_by_month: Group posts by month in separate directories based on published date (requires group_by_year)\n    :ivar year_dirname_format: Customize the year directory name format. Available properties: ``year``. \\\n    e.g. ``{year}`` &gt; ``2024``, ``Year_{year}`` &gt; ``Year_2024``\n    :ivar month_dirname_format: Customize the month directory name format. Available properties: ``year``, ``month``. \\\n    e.g. ``{year}-{month}`` &gt; ``2024-01``, ``{year}_{month}`` &gt; ``2024_01``\n    :ivar keywords: keywords to filter posts by title (case-insensitive)\n    :ivar keywords_exclude: keywords to exclude posts by title (case-insensitive)\n    :ivar download_file: Download post file (usually cover image). Set to False to skip file downloads.\n    :ivar download_attachments: Download post attachments. Set to False to skip attachment downloads.\n    :ivar min_file_size: Minimum file size in bytes to download. Files smaller than this will be skipped. \\\n    Set to None to disable minimum size filtering.\n    :ivar max_file_size: Maximum file size in bytes to download. Files larger than this will be skipped. \\\n    Set to None to disable maximum size filtering.\n    \"\"\"\n    count: int = 4\n    include_revisions: bool = False\n    post_dirname_format: str = \"{title}\"\n    post_structure: PostStructureConfiguration = PostStructureConfiguration()\n    mix_posts: bool = False\n    sequential_filename: bool = False\n    sequential_filename_excludes: Set[str] = Field(default_factory=set)\n    filename_format: str = \"{}\"\n    # noinspection PyDataclass\n    allow_list: Set[str] = Field(default_factory=set)\n    # noinspection PyDataclass\n    block_list: Set[str] = Field(default_factory=set)\n    extract_content: bool = False\n    extract_content_images: bool = False\n    extract_external_links: bool = False\n    # noinspection SpellCheckingInspection\n    external_link_patterns: List[str] = [\n        # Google Drive\n        r'https?://drive\\.google\\.com/[^\\s]+',\n        r'https?://docs\\.google\\.com/[^\\s]+',\n\n        # MEGA\n        r'https?://mega\\.nz/[^\\s]+',\n        r'https?://mega\\.co\\.nz/[^\\s]+',\n\n        # Dropbox\n        r'https?://(?:www\\.)?dropbox\\.com/[^\\s]+',\n        r'https?://db\\.tt/[^\\s]+',\n\n        # OneDrive\n        r'https?://onedrive\\.live\\.com/[^\\s]+',\n        r'https?://1drv\\.ms/[^\\s]+',\n\n        # MediaFire\n        r'https?://(?:www\\.)?mediafire\\.com/[^\\s]+',\n\n        # WeTransfer\n        r'https?://(?:www\\.)?wetransfer\\.com/[^\\s]+',\n        r'https?://we\\.tl/[^\\s]+',\n\n        # SendSpace\n        r'https?://(?:www\\.)?sendspace\\.com/[^\\s]+',\n\n        # 4shared\n        r'https?://(?:www\\.)?4shared\\.com/[^\\s]+',\n\n        # Zippyshare\n        r'https?://(?:www\\.)?zippyshare\\.com/[^\\s]+',\n\n        # Uploadfiles.io\n        r'https?://(?:www\\.)?uploadfiles\\.io/[^\\s]+',\n\n        # Box\n        r'https?://(?:www\\.)?box\\.com/[^\\s]+',\n\n        # pCloud\n        r'https?://(?:www\\.)?pcloud\\.com/[^\\s]+',\n\n        # Yandex Disk\n        r'https?://disk\\.yandex\\.[a-z]+/[^\\s]+',\n\n        # Generic patterns for other file hosting services\n        r'https?://[^\\s]*(?:file|upload|share|download|drive|storage)[^\\s]*\\.[a-z]{2,4}/[^\\s]+',\n    ]\n    group_by_year: bool = False\n    group_by_month: bool = False\n    year_dirname_format: str = \"{year}\"\n    month_dirname_format: str = \"{year}-{month:02d}\"\n    keywords: Set[str] = Field(default_factory=set)\n    keywords_exclude: Set[str] = Field(default_factory=set)\n    download_file: bool = True\n    download_attachments: bool = True\n    min_file_size: Optional[int] = None\n    max_file_size: Optional[int] = None\n</code></pre>"},{"location":"api/#ktoolbox.configuration.JobConfiguration.allow_list","title":"<code>allow_list: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.block_list","title":"<code>block_list: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.count","title":"<code>count: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.download_attachments","title":"<code>download_attachments: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.download_file","title":"<code>download_file: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.external_link_patterns","title":"<code>external_link_patterns: List[str] = ['https?://drive\\\\.google\\\\.com/[^\\\\s]+', 'https?://docs\\\\.google\\\\.com/[^\\\\s]+', 'https?://mega\\\\.nz/[^\\\\s]+', 'https?://mega\\\\.co\\\\.nz/[^\\\\s]+', 'https?://(?:www\\\\.)?dropbox\\\\.com/[^\\\\s]+', 'https?://db\\\\.tt/[^\\\\s]+', 'https?://onedrive\\\\.live\\\\.com/[^\\\\s]+', 'https?://1drv\\\\.ms/[^\\\\s]+', 'https?://(?:www\\\\.)?mediafire\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?wetransfer\\\\.com/[^\\\\s]+', 'https?://we\\\\.tl/[^\\\\s]+', 'https?://(?:www\\\\.)?sendspace\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?4shared\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?zippyshare\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?uploadfiles\\\\.io/[^\\\\s]+', 'https?://(?:www\\\\.)?box\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?pcloud\\\\.com/[^\\\\s]+', 'https?://disk\\\\.yandex\\\\.[a-z]+/[^\\\\s]+', 'https?://[^\\\\s]*(?:file|upload|share|download|drive|storage)[^\\\\s]*\\\\.[a-z]{2,4}/[^\\\\s]+']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.extract_content","title":"<code>extract_content: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.extract_content_images","title":"<code>extract_content_images: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.extract_external_links","title":"<code>extract_external_links: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.filename_format","title":"<code>filename_format: str = '{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.group_by_month","title":"<code>group_by_month: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.group_by_year","title":"<code>group_by_year: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.include_revisions","title":"<code>include_revisions: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.keywords","title":"<code>keywords: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.keywords_exclude","title":"<code>keywords_exclude: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.max_file_size","title":"<code>max_file_size: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.min_file_size","title":"<code>min_file_size: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.mix_posts","title":"<code>mix_posts: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.month_dirname_format","title":"<code>month_dirname_format: str = '{year}-{month:02d}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.post_dirname_format","title":"<code>post_dirname_format: str = '{title}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.post_structure","title":"<code>post_structure: PostStructureConfiguration = PostStructureConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.sequential_filename","title":"<code>sequential_filename: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.sequential_filename_excludes","title":"<code>sequential_filename_excludes: Set[str] = Field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.year_dirname_format","title":"<code>year_dirname_format: str = '{year}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration","title":"<code>LoggerConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Logger configuration</p> <p>Attributes:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to save logs, <code>None</code> for disable log file output</p> <code>                       None               </code> <code>level</code> <code>Union[str, int]</code> <p>Log filter level</p> <code>                       logging.getLevelName(logging.DEBUG)               </code> <code>rotation</code> <code>Union[str, int, time, timedelta]</code> <p>Log rotation</p> <code>                       '1 week'               </code> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class LoggerConfiguration(BaseModel):\n    \"\"\"\n    Logger configuration\n\n    :ivar path: Path to save logs, ``None`` for disable log file output\n    :ivar level: Log filter level\n    :ivar rotation: Log rotation\n    \"\"\"\n    path: Optional[Path] = None\n    level: Union[str, int] = logging.getLevelName(logging.DEBUG)\n    rotation: Union[str, int, datetime.time, datetime.timedelta] = \"1 week\"\n</code></pre>"},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.level","title":"<code>level: Union[str, int] = logging.getLevelName(logging.DEBUG)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.path","title":"<code>path: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.rotation","title":"<code>rotation: Union[str, int, datetime.time, datetime.timedelta] = '1 week'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration","title":"<code>PostStructureConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Post path structure model</p> <ul> <li> <p>Default: <pre><code>..\n\u251c\u2500 content.txt\n\u251c\u2500 external_links.txt\n\u251c\u2500 {id}_{}.png (file)\n\u251c\u2500 post.json (metadata)\n\u251c\u2500 attachments\n\u2502    \u251c\u2500 1.png\n\u2502    \u2514\u2500 2.png\n\u2514\u2500 revisions\n     \u251c\u2500 &lt;PostStructure&gt;\n     \u2502    \u251c\u2500 ...\n     \u2502    \u2514\u2500 ...\n     \u2514\u2500 &lt;PostStructure&gt;\n          \u251c\u2500 ...\n          \u2514\u2500 ...\n</code></pre></p> </li> <li> <p>Available properties for <code>file</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> </ul> <p>Attributes:</p> Name Type Description Default <code>attachments</code> <code>Path</code> <p>Sub path of attachment directory</p> <code>                       Path('attachments')               </code> <code>content</code> <code>Path</code> <p>Sub path of post content file</p> <code>                       Path('content.txt')               </code> <code>external_links</code> <code>Path</code> <p>Sub path of external links file (for cloud storage links found in content)</p> <code>                       Path('external_links.txt')               </code> <code>file</code> <code>str</code> <p>The format of the post <code>file</code> filename (<code>file</code> is not <code>attachment</code>, each post has only one <code>file</code>, usually the cover image)     Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename.     You can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_Stelle_lv5_logo.gif</code>, <code>TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code>, etc.     Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example:     <code>{title:.6}_{}</code> could shorten the title length to 6 characters like     <code>HiEveryoneThisIsALongTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code> to <code>HiEver_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code></p> <code>                       '{id}_{}'               </code> <code>revisions</code> <code>Path</code> <p>Sub path of revisions directory</p> <code>                       Path('revisions')               </code> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class PostStructureConfiguration(BaseModel):\n    # noinspection SpellCheckingInspection,GrazieInspection\n    \"\"\"\n    Post path structure model\n\n    - Default:\n    ```\n    ..\n    \u251c\u2500 content.txt\n    \u251c\u2500 external_links.txt\n    \u251c\u2500 {id}_{}.png (file)\n    \u251c\u2500 post.json (metadata)\n    \u251c\u2500 attachments\n    \u2502    \u251c\u2500 1.png\n    \u2502    \u2514\u2500 2.png\n    \u2514\u2500 revisions\n         \u251c\u2500 &lt;PostStructure&gt;\n         \u2502    \u251c\u2500 ...\n         \u2502    \u2514\u2500 ...\n         \u2514\u2500 &lt;PostStructure&gt;\n              \u251c\u2500 ...\n              \u2514\u2500 ...\n    ```\n\n    - Available properties for ``file``\n\n        | Property      | Type   |\n        |---------------|--------|\n        | ``id``        | String |\n        | ``user``      | String |\n        | ``service``   | String |\n        | ``title``     | String |\n        | ``added``     | Date   |\n        | ``published`` | Date   |\n        | ``edited``    | Date   |\n\n    :ivar attachments: Sub path of attachment directory\n    :ivar content: Sub path of post content file\n    :ivar external_links: Sub path of external links file (for cloud storage links found in content)\n    :ivar file: The format of the post `file` filename (`file` is not `attachment`, each post has only one `file`, usually the cover image) \\\n    Customize the filename format by inserting an empty ``{}`` to represent the basic filename. \\\n    You can use some of the [properties][ktoolbox.configuration.JobConfiguration] \\\n    in Post. For example: ``{title}_{}`` could result in filenames like \\\n    ``TheTitle_Stelle_lv5_logo.gif``, ``TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg``, etc. \\\n    Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example: \\\n    ``{title:.6}_{}`` could shorten the title length to 6 characters like \\\n    ``HiEveryoneThisIsALongTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg`` to ``HiEver_ScxHjZIdxt5cnjaAwf3ql2p7.jpg``\n    :ivar revisions: Sub path of revisions directory\n    \"\"\"\n    attachments: Path = Path(\"attachments\")\n    content: Path = Path(\"content.txt\")\n    external_links: Path = Path(\"external_links.txt\")\n    file: str = \"{id}_{}\"\n    revisions: Path = Path(\"revisions\")\n</code></pre>"},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.attachments","title":"<code>attachments: Path = Path('attachments')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.content","title":"<code>content: Path = Path('content.txt')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.external_links","title":"<code>external_links: Path = Path('external_links.txt')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.file","title":"<code>file: str = '{id}_{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.revisions","title":"<code>revisions: Path = Path('revisions')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader","title":"<code>downloader</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader","title":"<code>Downloader</code>","text":"<p>Attributes:</p> Name Type Description Default <code>_save_filename</code> <p>The actual filename for saving.</p> <code>                       designated_filename               </code> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>class Downloader:\n    \"\"\"\n    :ivar _save_filename: The actual filename for saving.\n    \"\"\"\n    succeeded_servers: Set[int] = set()\n    failure_servers: Set[int] = set()\n    wait_lock = Lock()\n\n    def __init__(\n            self,\n            url: str,\n            path: Path,\n            client: httpx.AsyncClient,\n            *,\n            buffer_size: int = None,\n            chunk_size: int = None,\n            designated_filename: str = None,\n            server_path: str = None,\n            post: Post = None\n    ):\n        # noinspection GrazieInspection\n        \"\"\"\n        Initialize a file downloader\n\n        - About filename:\n            1. If ``designated_filename`` parameter is set, use it.\n            2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n            3. Else use filename from 'file' part of ``server_path``.\n\n        :param url: Download URL\n        :param path: Directory path to save the file, which needs to be sanitized\n        :param client: HTTPX AsyncClient\n        :param buffer_size: Number of bytes for file I/O buffer\n        :param chunk_size: Number of bytes for chunk of download stream\n        :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n        :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n        it will be used as the save path.\n        :param post: Post object, use for logging.\n        \"\"\"\n\n        self._url = self._initial_url = url\n        self._path = path\n        self._client = client\n        self._buffer_size = buffer_size or config.downloader.buffer_size\n        self._chunk_size = chunk_size or config.downloader.chunk_size\n        self._designated_filename = designated_filename\n        self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n        self._save_filename = designated_filename  # Prioritize the manually specified filename\n        self._post = post\n\n        self._next_subdomain_index = 1\n        self._finished_lock = asyncio.Lock()\n        self._stop: bool = False\n\n    @cached_property\n    def url(self) -&gt; str:\n        \"\"\"Download URL\"\"\"\n        return self._url\n\n    @cached_property\n    def path(self) -&gt; Path:\n        \"\"\"Directory path to save the file\"\"\"\n        return self._path\n\n    @cached_property\n    def client(self) -&gt; httpx.AsyncClient:\n        \"\"\"HTTPX AsyncClient\"\"\"\n        return self._client\n\n    @cached_property\n    def buffer_size(self) -&gt; int:\n        \"\"\"Number of bytes for file I/O buffer\"\"\"\n        return self._buffer_size\n\n    @cached_property\n    def chunk_size(self) -&gt; int:\n        \"\"\"Number of bytes for chunk of download stream\"\"\"\n        return self._chunk_size\n\n    @cached_property\n    def post(self) -&gt; Post:\n        \"\"\"Post that the file belongs to\"\"\"\n        return self._post\n\n    @property\n    def filename(self) -&gt; Optional[str]:\n        \"\"\"Actual filename of the download file\"\"\"\n        return self._save_filename\n\n    @property\n    def finished(self) -&gt; bool:\n        \"\"\"\n        Check if the download finished\n\n        :return: ``False`` if the download **in process**, ``True`` otherwise\n        \"\"\"\n        return not self._finished_lock.locked()\n\n    def cancel(self):\n        \"\"\"\n        Cancel the download\n\n        It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n        \"\"\"\n        self._stop = True\n\n    @tenacity.retry(\n        stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n        wait=wait_fixed(config.downloader.retry_interval),\n        retry=retry_if_result(\n            lambda x: not x and x.code != RetCodeEnum.FileExisted\n        ) | retry_if_exception(\n            lambda x: isinstance(x, httpx.HTTPError)\n        ),\n        before_sleep=lambda x: logger.warning(\n            generate_msg(\n                f\"Retrying ({x.attempt_number})\",\n                file=x.args[0].filename,\n                post_name=x.args[0].post.title if x.args[0].post else None,\n                post_id=x.args[0].post.id if x.args[0].post else None,\n                message=x.outcome.result().message if not x.outcome.failed else None,\n                exception=x.outcome.exception(),\n                url=x.args[0].url\n            )\n        ),\n        reraise=True\n    )\n    async def run(\n            self,\n            *,\n            sync_callable: Callable[[\"Downloader\"], Any] = None,\n            async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n            tqdm_class: Type[std_tqdm] = None,\n            progress: bool = False\n    ) -&gt; DownloaderRet[str]:\n        \"\"\"\n        Start to download\n\n        :param sync_callable: Sync callable for download finished\n        :param async_callable: Async callable for download finished\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        :return: ``DownloaderRet`` which contain the actual output filename\n        :raise CancelledError: Job cancelled\n        \"\"\"\n        # Get filename to check if file exists (First-time duplicate file check)\n        # Check it before request to make progress more efficiency\n        server_relpath = self._server_path[1:]\n        server_relpath_without_params = urlparse(server_relpath).path\n        server_path_filename = unquote(Path(server_relpath_without_params).name)\n        # Priority order can be referenced from the constructor's documentation\n        save_filepath = self._path / (self._save_filename or server_path_filename)\n\n        # Get bucket file path\n        bucket_file_path: Optional[Path] = None\n        if config.downloader.use_bucket:\n            bucket_file_path = config.downloader.bucket_path / server_relpath\n\n        # Check if the file exists\n        file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n        if file_existed:\n            return DownloaderRet(\n                code=RetCodeEnum.FileExisted,\n                message=generate_msg(\n                    ret_msg,\n                    path=save_filepath\n                )\n            )\n\n        tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n        async with self.wait_lock:\n            await asyncio.sleep(1 / config.downloader.tps_limit)\n        async with self._finished_lock:\n            temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n            temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n            async with self._client.stream(\n                    method=\"GET\",\n                    url=config.downloader.reverse_proxy.format(self._url),\n                    follow_redirects=True,\n                    timeout=config.downloader.timeout,\n                    headers={\"Range\": f\"bytes={temp_size}-\"}\n            ) as res:  # type: httpx.Response\n                try:\n                    subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n                except ValueError:\n                    subdomain_index = None\n                if res.status_code == 403:\n                    if subdomain_index is not None:\n                        self.succeeded_servers.discard(subdomain_index)\n                        self.failure_servers.add(subdomain_index)\n                    # try succeeded servers first\n                    subdomain_index = next(iter(self.succeeded_servers), None)\n                    if subdomain_index is None:\n                        subdomain_index = self._next_subdomain_index\n                        # Update self._next_subdomain_index\n                        ## index fallback to 1 when a server after failure_servers has been tried\n                        if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                            self._next_subdomain_index = 1\n                            self.failure_servers.clear()\n                        ## otherwise, increment the index and avoid failure_servers\n                        else:\n                            self._next_subdomain_index += 1\n                            while self._next_subdomain_index in self.failure_servers:\n                                self._next_subdomain_index += 1\n                        msg = \"Download failed, trying next subdomain\"\n                    else:\n                        msg = \"Download failed, trying succeeded subdomains\"\n                    new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                    self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            msg,\n                            nex_subdomain=new_netloc,\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                    self._url = self._initial_url\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            \"Download failed\",\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                else:\n                    if subdomain_index is not None:\n                        self.failure_servers.discard(subdomain_index)\n                        self.succeeded_servers.add(subdomain_index)\n\n                # Get filename for saving and check if file exists (Second-time duplicate file check)\n                # Priority order can be referenced from the constructor's documentation\n                self._save_filename = self._designated_filename or sanitize_filename(\n                    filename_from_headers(res.headers)\n                ) or server_path_filename\n                save_filepath = self._path / self._save_filename\n                file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n                if file_existed:\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,\n                        message=generate_msg(\n                            ret_msg,\n                            path=save_filepath\n                        )\n                    )\n\n                # Download\n                total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n\n                # Check file size filtering if enabled and we have the total size\n                if total_size is not None and (config.job.min_file_size is not None or config.job.max_file_size is not None):\n                    # Check minimum size\n                    if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                        logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                        return DownloaderRet(\n                            code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                            message=generate_msg(\n                                f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                                path=save_filepath\n                            )\n                        )\n\n                    # Check maximum size  \n                    if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                        logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                        return DownloaderRet(\n                            code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                            message=generate_msg(\n                                f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                                path=save_filepath\n                            )\n                        )\n\n                # If no Content-Range header, try to get size from Content-Length\n                if total_size is None:\n                    content_length = res.headers.get(\"Content-Length\")\n                    if content_length:\n                        try:\n                            total_size = int(content_length)\n                            # Apply size filtering with Content-Length\n                            if config.job.min_file_size is not None or config.job.max_file_size is not None:\n                                # Check minimum size\n                                if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                                    return DownloaderRet(\n                                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                        message=generate_msg(\n                                            f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                                            path=save_filepath\n                                        )\n                                    )\n\n                                # Check maximum size  \n                                if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                                    return DownloaderRet(\n                                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                        message=generate_msg(\n                                            f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                                            path=save_filepath\n                                        )\n                                    )\n                        except ValueError:\n                            # Invalid Content-Length, continue with download\n                            pass\n                async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                    chunk_iterator = res.aiter_bytes(self._chunk_size)\n                    t = tqdm_class(\n                        desc=self._save_filename,\n                        total=total_size,\n                        initial=temp_size,\n                        disable=not progress,\n                        unit=\"B\",\n                        unit_scale=True\n                    )\n                    async for chunk in chunk_iterator:\n                        if self._stop:\n                            raise CancelledError\n                        await f.write(chunk)\n                        t.update(len(chunk))  # Update progress bar\n\n            # Download finished\n            if config.downloader.use_bucket:\n                bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n                os.link(temp_filepath, bucket_file_path)\n            final_filepath = self._path / self._save_filename\n            temp_filepath.rename(final_filepath)\n\n            # Set file time from headers\n            if config.downloader.keep_metadata:\n                try:\n                    utime_from_headers(res.headers, final_filepath)\n                except (OSError, ValueError, TypeError) as e:\n                    logger.warning(\n                        generate_msg(\n                            \"Failed to set file time from headers\",\n                            file=self._save_filename,\n                            exception=e\n                        )\n                    )\n\n            # Callbacks\n            if sync_callable:\n                sync_callable(self)\n            if async_callable:\n                await async_callable(self)\n\n            return DownloaderRet(\n                data=self._save_filename\n            ) if self._save_filename else DownloaderRet(\n                code=RetCodeEnum.GeneralFailure,\n                message=generate_msg(\n                    \"Download failed\",\n                    filename=self._designated_filename\n                )\n            )\n\n    __call__ = run\n</code></pre>"},{"location":"api/#ktoolbox.downloader.Downloader.__call__","title":"<code>__call__ = run</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.buffer_size","title":"<code>buffer_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for file I/O buffer</p>"},{"location":"api/#ktoolbox.downloader.Downloader.chunk_size","title":"<code>chunk_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for chunk of download stream</p>"},{"location":"api/#ktoolbox.downloader.Downloader.client","title":"<code>client: httpx.AsyncClient</code>  <code>cached</code> <code>property</code>","text":"<p>HTTPX AsyncClient</p>"},{"location":"api/#ktoolbox.downloader.Downloader.failure_servers","title":"<code>failure_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.filename","title":"<code>filename: Optional[str]</code>  <code>property</code>","text":"<p>Actual filename of the download file</p>"},{"location":"api/#ktoolbox.downloader.Downloader.finished","title":"<code>finished: bool</code>  <code>property</code>","text":"<p>Check if the download finished</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> if the download in process, <code>True</code> otherwise</p>"},{"location":"api/#ktoolbox.downloader.Downloader.path","title":"<code>path: Path</code>  <code>cached</code> <code>property</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.downloader.Downloader.post","title":"<code>post: Post</code>  <code>cached</code> <code>property</code>","text":"<p>Post that the file belongs to</p>"},{"location":"api/#ktoolbox.downloader.Downloader.succeeded_servers","title":"<code>succeeded_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.url","title":"<code>url: str</code>  <code>cached</code> <code>property</code>","text":"<p>Download URL</p>"},{"location":"api/#ktoolbox.downloader.Downloader.wait_lock","title":"<code>wait_lock = Lock()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.Downloader.__init__","title":"<code>__init__(url, path, client, *, buffer_size=None, chunk_size=None, designated_filename=None, server_path=None, post=None)</code>","text":"<p>Initialize a file downloader</p> <ul> <li>About filename:<ol> <li>If <code>designated_filename</code> parameter is set, use it.</li> <li>Else if <code>Content-Disposition</code> is set in headers, use filename from it.</li> <li>Else use filename from 'file' part of <code>server_path</code>.</li> </ol> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Download URL</p> required <code>path</code> <code>Path</code> <p>Directory path to save the file, which needs to be sanitized</p> required <code>client</code> <code>AsyncClient</code> <p>HTTPX AsyncClient</p> required <code>buffer_size</code> <code>int</code> <p>Number of bytes for file I/O buffer</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>Number of bytes for chunk of download stream</p> <code>None</code> <code>designated_filename</code> <code>str</code> <p>Manually specify the filename for saving, which needs to be sanitized</p> <code>None</code> <code>server_path</code> <code>str</code> <p>Server path of the file. if <code>DownloaderConfiguration.use_bucket</code> enabled,         it will be used as the save path.</p> <code>None</code> <code>post</code> <code>Post</code> <p>Post object, use for logging.</p> <code>None</code> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def __init__(\n        self,\n        url: str,\n        path: Path,\n        client: httpx.AsyncClient,\n        *,\n        buffer_size: int = None,\n        chunk_size: int = None,\n        designated_filename: str = None,\n        server_path: str = None,\n        post: Post = None\n):\n    # noinspection GrazieInspection\n    \"\"\"\n    Initialize a file downloader\n\n    - About filename:\n        1. If ``designated_filename`` parameter is set, use it.\n        2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n        3. Else use filename from 'file' part of ``server_path``.\n\n    :param url: Download URL\n    :param path: Directory path to save the file, which needs to be sanitized\n    :param client: HTTPX AsyncClient\n    :param buffer_size: Number of bytes for file I/O buffer\n    :param chunk_size: Number of bytes for chunk of download stream\n    :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n    :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n    it will be used as the save path.\n    :param post: Post object, use for logging.\n    \"\"\"\n\n    self._url = self._initial_url = url\n    self._path = path\n    self._client = client\n    self._buffer_size = buffer_size or config.downloader.buffer_size\n    self._chunk_size = chunk_size or config.downloader.chunk_size\n    self._designated_filename = designated_filename\n    self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n    self._save_filename = designated_filename  # Prioritize the manually specified filename\n    self._post = post\n\n    self._next_subdomain_index = 1\n    self._finished_lock = asyncio.Lock()\n    self._stop: bool = False\n</code></pre>"},{"location":"api/#ktoolbox.downloader.Downloader.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the download</p> <p>It will raise <code>asyncio.CancelledError</code> in <code>chunk_iterator</code> (writing chunk to file) iteration.</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def cancel(self):\n    \"\"\"\n    Cancel the download\n\n    It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n    \"\"\"\n    self._stop = True\n</code></pre>"},{"location":"api/#ktoolbox.downloader.Downloader.run","title":"<code>run(*, sync_callable=None, async_callable=None, tqdm_class=None, progress=False)</code>  <code>async</code>","text":"<p>Start to download</p> <p>Parameters:</p> Name Type Description Default <code>sync_callable</code> <code>Callable[[Downloader], Any]</code> <p>Sync callable for download finished</p> <code>None</code> <code>async_callable</code> <code>Callable[[Downloader], Coroutine]</code> <p>Async callable for download finished</p> <code>None</code> <code>tqdm_class</code> <code>Type[tqdm]</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>False</code> <p>Returns:</p> Type Description <code>DownloaderRet[str]</code> <p><code>DownloaderRet</code> which contain the actual output filename</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>Job cancelled</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>@tenacity.retry(\n    stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n    wait=wait_fixed(config.downloader.retry_interval),\n    retry=retry_if_result(\n        lambda x: not x and x.code != RetCodeEnum.FileExisted\n    ) | retry_if_exception(\n        lambda x: isinstance(x, httpx.HTTPError)\n    ),\n    before_sleep=lambda x: logger.warning(\n        generate_msg(\n            f\"Retrying ({x.attempt_number})\",\n            file=x.args[0].filename,\n            post_name=x.args[0].post.title if x.args[0].post else None,\n            post_id=x.args[0].post.id if x.args[0].post else None,\n            message=x.outcome.result().message if not x.outcome.failed else None,\n            exception=x.outcome.exception(),\n            url=x.args[0].url\n        )\n    ),\n    reraise=True\n)\nasync def run(\n        self,\n        *,\n        sync_callable: Callable[[\"Downloader\"], Any] = None,\n        async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n        tqdm_class: Type[std_tqdm] = None,\n        progress: bool = False\n) -&gt; DownloaderRet[str]:\n    \"\"\"\n    Start to download\n\n    :param sync_callable: Sync callable for download finished\n    :param async_callable: Async callable for download finished\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    :return: ``DownloaderRet`` which contain the actual output filename\n    :raise CancelledError: Job cancelled\n    \"\"\"\n    # Get filename to check if file exists (First-time duplicate file check)\n    # Check it before request to make progress more efficiency\n    server_relpath = self._server_path[1:]\n    server_relpath_without_params = urlparse(server_relpath).path\n    server_path_filename = unquote(Path(server_relpath_without_params).name)\n    # Priority order can be referenced from the constructor's documentation\n    save_filepath = self._path / (self._save_filename or server_path_filename)\n\n    # Get bucket file path\n    bucket_file_path: Optional[Path] = None\n    if config.downloader.use_bucket:\n        bucket_file_path = config.downloader.bucket_path / server_relpath\n\n    # Check if the file exists\n    file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n    if file_existed:\n        return DownloaderRet(\n            code=RetCodeEnum.FileExisted,\n            message=generate_msg(\n                ret_msg,\n                path=save_filepath\n            )\n        )\n\n    tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n    async with self.wait_lock:\n        await asyncio.sleep(1 / config.downloader.tps_limit)\n    async with self._finished_lock:\n        temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n        temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n        async with self._client.stream(\n                method=\"GET\",\n                url=config.downloader.reverse_proxy.format(self._url),\n                follow_redirects=True,\n                timeout=config.downloader.timeout,\n                headers={\"Range\": f\"bytes={temp_size}-\"}\n        ) as res:  # type: httpx.Response\n            try:\n                subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n            except ValueError:\n                subdomain_index = None\n            if res.status_code == 403:\n                if subdomain_index is not None:\n                    self.succeeded_servers.discard(subdomain_index)\n                    self.failure_servers.add(subdomain_index)\n                # try succeeded servers first\n                subdomain_index = next(iter(self.succeeded_servers), None)\n                if subdomain_index is None:\n                    subdomain_index = self._next_subdomain_index\n                    # Update self._next_subdomain_index\n                    ## index fallback to 1 when a server after failure_servers has been tried\n                    if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                        self._next_subdomain_index = 1\n                        self.failure_servers.clear()\n                    ## otherwise, increment the index and avoid failure_servers\n                    else:\n                        self._next_subdomain_index += 1\n                        while self._next_subdomain_index in self.failure_servers:\n                            self._next_subdomain_index += 1\n                    msg = \"Download failed, trying next subdomain\"\n                else:\n                    msg = \"Download failed, trying succeeded subdomains\"\n                new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        msg,\n                        nex_subdomain=new_netloc,\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                self._url = self._initial_url\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        \"Download failed\",\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            else:\n                if subdomain_index is not None:\n                    self.failure_servers.discard(subdomain_index)\n                    self.succeeded_servers.add(subdomain_index)\n\n            # Get filename for saving and check if file exists (Second-time duplicate file check)\n            # Priority order can be referenced from the constructor's documentation\n            self._save_filename = self._designated_filename or sanitize_filename(\n                filename_from_headers(res.headers)\n            ) or server_path_filename\n            save_filepath = self._path / self._save_filename\n            file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n            if file_existed:\n                return DownloaderRet(\n                    code=RetCodeEnum.FileExisted,\n                    message=generate_msg(\n                        ret_msg,\n                        path=save_filepath\n                    )\n                )\n\n            # Download\n            total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n\n            # Check file size filtering if enabled and we have the total size\n            if total_size is not None and (config.job.min_file_size is not None or config.job.max_file_size is not None):\n                # Check minimum size\n                if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                        message=generate_msg(\n                            f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                            path=save_filepath\n                        )\n                    )\n\n                # Check maximum size  \n                if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                        message=generate_msg(\n                            f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                            path=save_filepath\n                        )\n                    )\n\n            # If no Content-Range header, try to get size from Content-Length\n            if total_size is None:\n                content_length = res.headers.get(\"Content-Length\")\n                if content_length:\n                    try:\n                        total_size = int(content_length)\n                        # Apply size filtering with Content-Length\n                        if config.job.min_file_size is not None or config.job.max_file_size is not None:\n                            # Check minimum size\n                            if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                                logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                                return DownloaderRet(\n                                    code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                    message=generate_msg(\n                                        f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                                        path=save_filepath\n                                    )\n                                )\n\n                            # Check maximum size  \n                            if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                                logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                                return DownloaderRet(\n                                    code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                    message=generate_msg(\n                                        f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                                        path=save_filepath\n                                    )\n                                )\n                    except ValueError:\n                        # Invalid Content-Length, continue with download\n                        pass\n            async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                chunk_iterator = res.aiter_bytes(self._chunk_size)\n                t = tqdm_class(\n                    desc=self._save_filename,\n                    total=total_size,\n                    initial=temp_size,\n                    disable=not progress,\n                    unit=\"B\",\n                    unit_scale=True\n                )\n                async for chunk in chunk_iterator:\n                    if self._stop:\n                        raise CancelledError\n                    await f.write(chunk)\n                    t.update(len(chunk))  # Update progress bar\n\n        # Download finished\n        if config.downloader.use_bucket:\n            bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n            os.link(temp_filepath, bucket_file_path)\n        final_filepath = self._path / self._save_filename\n        temp_filepath.rename(final_filepath)\n\n        # Set file time from headers\n        if config.downloader.keep_metadata:\n            try:\n                utime_from_headers(res.headers, final_filepath)\n            except (OSError, ValueError, TypeError) as e:\n                logger.warning(\n                    generate_msg(\n                        \"Failed to set file time from headers\",\n                        file=self._save_filename,\n                        exception=e\n                    )\n                )\n\n        # Callbacks\n        if sync_callable:\n            sync_callable(self)\n        if async_callable:\n            await async_callable(self)\n\n        return DownloaderRet(\n            data=self._save_filename\n        ) if self._save_filename else DownloaderRet(\n            code=RetCodeEnum.GeneralFailure,\n            message=generate_msg(\n                \"Download failed\",\n                filename=self._designated_filename\n            )\n        )\n</code></pre>"},{"location":"api/#ktoolbox.downloader.DownloaderRet","title":"<code>DownloaderRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/downloader/base.py</code> <pre><code>class DownloaderRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.downloader.duplicate_file_check","title":"<code>duplicate_file_check(local_file_path, bucket_file_path=None)</code>","text":"<p>Check if the file existed, and link the bucket filepath to local filepath     if <code>DownloaderConfiguration.use_bucket</code> enabled.</p> <p>Parameters:</p> Name Type Description Default <code>local_file_path</code> <code>Path</code> <p>Download target path</p> required <code>bucket_file_path</code> <code>Path</code> <p>The bucket filepath of the local download path</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str]]</code> <p><code>(if file existed, message)</code></p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def duplicate_file_check(local_file_path: Path, bucket_file_path: Path = None) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"\n    Check if the file existed, and link the bucket filepath to local filepath \\\n    if ``DownloaderConfiguration.use_bucket`` enabled.\n\n    :param local_file_path: Download target path\n    :param bucket_file_path: The bucket filepath of the local download path\n    :return: ``(if file existed, message)``\n    \"\"\"\n    duplicate_check_path = bucket_file_path or local_file_path\n    if duplicate_check_path.is_file():\n        if config.downloader.use_bucket:\n            ret_msg = \"Download file already exists in both bucket and local, skipping\"\n            if not local_file_path.is_file():\n                ret_msg = \"Download file already exists in bucket, linking to local path\"\n                os.link(bucket_file_path, local_file_path)\n        else:\n            ret_msg = \"Download file already exists, skipping\"\n        return True, ret_msg\n    else:\n        return False, None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.filename_from_headers","title":"<code>filename_from_headers(headers)</code>","text":"<p>Get file name from headers.</p> <p>Parse from <code>Content-Disposition</code>.</p> <ul> <li> <p>Example: <pre><code>filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8''README%2Emd;filename=\"README.md\"'})\n</code></pre></p> </li> <li> <p>Return: <pre><code>README.md\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP headers</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>File name</p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def filename_from_headers(headers: Dict[str, str]) -&gt; Optional[str]:\n    \"\"\"\n    Get file name from headers.\n\n    Parse from ``Content-Disposition``.\n\n    - Example:\n    ```\n    filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8\\'\\'README%2Emd;filename=\"README.md\"'})\n    ```\n\n    - Return:\n    ```\n    README.md\n    ```\n\n    :param headers: HTTP headers\n    :return: File name\n    \"\"\"\n    if not (disposition := headers.get(\"Content-Disposition\")):\n        if not (disposition := headers.get(\"content-disposition\")):\n            return None\n    options = parse_header(disposition)  # alternative: `parse_header` in `utils.py`\n    if filename := options.get(\"filename*\"):\n        if len(name_with_charset := filename.split(\"''\")) == 2:\n            charset, name = name_with_charset\n            return urllib.parse.unquote(name, charset)\n    if filename := options.get(\"filename\"):\n        return urllib.parse.unquote(filename, config.downloader.encoding)\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utime_from_headers","title":"<code>utime_from_headers(headers, path)</code>","text":"<p>Run <code>os.utime</code> on specific file using <code>Last-Modified</code> or <code>Date</code> in HTTP headers.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP Headers</p> required <code>path</code> <code>Union[Path, str]</code> <p>File path</p> required Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def utime_from_headers(headers: Dict[str, str], path: Union[Path, str]) -&gt; Optional[Exception]:\n    \"\"\"\n    Run ``os.utime`` on specific file using ``Last-Modified`` or ``Date`` in HTTP headers.\n\n    :param headers: HTTP Headers\n    :param path: File path\n    :raise: OSError, ValueError, TypeError\n    \"\"\"\n    # Set file times using Last-Modified and Date headers from the response\n    last_modified = headers.get(\"Last-Modified\")\n    date_header = headers.get(\"Date\")\n    # Prefer Last-Modified for modification time\n    mtime = email.utils.parsedate_to_datetime(last_modified).timestamp() if last_modified else None\n    # Use Date for creation time\n    ctime = email.utils.parsedate_to_datetime(date_header).timestamp() if date_header else None\n    # Set times if available\n    if mtime or ctime:\n        atime = mtime or ctime  # Access time can be the same as modification time\n        os.utime(path, (atime, mtime or ctime))\n</code></pre>"},{"location":"api/#ktoolbox.downloader.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.downloader.base.__all__","title":"<code>__all__ = ['DownloaderRet']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.base.DownloaderRet","title":"<code>DownloaderRet</code>","text":"<p>               Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/downloader/base.py</code> <pre><code>class DownloaderRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader","title":"<code>downloader</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.__all__","title":"<code>__all__ = ['Downloader']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader","title":"<code>Downloader</code>","text":"<p>Attributes:</p> Name Type Description Default <code>_save_filename</code> <p>The actual filename for saving.</p> <code>                       designated_filename               </code> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>class Downloader:\n    \"\"\"\n    :ivar _save_filename: The actual filename for saving.\n    \"\"\"\n    succeeded_servers: Set[int] = set()\n    failure_servers: Set[int] = set()\n    wait_lock = Lock()\n\n    def __init__(\n            self,\n            url: str,\n            path: Path,\n            client: httpx.AsyncClient,\n            *,\n            buffer_size: int = None,\n            chunk_size: int = None,\n            designated_filename: str = None,\n            server_path: str = None,\n            post: Post = None\n    ):\n        # noinspection GrazieInspection\n        \"\"\"\n        Initialize a file downloader\n\n        - About filename:\n            1. If ``designated_filename`` parameter is set, use it.\n            2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n            3. Else use filename from 'file' part of ``server_path``.\n\n        :param url: Download URL\n        :param path: Directory path to save the file, which needs to be sanitized\n        :param client: HTTPX AsyncClient\n        :param buffer_size: Number of bytes for file I/O buffer\n        :param chunk_size: Number of bytes for chunk of download stream\n        :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n        :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n        it will be used as the save path.\n        :param post: Post object, use for logging.\n        \"\"\"\n\n        self._url = self._initial_url = url\n        self._path = path\n        self._client = client\n        self._buffer_size = buffer_size or config.downloader.buffer_size\n        self._chunk_size = chunk_size or config.downloader.chunk_size\n        self._designated_filename = designated_filename\n        self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n        self._save_filename = designated_filename  # Prioritize the manually specified filename\n        self._post = post\n\n        self._next_subdomain_index = 1\n        self._finished_lock = asyncio.Lock()\n        self._stop: bool = False\n\n    @cached_property\n    def url(self) -&gt; str:\n        \"\"\"Download URL\"\"\"\n        return self._url\n\n    @cached_property\n    def path(self) -&gt; Path:\n        \"\"\"Directory path to save the file\"\"\"\n        return self._path\n\n    @cached_property\n    def client(self) -&gt; httpx.AsyncClient:\n        \"\"\"HTTPX AsyncClient\"\"\"\n        return self._client\n\n    @cached_property\n    def buffer_size(self) -&gt; int:\n        \"\"\"Number of bytes for file I/O buffer\"\"\"\n        return self._buffer_size\n\n    @cached_property\n    def chunk_size(self) -&gt; int:\n        \"\"\"Number of bytes for chunk of download stream\"\"\"\n        return self._chunk_size\n\n    @cached_property\n    def post(self) -&gt; Post:\n        \"\"\"Post that the file belongs to\"\"\"\n        return self._post\n\n    @property\n    def filename(self) -&gt; Optional[str]:\n        \"\"\"Actual filename of the download file\"\"\"\n        return self._save_filename\n\n    @property\n    def finished(self) -&gt; bool:\n        \"\"\"\n        Check if the download finished\n\n        :return: ``False`` if the download **in process**, ``True`` otherwise\n        \"\"\"\n        return not self._finished_lock.locked()\n\n    def cancel(self):\n        \"\"\"\n        Cancel the download\n\n        It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n        \"\"\"\n        self._stop = True\n\n    @tenacity.retry(\n        stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n        wait=wait_fixed(config.downloader.retry_interval),\n        retry=retry_if_result(\n            lambda x: not x and x.code != RetCodeEnum.FileExisted\n        ) | retry_if_exception(\n            lambda x: isinstance(x, httpx.HTTPError)\n        ),\n        before_sleep=lambda x: logger.warning(\n            generate_msg(\n                f\"Retrying ({x.attempt_number})\",\n                file=x.args[0].filename,\n                post_name=x.args[0].post.title if x.args[0].post else None,\n                post_id=x.args[0].post.id if x.args[0].post else None,\n                message=x.outcome.result().message if not x.outcome.failed else None,\n                exception=x.outcome.exception(),\n                url=x.args[0].url\n            )\n        ),\n        reraise=True\n    )\n    async def run(\n            self,\n            *,\n            sync_callable: Callable[[\"Downloader\"], Any] = None,\n            async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n            tqdm_class: Type[std_tqdm] = None,\n            progress: bool = False\n    ) -&gt; DownloaderRet[str]:\n        \"\"\"\n        Start to download\n\n        :param sync_callable: Sync callable for download finished\n        :param async_callable: Async callable for download finished\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        :return: ``DownloaderRet`` which contain the actual output filename\n        :raise CancelledError: Job cancelled\n        \"\"\"\n        # Get filename to check if file exists (First-time duplicate file check)\n        # Check it before request to make progress more efficiency\n        server_relpath = self._server_path[1:]\n        server_relpath_without_params = urlparse(server_relpath).path\n        server_path_filename = unquote(Path(server_relpath_without_params).name)\n        # Priority order can be referenced from the constructor's documentation\n        save_filepath = self._path / (self._save_filename or server_path_filename)\n\n        # Get bucket file path\n        bucket_file_path: Optional[Path] = None\n        if config.downloader.use_bucket:\n            bucket_file_path = config.downloader.bucket_path / server_relpath\n\n        # Check if the file exists\n        file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n        if file_existed:\n            return DownloaderRet(\n                code=RetCodeEnum.FileExisted,\n                message=generate_msg(\n                    ret_msg,\n                    path=save_filepath\n                )\n            )\n\n        tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n        async with self.wait_lock:\n            await asyncio.sleep(1 / config.downloader.tps_limit)\n        async with self._finished_lock:\n            temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n            temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n            async with self._client.stream(\n                    method=\"GET\",\n                    url=config.downloader.reverse_proxy.format(self._url),\n                    follow_redirects=True,\n                    timeout=config.downloader.timeout,\n                    headers={\"Range\": f\"bytes={temp_size}-\"}\n            ) as res:  # type: httpx.Response\n                try:\n                    subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n                except ValueError:\n                    subdomain_index = None\n                if res.status_code == 403:\n                    if subdomain_index is not None:\n                        self.succeeded_servers.discard(subdomain_index)\n                        self.failure_servers.add(subdomain_index)\n                    # try succeeded servers first\n                    subdomain_index = next(iter(self.succeeded_servers), None)\n                    if subdomain_index is None:\n                        subdomain_index = self._next_subdomain_index\n                        # Update self._next_subdomain_index\n                        ## index fallback to 1 when a server after failure_servers has been tried\n                        if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                            self._next_subdomain_index = 1\n                            self.failure_servers.clear()\n                        ## otherwise, increment the index and avoid failure_servers\n                        else:\n                            self._next_subdomain_index += 1\n                            while self._next_subdomain_index in self.failure_servers:\n                                self._next_subdomain_index += 1\n                        msg = \"Download failed, trying next subdomain\"\n                    else:\n                        msg = \"Download failed, trying succeeded subdomains\"\n                    new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                    self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            msg,\n                            nex_subdomain=new_netloc,\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                    self._url = self._initial_url\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            \"Download failed\",\n                            status_code=res.status_code,\n                            filename=save_filepath\n                        )\n                    )\n                else:\n                    if subdomain_index is not None:\n                        self.failure_servers.discard(subdomain_index)\n                        self.succeeded_servers.add(subdomain_index)\n\n                # Get filename for saving and check if file exists (Second-time duplicate file check)\n                # Priority order can be referenced from the constructor's documentation\n                self._save_filename = self._designated_filename or sanitize_filename(\n                    filename_from_headers(res.headers)\n                ) or server_path_filename\n                save_filepath = self._path / self._save_filename\n                file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n                if file_existed:\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,\n                        message=generate_msg(\n                            ret_msg,\n                            path=save_filepath\n                        )\n                    )\n\n                # Download\n                total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n\n                # Check file size filtering if enabled and we have the total size\n                if total_size is not None and (config.job.min_file_size is not None or config.job.max_file_size is not None):\n                    # Check minimum size\n                    if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                        logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                        return DownloaderRet(\n                            code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                            message=generate_msg(\n                                f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                                path=save_filepath\n                            )\n                        )\n\n                    # Check maximum size  \n                    if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                        logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                        return DownloaderRet(\n                            code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                            message=generate_msg(\n                                f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                                path=save_filepath\n                            )\n                        )\n\n                # If no Content-Range header, try to get size from Content-Length\n                if total_size is None:\n                    content_length = res.headers.get(\"Content-Length\")\n                    if content_length:\n                        try:\n                            total_size = int(content_length)\n                            # Apply size filtering with Content-Length\n                            if config.job.min_file_size is not None or config.job.max_file_size is not None:\n                                # Check minimum size\n                                if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                                    return DownloaderRet(\n                                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                        message=generate_msg(\n                                            f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                                            path=save_filepath\n                                        )\n                                    )\n\n                                # Check maximum size  \n                                if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                                    return DownloaderRet(\n                                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                        message=generate_msg(\n                                            f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                                            path=save_filepath\n                                        )\n                                    )\n                        except ValueError:\n                            # Invalid Content-Length, continue with download\n                            pass\n                async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                    chunk_iterator = res.aiter_bytes(self._chunk_size)\n                    t = tqdm_class(\n                        desc=self._save_filename,\n                        total=total_size,\n                        initial=temp_size,\n                        disable=not progress,\n                        unit=\"B\",\n                        unit_scale=True\n                    )\n                    async for chunk in chunk_iterator:\n                        if self._stop:\n                            raise CancelledError\n                        await f.write(chunk)\n                        t.update(len(chunk))  # Update progress bar\n\n            # Download finished\n            if config.downloader.use_bucket:\n                bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n                os.link(temp_filepath, bucket_file_path)\n            final_filepath = self._path / self._save_filename\n            temp_filepath.rename(final_filepath)\n\n            # Set file time from headers\n            if config.downloader.keep_metadata:\n                try:\n                    utime_from_headers(res.headers, final_filepath)\n                except (OSError, ValueError, TypeError) as e:\n                    logger.warning(\n                        generate_msg(\n                            \"Failed to set file time from headers\",\n                            file=self._save_filename,\n                            exception=e\n                        )\n                    )\n\n            # Callbacks\n            if sync_callable:\n                sync_callable(self)\n            if async_callable:\n                await async_callable(self)\n\n            return DownloaderRet(\n                data=self._save_filename\n            ) if self._save_filename else DownloaderRet(\n                code=RetCodeEnum.GeneralFailure,\n                message=generate_msg(\n                    \"Download failed\",\n                    filename=self._designated_filename\n                )\n            )\n\n    __call__ = run\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.__call__","title":"<code>__call__ = run</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.buffer_size","title":"<code>buffer_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for file I/O buffer</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.chunk_size","title":"<code>chunk_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for chunk of download stream</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.client","title":"<code>client: httpx.AsyncClient</code>  <code>cached</code> <code>property</code>","text":"<p>HTTPX AsyncClient</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.failure_servers","title":"<code>failure_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.filename","title":"<code>filename: Optional[str]</code>  <code>property</code>","text":"<p>Actual filename of the download file</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.finished","title":"<code>finished: bool</code>  <code>property</code>","text":"<p>Check if the download finished</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> if the download in process, <code>True</code> otherwise</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.path","title":"<code>path: Path</code>  <code>cached</code> <code>property</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.post","title":"<code>post: Post</code>  <code>cached</code> <code>property</code>","text":"<p>Post that the file belongs to</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.succeeded_servers","title":"<code>succeeded_servers: Set[int] = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.url","title":"<code>url: str</code>  <code>cached</code> <code>property</code>","text":"<p>Download URL</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.wait_lock","title":"<code>wait_lock = Lock()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.__init__","title":"<code>__init__(url, path, client, *, buffer_size=None, chunk_size=None, designated_filename=None, server_path=None, post=None)</code>","text":"<p>Initialize a file downloader</p> <ul> <li>About filename:<ol> <li>If <code>designated_filename</code> parameter is set, use it.</li> <li>Else if <code>Content-Disposition</code> is set in headers, use filename from it.</li> <li>Else use filename from 'file' part of <code>server_path</code>.</li> </ol> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Download URL</p> required <code>path</code> <code>Path</code> <p>Directory path to save the file, which needs to be sanitized</p> required <code>client</code> <code>AsyncClient</code> <p>HTTPX AsyncClient</p> required <code>buffer_size</code> <code>int</code> <p>Number of bytes for file I/O buffer</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>Number of bytes for chunk of download stream</p> <code>None</code> <code>designated_filename</code> <code>str</code> <p>Manually specify the filename for saving, which needs to be sanitized</p> <code>None</code> <code>server_path</code> <code>str</code> <p>Server path of the file. if <code>DownloaderConfiguration.use_bucket</code> enabled,         it will be used as the save path.</p> <code>None</code> <code>post</code> <code>Post</code> <p>Post object, use for logging.</p> <code>None</code> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def __init__(\n        self,\n        url: str,\n        path: Path,\n        client: httpx.AsyncClient,\n        *,\n        buffer_size: int = None,\n        chunk_size: int = None,\n        designated_filename: str = None,\n        server_path: str = None,\n        post: Post = None\n):\n    # noinspection GrazieInspection\n    \"\"\"\n    Initialize a file downloader\n\n    - About filename:\n        1. If ``designated_filename`` parameter is set, use it.\n        2. Else if ``Content-Disposition`` is set in headers, use filename from it.\n        3. Else use filename from 'file' part of ``server_path``.\n\n    :param url: Download URL\n    :param path: Directory path to save the file, which needs to be sanitized\n    :param client: HTTPX AsyncClient\n    :param buffer_size: Number of bytes for file I/O buffer\n    :param chunk_size: Number of bytes for chunk of download stream\n    :param designated_filename: Manually specify the filename for saving, which needs to be sanitized\n    :param server_path: Server path of the file. if ``DownloaderConfiguration.use_bucket`` enabled, \\\n    it will be used as the save path.\n    :param post: Post object, use for logging.\n    \"\"\"\n\n    self._url = self._initial_url = url\n    self._path = path\n    self._client = client\n    self._buffer_size = buffer_size or config.downloader.buffer_size\n    self._chunk_size = chunk_size or config.downloader.chunk_size\n    self._designated_filename = designated_filename\n    self._server_path = server_path  # /hash[:1]/hash2[1:3]/hash\n    self._save_filename = designated_filename  # Prioritize the manually specified filename\n    self._post = post\n\n    self._next_subdomain_index = 1\n    self._finished_lock = asyncio.Lock()\n    self._stop: bool = False\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the download</p> <p>It will raise <code>asyncio.CancelledError</code> in <code>chunk_iterator</code> (writing chunk to file) iteration.</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def cancel(self):\n    \"\"\"\n    Cancel the download\n\n    It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n    \"\"\"\n    self._stop = True\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.run","title":"<code>run(*, sync_callable=None, async_callable=None, tqdm_class=None, progress=False)</code>  <code>async</code>","text":"<p>Start to download</p> <p>Parameters:</p> Name Type Description Default <code>sync_callable</code> <code>Callable[[Downloader], Any]</code> <p>Sync callable for download finished</p> <code>None</code> <code>async_callable</code> <code>Callable[[Downloader], Coroutine]</code> <p>Async callable for download finished</p> <code>None</code> <code>tqdm_class</code> <code>Type[tqdm]</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>False</code> <p>Returns:</p> Type Description <code>DownloaderRet[str]</code> <p><code>DownloaderRet</code> which contain the actual output filename</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>Job cancelled</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>@tenacity.retry(\n    stop=stop_never if config.downloader.retry_stop_never else stop_after_attempt(config.downloader.retry_times),\n    wait=wait_fixed(config.downloader.retry_interval),\n    retry=retry_if_result(\n        lambda x: not x and x.code != RetCodeEnum.FileExisted\n    ) | retry_if_exception(\n        lambda x: isinstance(x, httpx.HTTPError)\n    ),\n    before_sleep=lambda x: logger.warning(\n        generate_msg(\n            f\"Retrying ({x.attempt_number})\",\n            file=x.args[0].filename,\n            post_name=x.args[0].post.title if x.args[0].post else None,\n            post_id=x.args[0].post.id if x.args[0].post else None,\n            message=x.outcome.result().message if not x.outcome.failed else None,\n            exception=x.outcome.exception(),\n            url=x.args[0].url\n        )\n    ),\n    reraise=True\n)\nasync def run(\n        self,\n        *,\n        sync_callable: Callable[[\"Downloader\"], Any] = None,\n        async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n        tqdm_class: Type[std_tqdm] = None,\n        progress: bool = False\n) -&gt; DownloaderRet[str]:\n    \"\"\"\n    Start to download\n\n    :param sync_callable: Sync callable for download finished\n    :param async_callable: Async callable for download finished\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    :return: ``DownloaderRet`` which contain the actual output filename\n    :raise CancelledError: Job cancelled\n    \"\"\"\n    # Get filename to check if file exists (First-time duplicate file check)\n    # Check it before request to make progress more efficiency\n    server_relpath = self._server_path[1:]\n    server_relpath_without_params = urlparse(server_relpath).path\n    server_path_filename = unquote(Path(server_relpath_without_params).name)\n    # Priority order can be referenced from the constructor's documentation\n    save_filepath = self._path / (self._save_filename or server_path_filename)\n\n    # Get bucket file path\n    bucket_file_path: Optional[Path] = None\n    if config.downloader.use_bucket:\n        bucket_file_path = config.downloader.bucket_path / server_relpath\n\n    # Check if the file exists\n    file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n    if file_existed:\n        return DownloaderRet(\n            code=RetCodeEnum.FileExisted,\n            message=generate_msg(\n                ret_msg,\n                path=save_filepath\n            )\n        )\n\n    tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n    async with self.wait_lock:\n        await asyncio.sleep(1 / config.downloader.tps_limit)\n    async with self._finished_lock:\n        temp_filepath = Path(f\"{save_filepath}.{config.downloader.temp_suffix}\")\n        temp_size = temp_filepath.stat().st_size if temp_filepath.exists() else 0\n\n        async with self._client.stream(\n                method=\"GET\",\n                url=config.downloader.reverse_proxy.format(self._url),\n                follow_redirects=True,\n                timeout=config.downloader.timeout,\n                headers={\"Range\": f\"bytes={temp_size}-\"}\n        ) as res:  # type: httpx.Response\n            try:\n                subdomain_index = int(res.url.netloc.split(b\".\")[0][1:])\n            except ValueError:\n                subdomain_index = None\n            if res.status_code == 403:\n                if subdomain_index is not None:\n                    self.succeeded_servers.discard(subdomain_index)\n                    self.failure_servers.add(subdomain_index)\n                # try succeeded servers first\n                subdomain_index = next(iter(self.succeeded_servers), None)\n                if subdomain_index is None:\n                    subdomain_index = self._next_subdomain_index\n                    # Update self._next_subdomain_index\n                    ## index fallback to 1 when a server after failure_servers has been tried\n                    if self.failure_servers and self._next_subdomain_index &gt; max(self.failure_servers):\n                        self._next_subdomain_index = 1\n                        self.failure_servers.clear()\n                    ## otherwise, increment the index and avoid failure_servers\n                    else:\n                        self._next_subdomain_index += 1\n                        while self._next_subdomain_index in self.failure_servers:\n                            self._next_subdomain_index += 1\n                    msg = \"Download failed, trying next subdomain\"\n                else:\n                    msg = \"Download failed, trying succeeded subdomains\"\n                new_netloc = f\"n{subdomain_index}.{config.api.files_netloc}\"\n                self._url = str(res.url.copy_with(netloc=new_netloc.encode()))\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        msg,\n                        nex_subdomain=new_netloc,\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            elif res.status_code != httpx.codes.PARTIAL_CONTENT:\n                self._url = self._initial_url\n                return DownloaderRet(\n                    code=RetCodeEnum.GeneralFailure,\n                    message=generate_msg(\n                        \"Download failed\",\n                        status_code=res.status_code,\n                        filename=save_filepath\n                    )\n                )\n            else:\n                if subdomain_index is not None:\n                    self.failure_servers.discard(subdomain_index)\n                    self.succeeded_servers.add(subdomain_index)\n\n            # Get filename for saving and check if file exists (Second-time duplicate file check)\n            # Priority order can be referenced from the constructor's documentation\n            self._save_filename = self._designated_filename or sanitize_filename(\n                filename_from_headers(res.headers)\n            ) or server_path_filename\n            save_filepath = self._path / self._save_filename\n            file_existed, ret_msg = duplicate_file_check(save_filepath, bucket_file_path)\n            if file_existed:\n                return DownloaderRet(\n                    code=RetCodeEnum.FileExisted,\n                    message=generate_msg(\n                        ret_msg,\n                        path=save_filepath\n                    )\n                )\n\n            # Download\n            total_size = int(range_str.split(\"/\")[-1]) if (range_str := res.headers.get(\"Content-Range\")) else None\n\n            # Check file size filtering if enabled and we have the total size\n            if total_size is not None and (config.job.min_file_size is not None or config.job.max_file_size is not None):\n                # Check minimum size\n                if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                        message=generate_msg(\n                            f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                            path=save_filepath\n                        )\n                    )\n\n                # Check maximum size  \n                if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                    logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                    return DownloaderRet(\n                        code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                        message=generate_msg(\n                            f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                            path=save_filepath\n                        )\n                    )\n\n            # If no Content-Range header, try to get size from Content-Length\n            if total_size is None:\n                content_length = res.headers.get(\"Content-Length\")\n                if content_length:\n                    try:\n                        total_size = int(content_length)\n                        # Apply size filtering with Content-Length\n                        if config.job.min_file_size is not None or config.job.max_file_size is not None:\n                            # Check minimum size\n                            if config.job.min_file_size is not None and total_size &lt; config.job.min_file_size:\n                                logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - below minimum size {config.job.min_file_size}\")\n                                return DownloaderRet(\n                                    code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                    message=generate_msg(\n                                        f\"File skipped due to size filtering (size: {total_size} bytes, below minimum: {config.job.min_file_size})\",\n                                        path=save_filepath\n                                    )\n                                )\n\n                            # Check maximum size  \n                            if config.job.max_file_size is not None and total_size &gt; config.job.max_file_size:\n                                logger.debug(f\"Skipping file {self._save_filename} (size: {total_size} bytes) - above maximum size {config.job.max_file_size}\")\n                                return DownloaderRet(\n                                    code=RetCodeEnum.FileExisted,  # Use FileExisted to indicate it was skipped intentionally\n                                    message=generate_msg(\n                                        f\"File skipped due to size filtering (size: {total_size} bytes, above maximum: {config.job.max_file_size})\",\n                                        path=save_filepath\n                                    )\n                                )\n                    except ValueError:\n                        # Invalid Content-Length, continue with download\n                        pass\n            async with aiofiles.open(str(temp_filepath), \"ab\", self._buffer_size) as f:\n                chunk_iterator = res.aiter_bytes(self._chunk_size)\n                t = tqdm_class(\n                    desc=self._save_filename,\n                    total=total_size,\n                    initial=temp_size,\n                    disable=not progress,\n                    unit=\"B\",\n                    unit_scale=True\n                )\n                async for chunk in chunk_iterator:\n                    if self._stop:\n                        raise CancelledError\n                    await f.write(chunk)\n                    t.update(len(chunk))  # Update progress bar\n\n        # Download finished\n        if config.downloader.use_bucket:\n            bucket_file_path.parent.mkdir(parents=True, exist_ok=True)\n            os.link(temp_filepath, bucket_file_path)\n        final_filepath = self._path / self._save_filename\n        temp_filepath.rename(final_filepath)\n\n        # Set file time from headers\n        if config.downloader.keep_metadata:\n            try:\n                utime_from_headers(res.headers, final_filepath)\n            except (OSError, ValueError, TypeError) as e:\n                logger.warning(\n                    generate_msg(\n                        \"Failed to set file time from headers\",\n                        file=self._save_filename,\n                        exception=e\n                    )\n                )\n\n        # Callbacks\n        if sync_callable:\n            sync_callable(self)\n        if async_callable:\n            await async_callable(self)\n\n        return DownloaderRet(\n            data=self._save_filename\n        ) if self._save_filename else DownloaderRet(\n            code=RetCodeEnum.GeneralFailure,\n            message=generate_msg(\n                \"Download failed\",\n                filename=self._designated_filename\n            )\n        )\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.downloader.utils.__all__","title":"<code>__all__ = ['filename_from_headers', 'duplicate_file_check', 'utime_from_headers']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.utils.duplicate_file_check","title":"<code>duplicate_file_check(local_file_path, bucket_file_path=None)</code>","text":"<p>Check if the file existed, and link the bucket filepath to local filepath     if <code>DownloaderConfiguration.use_bucket</code> enabled.</p> <p>Parameters:</p> Name Type Description Default <code>local_file_path</code> <code>Path</code> <p>Download target path</p> required <code>bucket_file_path</code> <code>Path</code> <p>The bucket filepath of the local download path</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str]]</code> <p><code>(if file existed, message)</code></p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def duplicate_file_check(local_file_path: Path, bucket_file_path: Path = None) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"\n    Check if the file existed, and link the bucket filepath to local filepath \\\n    if ``DownloaderConfiguration.use_bucket`` enabled.\n\n    :param local_file_path: Download target path\n    :param bucket_file_path: The bucket filepath of the local download path\n    :return: ``(if file existed, message)``\n    \"\"\"\n    duplicate_check_path = bucket_file_path or local_file_path\n    if duplicate_check_path.is_file():\n        if config.downloader.use_bucket:\n            ret_msg = \"Download file already exists in both bucket and local, skipping\"\n            if not local_file_path.is_file():\n                ret_msg = \"Download file already exists in bucket, linking to local path\"\n                os.link(bucket_file_path, local_file_path)\n        else:\n            ret_msg = \"Download file already exists, skipping\"\n        return True, ret_msg\n    else:\n        return False, None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utils.filename_from_headers","title":"<code>filename_from_headers(headers)</code>","text":"<p>Get file name from headers.</p> <p>Parse from <code>Content-Disposition</code>.</p> <ul> <li> <p>Example: <pre><code>filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8''README%2Emd;filename=\"README.md\"'})\n</code></pre></p> </li> <li> <p>Return: <pre><code>README.md\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP headers</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>File name</p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def filename_from_headers(headers: Dict[str, str]) -&gt; Optional[str]:\n    \"\"\"\n    Get file name from headers.\n\n    Parse from ``Content-Disposition``.\n\n    - Example:\n    ```\n    filename_from_headers({'Content-Disposition': 'attachment;filename*=utf-8\\'\\'README%2Emd;filename=\"README.md\"'})\n    ```\n\n    - Return:\n    ```\n    README.md\n    ```\n\n    :param headers: HTTP headers\n    :return: File name\n    \"\"\"\n    if not (disposition := headers.get(\"Content-Disposition\")):\n        if not (disposition := headers.get(\"content-disposition\")):\n            return None\n    options = parse_header(disposition)  # alternative: `parse_header` in `utils.py`\n    if filename := options.get(\"filename*\"):\n        if len(name_with_charset := filename.split(\"''\")) == 2:\n            charset, name = name_with_charset\n            return urllib.parse.unquote(name, charset)\n    if filename := options.get(\"filename\"):\n        return urllib.parse.unquote(filename, config.downloader.encoding)\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utils.parse_header","title":"<code>parse_header(line)</code>","text":"<p>Alternative resolution for parsing header line.</p> <p>Apply when <code>cgi.parse_header</code> is unable to use due to the deprecation of <code>cgi</code> module.</p> <p>https://peps.python.org/pep-0594/#cgi</p> <ul> <li> <p>Example: <pre><code>parse_header(\"text/html; charset=utf-8\")\n</code></pre></p> </li> <li> <p>Return: <pre><code>{'text/html': None, 'charset': 'utf-8'}\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Header line</p> required <p>Returns:</p> Type Description <code>Dict[str, Optional[str]]</code> <p>Dict of header line</p> Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def parse_header(line: str) -&gt; Dict[str, Optional[str]]:\n    \"\"\"\n    Alternative resolution for parsing header line.\n\n    Apply when ``cgi.parse_header`` is unable to use due to the deprecation of `cgi` module.\n\n    https://peps.python.org/pep-0594/#cgi\n\n    - Example:\n    ```\n    parse_header(\"text/html; charset=utf-8\")\n    ```\n\n    - Return:\n    ```\n    {'text/html': None, 'charset': 'utf-8'}\n    ```\n\n    :param line: Header line\n    :return: Dict of header line\n    \"\"\"\n    dict_value: Dict[str, Optional[str]] = {}\n    for item in line.split(\";\"):\n        if len(pair := item.split(\"=\")) == 1:\n            dict_value[pair[0]] = None\n        elif len(pair) == 2:\n            key, value = pair\n            dict_value.setdefault(key, value)\n    return dict_value\n</code></pre>"},{"location":"api/#ktoolbox.downloader.utils.utime_from_headers","title":"<code>utime_from_headers(headers, path)</code>","text":"<p>Run <code>os.utime</code> on specific file using <code>Last-Modified</code> or <code>Date</code> in HTTP headers.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP Headers</p> required <code>path</code> <code>Union[Path, str]</code> <p>File path</p> required Source code in <code>ktoolbox/downloader/utils.py</code> <pre><code>def utime_from_headers(headers: Dict[str, str], path: Union[Path, str]) -&gt; Optional[Exception]:\n    \"\"\"\n    Run ``os.utime`` on specific file using ``Last-Modified`` or ``Date`` in HTTP headers.\n\n    :param headers: HTTP Headers\n    :param path: File path\n    :raise: OSError, ValueError, TypeError\n    \"\"\"\n    # Set file times using Last-Modified and Date headers from the response\n    last_modified = headers.get(\"Last-Modified\")\n    date_header = headers.get(\"Date\")\n    # Prefer Last-Modified for modification time\n    mtime = email.utils.parsedate_to_datetime(last_modified).timestamp() if last_modified else None\n    # Use Date for creation time\n    ctime = email.utils.parsedate_to_datetime(date_header).timestamp() if date_header else None\n    # Set times if available\n    if mtime or ctime:\n        atime = mtime or ctime  # Access time can be the same as modification time\n        os.utime(path, (atime, mtime or ctime))\n</code></pre>"},{"location":"api/#ktoolbox.editor","title":"<code>editor</code>","text":""},{"location":"api/#ktoolbox.editor.__all__","title":"<code>__all__ = ['EditWithSignalWidget', 'CascadingBoxes', 'run_config_editor']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.default_config","title":"<code>default_config = Configuration(_env_file='')</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.default_config_envs","title":"<code>default_config_envs = set(dump_envs(default_config))</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.initial_envs","title":"<code>initial_envs = set(dump_envs(config))</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.menu_top","title":"<code>menu_top = menu('KToolBox Configuration Editor', [sub_menu('Edit', [sub_menu('API', model_to_widgets(config.api)), sub_menu('Downloader', model_to_widgets(config.downloader)), sub_menu('Job', model_to_widgets(config.job)), sub_menu('Logger', model_to_widgets(config.logger)), urwid.Divider()] + list(model_to_widgets(config, ['ssl_verify', 'json_dump_indent', 'use_uvloop']))), urwid.Divider(), menu_option(urwid.Button('JSON Preview', lambda x: top.open_box(sub_menu_with_menu_widget('JSON Preview', [urwid.Text(config.model_dump_json(indent=4))])[1]))), menu_option(urwid.Button('JSON Preview (Python Mode)', lambda x: top.open_box(sub_menu_with_menu_widget('JSON Preview (Python Serialize Mode)', [urwid.Text(pprint.pformat(config.model_dump(mode='python'), sort_dicts=False))])[1]))), menu_option(urwid.Button('DotEnv Preview (.env / prod.env)', lambda x: top.open_box(sub_menu_with_menu_widget('DotEnv Preview (.env / prod.env)', [urwid.Text('\\n'.join(dump_modified_envs(dump_envs(config))) or 'Same as the default configuration, DotEnv will be left empty.')])[1]))), urwid.Divider(), sub_menu('Save', [menu_option(urwid.Button(\"Save to '.env' / 'prod.env' file\", on_save_dotenv))]), urwid.Divider(bottom=2), menu_option(urwid.Button('Help', lambda x: webbrowser.open('https://ktoolbox.readthedocs.io/latest/configuration/guide/'))), menu_option(urwid.Button('Exit', exit_program)), urwid.Divider(bottom=2), urwid.Text('For detailed information, please refer to https://ktoolbox.readthedocs.io', align=urwid.CENTER), urwid.Divider(), urwid.Text(__version__, align=urwid.CENTER)])</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.top","title":"<code>top = CascadingBoxes(menu_top)</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.CascadingBoxes","title":"<code>CascadingBoxes</code>","text":"<p>               Bases: <code>WidgetPlaceholder</code></p> Source code in <code>ktoolbox/editor.py</code> <pre><code>class CascadingBoxes(urwid.WidgetPlaceholder):\n    max_box_levels = 4\n\n    def __init__(self, box: urwid.Widget) -&gt; None:\n        super().__init__(urwid.SolidFill(\"/\"))\n        self.box_level = 0\n        self.open_box(box)\n\n    def open_box(self, box: urwid.Widget):\n        self.original_widget = urwid.Overlay(\n            urwid.LineBox(\n                urwid.Padding(box, align=urwid.CENTER, left=2, right=2)\n            ),\n            self.original_widget,\n            align=urwid.CENTER,\n            width=(urwid.RELATIVE, 80),\n            valign=urwid.MIDDLE,\n            height=(urwid.RELATIVE, 80),\n            min_width=24,\n            min_height=8,\n            left=self.box_level * 3,\n            right=(self.max_box_levels - self.box_level - 1) * 3,\n            top=self.box_level * 2,\n            bottom=(self.max_box_levels - self.box_level - 1) * 2,\n        )\n        self.box_level += 1\n\n    def back(self) -&gt; Optional[NoReturn]:\n        self.original_widget = self.original_widget[0]\n        self.box_level -= 1\n        return None\n\n    def exit(self):\n        raise urwid.ExitMainLoop()\n\n    def keypress(self, size, key: str) -&gt; Union[str, NoReturn, None]:\n        if key == \"esc\":\n            if self.box_level &gt; 1:\n                self.back()\n            else:\n                exit_program()\n        return super().keypress(size, key)\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.box_level","title":"<code>box_level = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.CascadingBoxes.max_box_levels","title":"<code>max_box_levels = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.CascadingBoxes.__init__","title":"<code>__init__(box)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def __init__(self, box: urwid.Widget) -&gt; None:\n    super().__init__(urwid.SolidFill(\"/\"))\n    self.box_level = 0\n    self.open_box(box)\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.back","title":"<code>back()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def back(self) -&gt; Optional[NoReturn]:\n    self.original_widget = self.original_widget[0]\n    self.box_level -= 1\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.exit","title":"<code>exit()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def exit(self):\n    raise urwid.ExitMainLoop()\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.keypress","title":"<code>keypress(size, key)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def keypress(self, size, key: str) -&gt; Union[str, NoReturn, None]:\n    if key == \"esc\":\n        if self.box_level &gt; 1:\n            self.back()\n        else:\n            exit_program()\n    return super().keypress(size, key)\n</code></pre>"},{"location":"api/#ktoolbox.editor.CascadingBoxes.open_box","title":"<code>open_box(box)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def open_box(self, box: urwid.Widget):\n    self.original_widget = urwid.Overlay(\n        urwid.LineBox(\n            urwid.Padding(box, align=urwid.CENTER, left=2, right=2)\n        ),\n        self.original_widget,\n        align=urwid.CENTER,\n        width=(urwid.RELATIVE, 80),\n        valign=urwid.MIDDLE,\n        height=(urwid.RELATIVE, 80),\n        min_width=24,\n        min_height=8,\n        left=self.box_level * 3,\n        right=(self.max_box_levels - self.box_level - 1) * 3,\n        top=self.box_level * 2,\n        bottom=(self.max_box_levels - self.box_level - 1) * 2,\n    )\n    self.box_level += 1\n</code></pre>"},{"location":"api/#ktoolbox.editor.EditWithSignalWidget","title":"<code>EditWithSignalWidget</code>","text":"<p>               Bases: <code>Edit</code></p> <p>Custom <code>urwid.Edit</code>, support callback when changed.</p> Source code in <code>ktoolbox/editor.py</code> <pre><code>class EditWithSignalWidget(urwid.Edit):\n    \"\"\"\n    Custom ``urwid.Edit``, support callback when changed.\n    \"\"\"\n\n    def __init__(\n            self,\n            *args,\n            on_state_change: Optional[Callable[[EditWithSignalWidget, _T], Any]],\n            user_data: Optional[_T],\n            **kwargs\n    ) -&gt; None:\n        self.__on_state_change = on_state_change\n        self.__user_data = user_data\n        super().__init__(*args, **kwargs)\n\n    def keypress(self, size: Tuple[int], key: str) -&gt; Union[str, None]:\n        ret = super().keypress(size, key)\n        self.__on_state_change(self, self.__user_data)\n        return ret\n</code></pre>"},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.__on_state_change","title":"<code>__on_state_change = on_state_change</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.__user_data","title":"<code>__user_data = user_data</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.__init__","title":"<code>__init__(*args, on_state_change, user_data, **kwargs)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def __init__(\n        self,\n        *args,\n        on_state_change: Optional[Callable[[EditWithSignalWidget, _T], Any]],\n        user_data: Optional[_T],\n        **kwargs\n) -&gt; None:\n    self.__on_state_change = on_state_change\n    self.__user_data = user_data\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/#ktoolbox.editor.EditWithSignalWidget.keypress","title":"<code>keypress(size, key)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def keypress(self, size: Tuple[int], key: str) -&gt; Union[str, None]:\n    ret = super().keypress(size, key)\n    self.__on_state_change(self, self.__user_data)\n    return ret\n</code></pre>"},{"location":"api/#ktoolbox.editor.dump_envs","title":"<code>dump_envs(model)</code>","text":"<p>Dump environment variables, with no Env prefix</p> Source code in <code>ktoolbox/editor.py</code> <pre><code>def dump_envs(model: BaseModel) -&gt; List[str]:\n    \"\"\"Dump environment variables, with no Env prefix\"\"\"\n    envs = []\n    for field in model.model_fields:\n        value = model.__getattribute__(field)\n        if isinstance(value, BaseModel):\n            for env in dump_envs(value):\n                envs.append(f\"{field.upper()}__{env}\")\n        else:\n            envs.append(\n                f\"{field.upper()}=\"\n                f\"{json.dumps(list(value)) if isinstance(value, (list, set, tuple, dict)) else model.__pydantic_serializer__.to_python(value)}\"\n            )\n    return envs\n</code></pre>"},{"location":"api/#ktoolbox.editor.dump_modified_envs","title":"<code>dump_modified_envs(envs)</code>","text":"<p>Dump modified environment variables, with Env prefix</p> <p>Parameters:</p> Name Type Description Default <code>envs</code> <code>List[str]</code> <p>Current Envs</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def dump_modified_envs(envs: List[str]) -&gt; List[str]:\n    \"\"\"\n    Dump modified environment variables, with Env prefix\n\n    :param envs: Current Envs\n    \"\"\"\n    return sorted([\n        f\"KTOOLBOX_{env}\" for env in set(envs) - default_config_envs\n    ])\n</code></pre>"},{"location":"api/#ktoolbox.editor.exit_program","title":"<code>exit_program(_=None)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def exit_program(_: urwid.Button = None) -&gt; Optional[NoReturn]:\n    if has_changed():\n        top.open_box(\n            urwid.Filler(\n                urwid.Pile([\n                    urwid.Text(\"Any unsaved changes will be lost. Are you sure you want to EXIT?\"),\n                    urwid.Divider(),\n                    menu_option(urwid.Button(\n                        \"NO\", lambda x: top.back()\n                    )),\n                    menu_option(urwid.Button(\n                        \"YES\", lambda x: top.exit()\n                    )),\n                ])\n            )\n        )\n    else:\n        top.exit()\n</code></pre>"},{"location":"api/#ktoolbox.editor.get_item","title":"<code>get_item(model, field, get_value_callback, widget_list, list_walker)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def get_item(\n        model: BaseModel,\n        field: str,\n        get_value_callback: Callable[[EditWithSignalWidget], Optional[Any]],\n        widget_list: List[urwid.WidgetPlaceholder],\n        list_walker: urwid.ListWalker\n) -&gt; Callable[[str], urwid.WidgetPlaceholder]:\n    def inner(edit_text: str = \"\"):\n        item = urwid.WidgetPlaceholder(urwid.Widget())\n        edit_widget = EditWithSignalWidget(\n            edit_text=edit_text,\n            align=urwid.LEFT,\n            on_state_change=on_item_changed,\n            user_data=(model, field, get_value_callback, widget_list, item)\n        )\n        columns_widget = urwid.Columns([\n            edit_widget,\n            urwid.Divider(),\n            urwid.Divider(),\n            urwid.Button(\n                \"Remove -\",\n                on_remove_item,\n                (model, field, widget_list, item, list_walker)\n            )\n        ])\n        item.original_widget = columns_widget\n        return item\n\n    return inner\n</code></pre>"},{"location":"api/#ktoolbox.editor.get_value","title":"<code>get_value(item_types)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def get_value(item_types: Sequence[type]) -&gt; Callable[[EditWithSignalWidget], Optional[Any]]:\n    def inner(w: EditWithSignalWidget = None):\n        for t in item_types:\n            try:\n                return t(w.get_edit_text()) if w is not None else t()\n            except ValueError:\n                continue\n        return None\n\n    return inner\n</code></pre>"},{"location":"api/#ktoolbox.editor.has_changed","title":"<code>has_changed()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def has_changed() -&gt; bool:\n    return bool(set(dump_envs(config)) - initial_envs)\n</code></pre>"},{"location":"api/#ktoolbox.editor.menu","title":"<code>menu(title, choices)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def menu(\n        title: Union[str, Tuple[Hashable, str], List[Union[str, Tuple[Hashable, str]]]],\n        choices: Iterable[urwid.Widget],\n) -&gt; urwid.ListBox:\n    body = [urwid.Text(title, align=urwid.CENTER), urwid.Divider(), *choices]\n    return urwid.ListBox(urwid.SimpleFocusListWalker(body))\n</code></pre>"},{"location":"api/#ktoolbox.editor.menu_option","title":"<code>menu_option(widget)</code>","text":"<p>Return <code>focus_map=\"reversed\"</code> Widget</p> Source code in <code>ktoolbox/editor.py</code> <pre><code>def menu_option(widget: urwid.Widget) -&gt; urwid.AttrMap:\n    \"\"\"Return ``focus_map=\"reversed\"`` Widget\"\"\"\n    return urwid.AttrMap(widget, None, focus_map=\"reversed\")\n</code></pre>"},{"location":"api/#ktoolbox.editor.model_to_widgets","title":"<code>model_to_widgets(model, fields=None)</code>","text":"<p>Generate urwid widgets for Pydantic model</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>Pydantic model</p> required <code>fields</code> <code>Iterable[str]</code> <p>Only generate for these fields, default to all fields.</p> <code>None</code> Source code in <code>ktoolbox/editor.py</code> <pre><code>def model_to_widgets(model: BaseModel, fields: Iterable[str] = None) -&gt; Generator[urwid.Widget, Any, None]:\n    \"\"\"\n    Generate urwid widgets for Pydantic model\n\n    :param model: Pydantic model\n    :param fields: Only generate for these fields, default to all fields.\n    \"\"\"\n    for field, field_info in model.model_fields.items():\n        if fields is not None and field not in fields:\n            continue\n        origin_annotation = getattr(field_info.annotation, '__origin__', None)\n        annotation = get_args(field_info.annotation) if origin_annotation is Union else [field_info.annotation]\n\n        if origin_annotation is Literal:\n            radio_buttons = []\n            for value in get_args(field_info.annotation):\n                menu_option(urwid.RadioButton(\n                    radio_buttons,\n                    str(value),\n                    model.__getattribute__(field) == value,\n                    on_radio_button_change,\n                    (model, field, value)\n                ))\n            yield sub_menu(field, radio_buttons)\n        elif bool in annotation:\n            yield menu_option(urwid.CheckBox(\n                field,\n                model.__getattribute__(field),\n                on_state_change=on_checkbox_change,\n                user_data=(model, field)\n            ))\n        elif any(map(lambda x: x in annotation, [str, int, float, Path])):\n            yield menu_option(urwid.Columns([\n                urwid.Text(f\"{' ' * 4}{field}\", align=urwid.LEFT),\n                EditWithSignalWidget(\n                    edit_text=str(model.__getattribute__(field)),\n                    align=urwid.RIGHT,\n                    on_state_change=on_edit_change,\n                    user_data=(model, field, annotation)\n                )\n            ]))\n        elif origin_annotation in [list, set, tuple]:\n            item_types = get_args(field_info.annotation)\n            widget_list = []\n            widget, menu_widget = sub_menu_with_menu_widget(field, [])\n            list_walker: urwid.SimpleFocusListWalker = menu_widget.body  # type: ignore\n            widget_list.extend([\n                get_item(model, field, get_value(item_types), widget_list, list_walker)\n                (str(existed)) for existed in model.__getattribute__(field)\n            ])\n            # noinspection PyTypeChecker\n            option_widget = menu_option(\n                urwid.Button(\n                    \"Add +\",\n                    on_add_item,\n                    (\n                        model,\n                        field,\n                        get_value(item_types),\n                        widget_list,\n                        get_item(model, field, get_value(item_types), widget_list, list_walker),\n                        list_walker\n                    )\n                )\n            )\n            list_walker.extend([urwid.Divider(), option_widget, urwid.Divider()])\n            list_walker.extend(widget_list)\n            yield widget\n        elif isinstance(field_info.annotation, ModelMetaclass):\n            yield sub_menu(field, model_to_widgets(model.__getattribute__(field)))\n        else:\n            yield sub_menu(\n                field,\n                [urwid.Text(\n                    f\"This option ({repr(field_info.annotation)}) is currently not supported for editing in \"\n                    \"the graphical interface; please edit it in the '.env' or 'prod.env' file in the working directory.\"\n                )]\n            )\n    yield urwid.Divider()\n    yield menu_option(urwid.Button(\n        f\"View Document: {type(model).__name__}\", lambda x: webbrowser.open(\n            f\"https://ktoolbox.readthedocs.io/latest/configuration/reference/#ktoolbox.configuration.{type(model).__name__}\"\n        )\n    ))\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_add_item","title":"<code>on_add_item(_, user_data)</code>","text":"<p>Call when add item to List/Set/Tuple field</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Button</code> <p>Widget</p> required <code>user_data</code> <code>Tuple[BaseModel, str, Callable[[], Optional[Any]], Union[List[_T], List[None]], Callable[[], _T], Union[MonitoredFocusList[_T], ListWalker]]</code> <p>(model, field, () -&gt; (default value), item list, () -&gt; (new item), menu widget)</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_add_item(\n        _: urwid.Button,\n        user_data: Tuple[\n            BaseModel,\n            str,\n            Callable[[], Optional[Any]],\n            Union[List[_T], List[None]],\n            Callable[[], _T],\n            Union[urwid.MonitoredFocusList[_T], urwid.ListWalker]\n        ]\n):\n    \"\"\"\n    Call when add item to List/Set/Tuple field\n\n    :param _: Widget\n    :param user_data: (model, field, () -&gt; (default value), item list, () -&gt; (new item), menu widget)\n    \"\"\"\n    model, field, get_default, item_list, get_new_widget, widget = user_data\n    values = list(model.__getattribute__(field))\n    values.append(get_default())\n    model.__setattr__(field, values)\n    new_widget = get_new_widget()\n    item_list.append(new_widget)\n    widget.append(new_widget)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_checkbox_change","title":"<code>on_checkbox_change(_, state, user_data)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_checkbox_change(_: urwid.CheckBox, state: bool, user_data: Tuple[BaseModel, str]):\n    model, field = user_data\n    model.__setattr__(field, state)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_edit_change","title":"<code>on_edit_change(widget, user_data)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_edit_change(widget: urwid.EditWithSignalWidget, user_data: Tuple[BaseModel, str, Iterable[type]]):\n    model, field, annotation = user_data\n    for field_type in annotation:\n        try:\n            model.__setattr__(field, field_type(widget.get_edit_text()))\n        except ValueError:\n            continue\n        else:\n            break\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_item_changed","title":"<code>on_item_changed(widget, user_data)</code>","text":"<p>Call when List/Set/Tuple field item changed</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>EditWithSignalWidget</code> <p>Widget</p> required <code>user_data</code> <code>Tuple[BaseModel, str, Callable[[EditWithSignalWidget], Any], Union[List[_T], List[None]], _T]</code> <p>(model, field, (edit widget) -&gt; (value), item list, item)</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_item_changed(\n        widget: EditWithSignalWidget,\n        user_data: Tuple[\n            BaseModel,\n            str,\n            Callable[[EditWithSignalWidget], Any],\n            Union[List[_T], List[None]],\n            _T\n        ]\n):\n    \"\"\"\n    Call when List/Set/Tuple field item changed\n\n    :param widget: Widget\n    :param user_data: (model, field, (edit widget) -&gt; (value), item list, item)\n    \"\"\"\n    model, field, get_value_callback, item_list, item = user_data\n    values = list(model.__getattribute__(field))\n    index = item_list.index(item)\n    values[index] = get_value_callback(widget)\n    model.__setattr__(field, values)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_radio_button_change","title":"<code>on_radio_button_change(_, state, user_data)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_radio_button_change(_: urwid.RadioButton, state: bool, user_data: Tuple[BaseModel, str, Any]):\n    if state:\n        model, field, value = user_data\n        model.__setattr__(field, value)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_remove_item","title":"<code>on_remove_item(_, user_data)</code>","text":"<p>Call when remove item to List/Set/Tuple field</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Button</code> <p>Widget</p> required <code>user_data</code> <code>Tuple[BaseModel, str, Union[List[_T], List[None]], _T, Union[MonitoredFocusList[_T], ListWalker]]</code> <p>(model, field, item list, item, menu widget)</p> required Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_remove_item(\n        _: urwid.Button,\n        user_data: Tuple[\n            BaseModel,\n            str,\n            Union[List[_T], List[None]],\n            _T,\n            Union[urwid.MonitoredFocusList[_T], urwid.ListWalker]\n        ]\n):\n    \"\"\"\n    Call when remove item to List/Set/Tuple field\n\n    :param _: Widget\n    :param user_data: (model, field, item list, item, menu widget)\n    \"\"\"\n    model, field, item_list, item, widget = user_data\n    values = list(model.__getattribute__(field))\n    index = item_list.index(item)\n    values.pop(index)\n    model.__setattr__(field, values)\n    item_list.pop(index)\n    widget.remove(item)\n</code></pre>"},{"location":"api/#ktoolbox.editor.on_save_dotenv","title":"<code>on_save_dotenv(_)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def on_save_dotenv(_: urwid.Button):\n    if has_changed():\n        pile = urwid.Pile([\n            urwid.Text(\"Your changes have been saved.\"),\n            urwid.Divider(),\n            menu_option(urwid.Button(\n                \"OK\", lambda x: top.back()\n            )),\n        ])\n        try:\n            save_dotenv()\n        except Exception as e:\n            pile = urwid.Pile([\n                urwid.Text(\"Unable to save changes!\"),\n                urwid.Divider(),\n                urwid.Text(f\"{type(e).__name__}: {e}\"),\n                urwid.Divider(),\n                menu_option(urwid.Button(\n                    \"OK\", lambda x: top.back()\n                )),\n            ])\n    else:\n        pile = urwid.Pile([\n            urwid.Text(\"Nothing has changed, no need to save.\"),\n            urwid.Divider(),\n            menu_option(urwid.Button(\n                \"OK\", lambda x: top.back()\n            )),\n        ])\n    top.open_box(urwid.Filler(pile))\n</code></pre>"},{"location":"api/#ktoolbox.editor.run_config_editor","title":"<code>run_config_editor()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def run_config_editor():\n    urwid.MainLoop(top, palette=[(\"reversed\", \"standout\", \"\")]).run()\n</code></pre>"},{"location":"api/#ktoolbox.editor.save_dotenv","title":"<code>save_dotenv()</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def save_dotenv():\n    current_envs = dump_envs(config)\n    envs_to_dump = \"\\n\".join(dump_modified_envs(current_envs))\n    prod_dotenv_path = Path(\"prod.env\")\n    dotenv_path = Path(\".env\")\n    if prod_dotenv_path.is_file():\n        with prod_dotenv_path.open(\"w\") as f:\n            f.write(envs_to_dump)\n    else:\n        with dotenv_path.open(\"w\") as f:\n            f.write(envs_to_dump)\n    initial_envs.clear()\n    initial_envs.update(current_envs)\n</code></pre>"},{"location":"api/#ktoolbox.editor.sub_menu","title":"<code>sub_menu(caption, choices)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def sub_menu(\n        caption: Union[str, Tuple[Hashable, str], List[Union[str, Tuple[Hashable, str]]]],\n        choices: Iterable[urwid.Widget],\n) -&gt; urwid.AttrMap[urwid.Button]:\n    button, _ = sub_menu_with_menu_widget(caption, choices)\n    return button\n</code></pre>"},{"location":"api/#ktoolbox.editor.sub_menu_with_menu_widget","title":"<code>sub_menu_with_menu_widget(caption, choices)</code>","text":"Source code in <code>ktoolbox/editor.py</code> <pre><code>def sub_menu_with_menu_widget(\n        caption: Union[str, Tuple[Hashable, str], List[Union[str, Tuple[Hashable, str]]]],\n        choices: Iterable[urwid.Widget],\n) -&gt; Tuple[urwid.AttrMap[urwid.Button], urwid.ListBox]:\n    contents = menu(\n        caption,\n        list(choices) + [\n            urwid.Divider(bottom=2),\n            menu_option(urwid.Button(\n                \"Back\", lambda x: top.back()\n            ))\n        ]\n    )\n\n    return menu_option(urwid.Button(\n        [caption, \"...\"],\n        lambda x: top.open_box(contents)\n    )), contents\n</code></pre>"},{"location":"api/#ktoolbox.job","title":"<code>job</code>","text":""},{"location":"api/#ktoolbox.job.CreatorIndices","title":"<code>CreatorIndices</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Creator directory indices model</p> <p>Record the path of each downloaded post.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class CreatorIndices(BaseKToolBoxData):\n    \"\"\"\n    Creator directory indices model\n\n    Record the path of each downloaded post.\n    \"\"\"\n    creator_id: str\n    \"\"\"Creator ID\"\"\"\n    service: str\n    \"\"\"Creator service\"\"\"\n    posts: Dict[str, Post] = {}\n    \"\"\"All posts, ``id`` -&gt; ``Post``\"\"\"\n    posts_path: Dict[str, Path] = {}\n    \"\"\"Posts and their path, ``id`` -&gt; ``Path``\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.CreatorIndices.creator_id","title":"<code>creator_id: str</code>  <code>instance-attribute</code>","text":"<p>Creator ID</p>"},{"location":"api/#ktoolbox.job.CreatorIndices.posts","title":"<code>posts: Dict[str, Post] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All posts, <code>id</code> -&gt; <code>Post</code></p>"},{"location":"api/#ktoolbox.job.CreatorIndices.posts_path","title":"<code>posts_path: Dict[str, Path] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Posts and their path, <code>id</code> -&gt; <code>Path</code></p>"},{"location":"api/#ktoolbox.job.CreatorIndices.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>Creator service</p>"},{"location":"api/#ktoolbox.job.Job","title":"<code>Job</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Download job model</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class Job(BaseModel):\n    \"\"\"\n    Download job model\n    \"\"\"\n    path: Path\n    \"\"\"Directory path to save the file\"\"\"\n    alt_filename: Optional[str] = None\n    \"\"\"Use this name if no filename given by the server\"\"\"\n    server_path: str\n    \"\"\"The `path` part of download URL\"\"\"\n    type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None\n    \"\"\"Target file type\"\"\"\n    post: Optional[Post] = None\n    \"\"\"Post object\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.Job.alt_filename","title":"<code>alt_filename: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use this name if no filename given by the server</p>"},{"location":"api/#ktoolbox.job.Job.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.job.Job.post","title":"<code>post: Optional[Post] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Post object</p>"},{"location":"api/#ktoolbox.job.Job.server_path","title":"<code>server_path: str</code>  <code>instance-attribute</code>","text":"<p>The <code>path</code> part of download URL</p>"},{"location":"api/#ktoolbox.job.Job.type","title":"<code>type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target file type</p>"},{"location":"api/#ktoolbox.job.JobListData","title":"<code>JobListData</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Download job list data model</p> <p>For saving the list of jobs to disk.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class JobListData(BaseKToolBoxData):\n    \"\"\"\n    Download job list data model\n\n    For saving the list of jobs to disk.\n    \"\"\"\n    jobs: List[Job] = []\n    \"\"\"All jobs\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.JobListData.jobs","title":"<code>jobs: List[Job] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All jobs</p>"},{"location":"api/#ktoolbox.job.JobRunner","title":"<code>JobRunner</code>","text":"Source code in <code>ktoolbox/job/runner.py</code> <pre><code>class JobRunner:\n    def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True,\n                 centralized_progress: bool = True, use_colors: bool = True, use_emojis: bool = True):\n        \"\"\"\n        Create a job runner\n\n        :param job_list: Jobs to initial ``self._job_queue``\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        :param centralized_progress: Use centralized progress manager to prevent display chaos\n        :param use_colors: Enable colorful progress bars (requires ANSI terminal support)\n        :param use_emojis: Enable emoji indicators in progress bars\n        \"\"\"\n        job_list = job_list or []\n        self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n        for job in job_list:\n            self._job_queue.put_nowait(job)\n\n        # Initialize progress management\n        self._progress = progress\n        self._centralized_progress = centralized_progress and progress\n\n        if self._centralized_progress:\n            # Use centralized progress manager with enhanced visuals\n            self._progress_manager = ProgressManager(\n                max_workers=config.job.count,\n                use_colors=use_colors,\n                use_emojis=use_emojis\n            )\n            self._tqdm_class = tqdm_class or create_managed_tqdm_class(self._progress_manager)\n        else:\n            # Use traditional tqdm\n            self._progress_manager = None\n            self._tqdm_class = tqdm_class\n\n        self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n        self._concurrent_tasks: Set[asyncio.Task] = set()\n        self._lock = asyncio.Lock()\n        self._total_jobs_count = len(job_list)\n\n    @property\n    def finished(self):\n        \"\"\"\n        Check if all jobs finished\n\n        :return: ``False`` if **in process**, ``False`` otherwise\n        \"\"\"\n        return not self._lock.locked()\n\n    @cached_property\n    def downloaders(self):\n        \"\"\"Get downloaders with task\"\"\"\n        return MappingProxyType(self._downloaders_with_task)\n\n    @property\n    def waiting_size(self) -&gt; int:\n        \"\"\"Get the number of jobs waiting to be processed\"\"\"\n        return self._job_queue.qsize()\n\n    @property\n    def done_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that done\"\"\"\n        size = 0\n        for downloader, task in self._downloaders_with_task.items():\n            if downloader.finished or task.done():\n                size += 1\n        return size\n\n    @property\n    def processing_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that in process\"\"\"\n        return len(self._downloaders_with_task) - self.done_size\n\n    async def processor(self) -&gt; int:\n        \"\"\"\n        Process each job in ``self._job_queue``\n\n        :return: Number of jobs that failed\n        \"\"\"\n        failed_num = 0\n        async with httpx.AsyncClient(\n                verify=config.ssl_verify,\n                cookies={\"session\": config.api.session_key} if config.api.session_key else None\n        ) as client:\n            while not self._job_queue.empty():\n                job = await self._job_queue.get()\n\n                # Create downloader\n                url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n                url = str(urlunparse(url_parts))\n                downloader = Downloader(\n                    url=url,\n                    path=job.path,\n                    client=client,\n                    designated_filename=job.alt_filename,\n                    server_path=job.server_path,\n                    post=job.post\n                )\n\n                # Create task\n                task = asyncio.create_task(\n                    downloader.run(\n                        tqdm_class=self._tqdm_class,\n                        progress=self._progress\n                    )\n                )\n                self._downloaders_with_task[downloader] = task\n                # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n                #   Delete this for counting finished job tasks\n\n                # Run task\n                task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n                task_done = task_done_set.pop()\n                try:\n                    exception = task_done.exception()\n                except CancelledError as e:\n                    exception = e\n                if not exception:  # raise Exception when cancelled or other exceptions\n                    ret = task_done.result()\n                    if ret.code == RetCodeEnum.FileExisted:\n                        logger.debug(ret.message)\n                        # Treat file existed as successful download but mark as existed\n                        if self._progress_manager:\n                            # Increment existed count atomically and update completed based on current done_size\n                            try:\n                                self._progress_manager.increment_existed(1)\n                            except AttributeError:\n                                # Fallback if older ProgressManager doesn't have increment_existed\n                                self._progress_manager.update_job_progress(\n                                    existed=self._progress_manager._existed_jobs + 1\n                                )\n                            self._progress_manager.update_job_progress(\n                                completed=self.done_size\n                            )\n                    elif ret.code != RetCodeEnum.Success:\n                        logger.error(ret.message)\n                        failed_num += 1\n                        # Update progress manager with failed job\n                        if self._progress_manager:\n                            self._progress_manager.update_job_progress(\n                                failed=failed_num\n                            )\n                    else:\n                        # Update progress manager with completed job\n                        if self._progress_manager:\n                            self._progress_manager.update_job_progress(\n                                completed=self.done_size\n                            )\n                elif isinstance(exception, CancelledError):\n                    logger.warning(\n                        generate_msg(\n                            \"Download cancelled\",\n                            filename=job.alt_filename\n                        )\n                    )\n                else:\n                    logger.error(\n                        generate_msg(\n                            \"Download failed\",\n                            filename=job.alt_filename,\n                            exception=exception\n                        )\n                    )\n                    failed_num += 1\n                    # Update progress manager with failed job\n                    if self._progress_manager:\n                        self._progress_manager.update_job_progress(\n                            failed=failed_num\n                        )\n                self._job_queue.task_done()\n        await self._job_queue.join()\n        return failed_num\n\n    async def _watch_status(self):\n        \"\"\"\n        Watch running, completed, failed jobs\n        \"\"\"\n        try:\n            while not self._job_queue.empty():\n                await asyncio.sleep(30)\n                existed = self._progress_manager._existed_jobs if self._progress_manager else 0\n                total = (self.waiting_size + self.processing_size + self.done_size)\n                percent = (self.done_size / total) * 100 if total &gt; 0 else 0\n                logger.info(\n                    f\"Waiting: {self.waiting_size} / \"\n                    f\"Running: {self.processing_size} / \"\n                    f\"Completed: {self.done_size} \"\n                    f\"({percent:.2f}%) | Existed: {existed}\"\n                )\n        except asyncio.CancelledError:\n            # Exit promptly when cancelled to allow fast shutdown\n            return\n\n    async def start(self) -&gt; int:\n        \"\"\"\n        Start processing jobs concurrently\n\n        It will **Block** until other call of ``self.start()`` method finished\n\n        :return: Number of jobs that failed\n        \"\"\"\n        failed_num = 0\n\n        # Initialize progress manager if using centralized progress\n        if self._progress_manager:\n            self._progress_manager.set_job_totals(self._total_jobs_count)\n            self._progress_manager.start_display()\n            # Setup logger integration to work with progress display\n            setup_logger_for_progress(self._progress_manager)\n\n        async with self._lock:\n            self._concurrent_tasks.clear()\n            for _ in range(config.job.count):\n                task = asyncio.create_task(self.processor())\n                self._concurrent_tasks.add(task)\n                task.add_done_callback(self._concurrent_tasks.discard)\n\n            # Start background display update if using centralized progress\n            display_task = None\n            if self._progress_manager:\n                display_task = asyncio.create_task(self._update_display_loop())\n\n            # Start watcher as a background task so we can cancel it promptly when downloads finish\n            watch_task = None\n            if self._progress_manager:\n                watch_task = asyncio.create_task(self._watch_status())\n\n            # Wait for all concurrent processor tasks to finish\n            task_done_set, _ = await asyncio.wait(self._concurrent_tasks)\n\n            # Cancel watcher promptly to avoid waiting for its sleep interval\n            if watch_task:\n                watch_task.cancel()\n                try:\n                    await watch_task\n                except asyncio.CancelledError:\n                    pass\n\n            if display_task:\n                display_task.cancel()\n                try:\n                    await display_task\n                except asyncio.CancelledError:\n                    pass\n\n            for task in task_done_set:\n                try:\n                    failed_num += task.result()\n                except CancelledError:\n                    pass\n\n            # Clean up progress manager\n            if self._progress_manager:\n                self._progress_manager.stop_display()\n                # Remove logger integration\n                setup_logger_for_progress(None)\n\n        if failed_num:\n            logger.warning(f\"{failed_num} jobs failed, download finished\")\n        else:\n            logger.success(\"All jobs in queue finished\")\n        return failed_num\n\n    async def _update_display_loop(self):\n        \"\"\"Background task to update the progress display\"\"\"\n        try:\n            while True:\n                if self._progress_manager:\n                    self._progress_manager.update_display()\n                await asyncio.sleep(0.1)  # Update 10 times per second\n        except asyncio.CancelledError:\n            pass\n\n    async def add_jobs(self, *jobs: Job):\n        \"\"\"Add jobs to ``self._job_queue``\"\"\"\n        for job in jobs:\n            await self._job_queue.put(job)\n\n        # Update total job count for progress tracking\n        self._total_jobs_count += len(jobs)\n        if self._progress_manager:\n            self._progress_manager.set_job_totals(self._total_jobs_count)\n\n    @staticmethod\n    async def _force_cancel(target: asyncio.Task, wait_time: float = None) -&gt; bool:\n        \"\"\"\n        Force cancel ``asyncio.Task`` after ``wait_time`` seconds\n\n        :param target: Target task\n        :param wait_time: Seconds to wait before cancel (``0`` for skip one event loop run cycle)\n        :return: Whether cancelled successfully\n        \"\"\"\n        if wait_time is not None:\n            await asyncio.sleep(wait_time)\n        return target.cancel()\n\n    async def cancel_downloader(self, target: Downloader) -&gt; bool:\n        \"\"\"\n        Cancel downloader\n\n        :return: Whether cancelled successfully\n        \"\"\"\n        task = self._downloaders_with_task[target]\n        if not task.done():\n            target.cancel()\n            return await self._force_cancel(task, 0) or task.done()\n        return True\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.done_size","title":"<code>done_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that done</p>"},{"location":"api/#ktoolbox.job.JobRunner.downloaders","title":"<code>downloaders</code>  <code>cached</code> <code>property</code>","text":"<p>Get downloaders with task</p>"},{"location":"api/#ktoolbox.job.JobRunner.finished","title":"<code>finished</code>  <code>property</code>","text":"<p>Check if all jobs finished</p> <p>Returns:</p> Type Description <p><code>False</code> if in process, <code>False</code> otherwise</p>"},{"location":"api/#ktoolbox.job.JobRunner.processing_size","title":"<code>processing_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that in process</p>"},{"location":"api/#ktoolbox.job.JobRunner.waiting_size","title":"<code>waiting_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs waiting to be processed</p>"},{"location":"api/#ktoolbox.job.JobRunner.__init__","title":"<code>__init__(*, job_list=None, tqdm_class=None, progress=True, centralized_progress=True, use_colors=True, use_emojis=True)</code>","text":"<p>Create a job runner</p> <p>Parameters:</p> Name Type Description Default <code>job_list</code> <code>List[Job]</code> <p>Jobs to initial <code>self._job_queue</code></p> <code>None</code> <code>tqdm_class</code> <code>tqdm</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>True</code> <code>centralized_progress</code> <code>bool</code> <p>Use centralized progress manager to prevent display chaos</p> <code>True</code> <code>use_colors</code> <code>bool</code> <p>Enable colorful progress bars (requires ANSI terminal support)</p> <code>True</code> <code>use_emojis</code> <code>bool</code> <p>Enable emoji indicators in progress bars</p> <code>True</code> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True,\n             centralized_progress: bool = True, use_colors: bool = True, use_emojis: bool = True):\n    \"\"\"\n    Create a job runner\n\n    :param job_list: Jobs to initial ``self._job_queue``\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    :param centralized_progress: Use centralized progress manager to prevent display chaos\n    :param use_colors: Enable colorful progress bars (requires ANSI terminal support)\n    :param use_emojis: Enable emoji indicators in progress bars\n    \"\"\"\n    job_list = job_list or []\n    self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n    for job in job_list:\n        self._job_queue.put_nowait(job)\n\n    # Initialize progress management\n    self._progress = progress\n    self._centralized_progress = centralized_progress and progress\n\n    if self._centralized_progress:\n        # Use centralized progress manager with enhanced visuals\n        self._progress_manager = ProgressManager(\n            max_workers=config.job.count,\n            use_colors=use_colors,\n            use_emojis=use_emojis\n        )\n        self._tqdm_class = tqdm_class or create_managed_tqdm_class(self._progress_manager)\n    else:\n        # Use traditional tqdm\n        self._progress_manager = None\n        self._tqdm_class = tqdm_class\n\n    self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n    self._concurrent_tasks: Set[asyncio.Task] = set()\n    self._lock = asyncio.Lock()\n    self._total_jobs_count = len(job_list)\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.add_jobs","title":"<code>add_jobs(*jobs)</code>  <code>async</code>","text":"<p>Add jobs to <code>self._job_queue</code></p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def add_jobs(self, *jobs: Job):\n    \"\"\"Add jobs to ``self._job_queue``\"\"\"\n    for job in jobs:\n        await self._job_queue.put(job)\n\n    # Update total job count for progress tracking\n    self._total_jobs_count += len(jobs)\n    if self._progress_manager:\n        self._progress_manager.set_job_totals(self._total_jobs_count)\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.cancel_downloader","title":"<code>cancel_downloader(target)</code>  <code>async</code>","text":"<p>Cancel downloader</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether cancelled successfully</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def cancel_downloader(self, target: Downloader) -&gt; bool:\n    \"\"\"\n    Cancel downloader\n\n    :return: Whether cancelled successfully\n    \"\"\"\n    task = self._downloaders_with_task[target]\n    if not task.done():\n        target.cancel()\n        return await self._force_cancel(task, 0) or task.done()\n    return True\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.processor","title":"<code>processor()</code>  <code>async</code>","text":"<p>Process each job in <code>self._job_queue</code></p> <p>Returns:</p> Type Description <code>int</code> <p>Number of jobs that failed</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def processor(self) -&gt; int:\n    \"\"\"\n    Process each job in ``self._job_queue``\n\n    :return: Number of jobs that failed\n    \"\"\"\n    failed_num = 0\n    async with httpx.AsyncClient(\n            verify=config.ssl_verify,\n            cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    ) as client:\n        while not self._job_queue.empty():\n            job = await self._job_queue.get()\n\n            # Create downloader\n            url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n            url = str(urlunparse(url_parts))\n            downloader = Downloader(\n                url=url,\n                path=job.path,\n                client=client,\n                designated_filename=job.alt_filename,\n                server_path=job.server_path,\n                post=job.post\n            )\n\n            # Create task\n            task = asyncio.create_task(\n                downloader.run(\n                    tqdm_class=self._tqdm_class,\n                    progress=self._progress\n                )\n            )\n            self._downloaders_with_task[downloader] = task\n            # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n            #   Delete this for counting finished job tasks\n\n            # Run task\n            task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n            task_done = task_done_set.pop()\n            try:\n                exception = task_done.exception()\n            except CancelledError as e:\n                exception = e\n            if not exception:  # raise Exception when cancelled or other exceptions\n                ret = task_done.result()\n                if ret.code == RetCodeEnum.FileExisted:\n                    logger.debug(ret.message)\n                    # Treat file existed as successful download but mark as existed\n                    if self._progress_manager:\n                        # Increment existed count atomically and update completed based on current done_size\n                        try:\n                            self._progress_manager.increment_existed(1)\n                        except AttributeError:\n                            # Fallback if older ProgressManager doesn't have increment_existed\n                            self._progress_manager.update_job_progress(\n                                existed=self._progress_manager._existed_jobs + 1\n                            )\n                        self._progress_manager.update_job_progress(\n                            completed=self.done_size\n                        )\n                elif ret.code != RetCodeEnum.Success:\n                    logger.error(ret.message)\n                    failed_num += 1\n                    # Update progress manager with failed job\n                    if self._progress_manager:\n                        self._progress_manager.update_job_progress(\n                            failed=failed_num\n                        )\n                else:\n                    # Update progress manager with completed job\n                    if self._progress_manager:\n                        self._progress_manager.update_job_progress(\n                            completed=self.done_size\n                        )\n            elif isinstance(exception, CancelledError):\n                logger.warning(\n                    generate_msg(\n                        \"Download cancelled\",\n                        filename=job.alt_filename\n                    )\n                )\n            else:\n                logger.error(\n                    generate_msg(\n                        \"Download failed\",\n                        filename=job.alt_filename,\n                        exception=exception\n                    )\n                )\n                failed_num += 1\n                # Update progress manager with failed job\n                if self._progress_manager:\n                    self._progress_manager.update_job_progress(\n                        failed=failed_num\n                    )\n            self._job_queue.task_done()\n    await self._job_queue.join()\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.job.JobRunner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start processing jobs concurrently</p> <p>It will Block until other call of <code>self.start()</code> method finished</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of jobs that failed</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def start(self) -&gt; int:\n    \"\"\"\n    Start processing jobs concurrently\n\n    It will **Block** until other call of ``self.start()`` method finished\n\n    :return: Number of jobs that failed\n    \"\"\"\n    failed_num = 0\n\n    # Initialize progress manager if using centralized progress\n    if self._progress_manager:\n        self._progress_manager.set_job_totals(self._total_jobs_count)\n        self._progress_manager.start_display()\n        # Setup logger integration to work with progress display\n        setup_logger_for_progress(self._progress_manager)\n\n    async with self._lock:\n        self._concurrent_tasks.clear()\n        for _ in range(config.job.count):\n            task = asyncio.create_task(self.processor())\n            self._concurrent_tasks.add(task)\n            task.add_done_callback(self._concurrent_tasks.discard)\n\n        # Start background display update if using centralized progress\n        display_task = None\n        if self._progress_manager:\n            display_task = asyncio.create_task(self._update_display_loop())\n\n        # Start watcher as a background task so we can cancel it promptly when downloads finish\n        watch_task = None\n        if self._progress_manager:\n            watch_task = asyncio.create_task(self._watch_status())\n\n        # Wait for all concurrent processor tasks to finish\n        task_done_set, _ = await asyncio.wait(self._concurrent_tasks)\n\n        # Cancel watcher promptly to avoid waiting for its sleep interval\n        if watch_task:\n            watch_task.cancel()\n            try:\n                await watch_task\n            except asyncio.CancelledError:\n                pass\n\n        if display_task:\n            display_task.cancel()\n            try:\n                await display_task\n            except asyncio.CancelledError:\n                pass\n\n        for task in task_done_set:\n            try:\n                failed_num += task.result()\n            except CancelledError:\n                pass\n\n        # Clean up progress manager\n        if self._progress_manager:\n            self._progress_manager.stop_display()\n            # Remove logger integration\n            setup_logger_for_progress(None)\n\n    if failed_num:\n        logger.warning(f\"{failed_num} jobs failed, download finished\")\n    else:\n        logger.success(\"All jobs in queue finished\")\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.job.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.job.model.__all__","title":"<code>__all__ = ['Job', 'JobListData', 'CreatorIndices']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.job.model.CreatorIndices","title":"<code>CreatorIndices</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Creator directory indices model</p> <p>Record the path of each downloaded post.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class CreatorIndices(BaseKToolBoxData):\n    \"\"\"\n    Creator directory indices model\n\n    Record the path of each downloaded post.\n    \"\"\"\n    creator_id: str\n    \"\"\"Creator ID\"\"\"\n    service: str\n    \"\"\"Creator service\"\"\"\n    posts: Dict[str, Post] = {}\n    \"\"\"All posts, ``id`` -&gt; ``Post``\"\"\"\n    posts_path: Dict[str, Path] = {}\n    \"\"\"Posts and their path, ``id`` -&gt; ``Path``\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.creator_id","title":"<code>creator_id: str</code>  <code>instance-attribute</code>","text":"<p>Creator ID</p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.posts","title":"<code>posts: Dict[str, Post] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All posts, <code>id</code> -&gt; <code>Post</code></p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.posts_path","title":"<code>posts_path: Dict[str, Path] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Posts and their path, <code>id</code> -&gt; <code>Path</code></p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>Creator service</p>"},{"location":"api/#ktoolbox.job.model.Job","title":"<code>Job</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Download job model</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class Job(BaseModel):\n    \"\"\"\n    Download job model\n    \"\"\"\n    path: Path\n    \"\"\"Directory path to save the file\"\"\"\n    alt_filename: Optional[str] = None\n    \"\"\"Use this name if no filename given by the server\"\"\"\n    server_path: str\n    \"\"\"The `path` part of download URL\"\"\"\n    type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None\n    \"\"\"Target file type\"\"\"\n    post: Optional[Post] = None\n    \"\"\"Post object\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.Job.alt_filename","title":"<code>alt_filename: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use this name if no filename given by the server</p>"},{"location":"api/#ktoolbox.job.model.Job.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.job.model.Job.post","title":"<code>post: Optional[Post] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Post object</p>"},{"location":"api/#ktoolbox.job.model.Job.server_path","title":"<code>server_path: str</code>  <code>instance-attribute</code>","text":"<p>The <code>path</code> part of download URL</p>"},{"location":"api/#ktoolbox.job.model.Job.type","title":"<code>type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target file type</p>"},{"location":"api/#ktoolbox.job.model.JobListData","title":"<code>JobListData</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code></p> <p>Download job list data model</p> <p>For saving the list of jobs to disk.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class JobListData(BaseKToolBoxData):\n    \"\"\"\n    Download job list data model\n\n    For saving the list of jobs to disk.\n    \"\"\"\n    jobs: List[Job] = []\n    \"\"\"All jobs\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.JobListData.jobs","title":"<code>jobs: List[Job] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All jobs</p>"},{"location":"api/#ktoolbox.job.runner","title":"<code>runner</code>","text":""},{"location":"api/#ktoolbox.job.runner.__all__","title":"<code>__all__ = ['JobRunner']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.job.runner.JobRunner","title":"<code>JobRunner</code>","text":"Source code in <code>ktoolbox/job/runner.py</code> <pre><code>class JobRunner:\n    def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True,\n                 centralized_progress: bool = True, use_colors: bool = True, use_emojis: bool = True):\n        \"\"\"\n        Create a job runner\n\n        :param job_list: Jobs to initial ``self._job_queue``\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        :param centralized_progress: Use centralized progress manager to prevent display chaos\n        :param use_colors: Enable colorful progress bars (requires ANSI terminal support)\n        :param use_emojis: Enable emoji indicators in progress bars\n        \"\"\"\n        job_list = job_list or []\n        self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n        for job in job_list:\n            self._job_queue.put_nowait(job)\n\n        # Initialize progress management\n        self._progress = progress\n        self._centralized_progress = centralized_progress and progress\n\n        if self._centralized_progress:\n            # Use centralized progress manager with enhanced visuals\n            self._progress_manager = ProgressManager(\n                max_workers=config.job.count,\n                use_colors=use_colors,\n                use_emojis=use_emojis\n            )\n            self._tqdm_class = tqdm_class or create_managed_tqdm_class(self._progress_manager)\n        else:\n            # Use traditional tqdm\n            self._progress_manager = None\n            self._tqdm_class = tqdm_class\n\n        self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n        self._concurrent_tasks: Set[asyncio.Task] = set()\n        self._lock = asyncio.Lock()\n        self._total_jobs_count = len(job_list)\n\n    @property\n    def finished(self):\n        \"\"\"\n        Check if all jobs finished\n\n        :return: ``False`` if **in process**, ``False`` otherwise\n        \"\"\"\n        return not self._lock.locked()\n\n    @cached_property\n    def downloaders(self):\n        \"\"\"Get downloaders with task\"\"\"\n        return MappingProxyType(self._downloaders_with_task)\n\n    @property\n    def waiting_size(self) -&gt; int:\n        \"\"\"Get the number of jobs waiting to be processed\"\"\"\n        return self._job_queue.qsize()\n\n    @property\n    def done_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that done\"\"\"\n        size = 0\n        for downloader, task in self._downloaders_with_task.items():\n            if downloader.finished or task.done():\n                size += 1\n        return size\n\n    @property\n    def processing_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that in process\"\"\"\n        return len(self._downloaders_with_task) - self.done_size\n\n    async def processor(self) -&gt; int:\n        \"\"\"\n        Process each job in ``self._job_queue``\n\n        :return: Number of jobs that failed\n        \"\"\"\n        failed_num = 0\n        async with httpx.AsyncClient(\n                verify=config.ssl_verify,\n                cookies={\"session\": config.api.session_key} if config.api.session_key else None\n        ) as client:\n            while not self._job_queue.empty():\n                job = await self._job_queue.get()\n\n                # Create downloader\n                url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n                url = str(urlunparse(url_parts))\n                downloader = Downloader(\n                    url=url,\n                    path=job.path,\n                    client=client,\n                    designated_filename=job.alt_filename,\n                    server_path=job.server_path,\n                    post=job.post\n                )\n\n                # Create task\n                task = asyncio.create_task(\n                    downloader.run(\n                        tqdm_class=self._tqdm_class,\n                        progress=self._progress\n                    )\n                )\n                self._downloaders_with_task[downloader] = task\n                # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n                #   Delete this for counting finished job tasks\n\n                # Run task\n                task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n                task_done = task_done_set.pop()\n                try:\n                    exception = task_done.exception()\n                except CancelledError as e:\n                    exception = e\n                if not exception:  # raise Exception when cancelled or other exceptions\n                    ret = task_done.result()\n                    if ret.code == RetCodeEnum.FileExisted:\n                        logger.debug(ret.message)\n                        # Treat file existed as successful download but mark as existed\n                        if self._progress_manager:\n                            # Increment existed count atomically and update completed based on current done_size\n                            try:\n                                self._progress_manager.increment_existed(1)\n                            except AttributeError:\n                                # Fallback if older ProgressManager doesn't have increment_existed\n                                self._progress_manager.update_job_progress(\n                                    existed=self._progress_manager._existed_jobs + 1\n                                )\n                            self._progress_manager.update_job_progress(\n                                completed=self.done_size\n                            )\n                    elif ret.code != RetCodeEnum.Success:\n                        logger.error(ret.message)\n                        failed_num += 1\n                        # Update progress manager with failed job\n                        if self._progress_manager:\n                            self._progress_manager.update_job_progress(\n                                failed=failed_num\n                            )\n                    else:\n                        # Update progress manager with completed job\n                        if self._progress_manager:\n                            self._progress_manager.update_job_progress(\n                                completed=self.done_size\n                            )\n                elif isinstance(exception, CancelledError):\n                    logger.warning(\n                        generate_msg(\n                            \"Download cancelled\",\n                            filename=job.alt_filename\n                        )\n                    )\n                else:\n                    logger.error(\n                        generate_msg(\n                            \"Download failed\",\n                            filename=job.alt_filename,\n                            exception=exception\n                        )\n                    )\n                    failed_num += 1\n                    # Update progress manager with failed job\n                    if self._progress_manager:\n                        self._progress_manager.update_job_progress(\n                            failed=failed_num\n                        )\n                self._job_queue.task_done()\n        await self._job_queue.join()\n        return failed_num\n\n    async def _watch_status(self):\n        \"\"\"\n        Watch running, completed, failed jobs\n        \"\"\"\n        try:\n            while not self._job_queue.empty():\n                await asyncio.sleep(30)\n                existed = self._progress_manager._existed_jobs if self._progress_manager else 0\n                total = (self.waiting_size + self.processing_size + self.done_size)\n                percent = (self.done_size / total) * 100 if total &gt; 0 else 0\n                logger.info(\n                    f\"Waiting: {self.waiting_size} / \"\n                    f\"Running: {self.processing_size} / \"\n                    f\"Completed: {self.done_size} \"\n                    f\"({percent:.2f}%) | Existed: {existed}\"\n                )\n        except asyncio.CancelledError:\n            # Exit promptly when cancelled to allow fast shutdown\n            return\n\n    async def start(self) -&gt; int:\n        \"\"\"\n        Start processing jobs concurrently\n\n        It will **Block** until other call of ``self.start()`` method finished\n\n        :return: Number of jobs that failed\n        \"\"\"\n        failed_num = 0\n\n        # Initialize progress manager if using centralized progress\n        if self._progress_manager:\n            self._progress_manager.set_job_totals(self._total_jobs_count)\n            self._progress_manager.start_display()\n            # Setup logger integration to work with progress display\n            setup_logger_for_progress(self._progress_manager)\n\n        async with self._lock:\n            self._concurrent_tasks.clear()\n            for _ in range(config.job.count):\n                task = asyncio.create_task(self.processor())\n                self._concurrent_tasks.add(task)\n                task.add_done_callback(self._concurrent_tasks.discard)\n\n            # Start background display update if using centralized progress\n            display_task = None\n            if self._progress_manager:\n                display_task = asyncio.create_task(self._update_display_loop())\n\n            # Start watcher as a background task so we can cancel it promptly when downloads finish\n            watch_task = None\n            if self._progress_manager:\n                watch_task = asyncio.create_task(self._watch_status())\n\n            # Wait for all concurrent processor tasks to finish\n            task_done_set, _ = await asyncio.wait(self._concurrent_tasks)\n\n            # Cancel watcher promptly to avoid waiting for its sleep interval\n            if watch_task:\n                watch_task.cancel()\n                try:\n                    await watch_task\n                except asyncio.CancelledError:\n                    pass\n\n            if display_task:\n                display_task.cancel()\n                try:\n                    await display_task\n                except asyncio.CancelledError:\n                    pass\n\n            for task in task_done_set:\n                try:\n                    failed_num += task.result()\n                except CancelledError:\n                    pass\n\n            # Clean up progress manager\n            if self._progress_manager:\n                self._progress_manager.stop_display()\n                # Remove logger integration\n                setup_logger_for_progress(None)\n\n        if failed_num:\n            logger.warning(f\"{failed_num} jobs failed, download finished\")\n        else:\n            logger.success(\"All jobs in queue finished\")\n        return failed_num\n\n    async def _update_display_loop(self):\n        \"\"\"Background task to update the progress display\"\"\"\n        try:\n            while True:\n                if self._progress_manager:\n                    self._progress_manager.update_display()\n                await asyncio.sleep(0.1)  # Update 10 times per second\n        except asyncio.CancelledError:\n            pass\n\n    async def add_jobs(self, *jobs: Job):\n        \"\"\"Add jobs to ``self._job_queue``\"\"\"\n        for job in jobs:\n            await self._job_queue.put(job)\n\n        # Update total job count for progress tracking\n        self._total_jobs_count += len(jobs)\n        if self._progress_manager:\n            self._progress_manager.set_job_totals(self._total_jobs_count)\n\n    @staticmethod\n    async def _force_cancel(target: asyncio.Task, wait_time: float = None) -&gt; bool:\n        \"\"\"\n        Force cancel ``asyncio.Task`` after ``wait_time`` seconds\n\n        :param target: Target task\n        :param wait_time: Seconds to wait before cancel (``0`` for skip one event loop run cycle)\n        :return: Whether cancelled successfully\n        \"\"\"\n        if wait_time is not None:\n            await asyncio.sleep(wait_time)\n        return target.cancel()\n\n    async def cancel_downloader(self, target: Downloader) -&gt; bool:\n        \"\"\"\n        Cancel downloader\n\n        :return: Whether cancelled successfully\n        \"\"\"\n        task = self._downloaders_with_task[target]\n        if not task.done():\n            target.cancel()\n            return await self._force_cancel(task, 0) or task.done()\n        return True\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.done_size","title":"<code>done_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that done</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.downloaders","title":"<code>downloaders</code>  <code>cached</code> <code>property</code>","text":"<p>Get downloaders with task</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.finished","title":"<code>finished</code>  <code>property</code>","text":"<p>Check if all jobs finished</p> <p>Returns:</p> Type Description <p><code>False</code> if in process, <code>False</code> otherwise</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.processing_size","title":"<code>processing_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that in process</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.waiting_size","title":"<code>waiting_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs waiting to be processed</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.__init__","title":"<code>__init__(*, job_list=None, tqdm_class=None, progress=True, centralized_progress=True, use_colors=True, use_emojis=True)</code>","text":"<p>Create a job runner</p> <p>Parameters:</p> Name Type Description Default <code>job_list</code> <code>List[Job]</code> <p>Jobs to initial <code>self._job_queue</code></p> <code>None</code> <code>tqdm_class</code> <code>tqdm</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>True</code> <code>centralized_progress</code> <code>bool</code> <p>Use centralized progress manager to prevent display chaos</p> <code>True</code> <code>use_colors</code> <code>bool</code> <p>Enable colorful progress bars (requires ANSI terminal support)</p> <code>True</code> <code>use_emojis</code> <code>bool</code> <p>Enable emoji indicators in progress bars</p> <code>True</code> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True,\n             centralized_progress: bool = True, use_colors: bool = True, use_emojis: bool = True):\n    \"\"\"\n    Create a job runner\n\n    :param job_list: Jobs to initial ``self._job_queue``\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    :param centralized_progress: Use centralized progress manager to prevent display chaos\n    :param use_colors: Enable colorful progress bars (requires ANSI terminal support)\n    :param use_emojis: Enable emoji indicators in progress bars\n    \"\"\"\n    job_list = job_list or []\n    self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n    for job in job_list:\n        self._job_queue.put_nowait(job)\n\n    # Initialize progress management\n    self._progress = progress\n    self._centralized_progress = centralized_progress and progress\n\n    if self._centralized_progress:\n        # Use centralized progress manager with enhanced visuals\n        self._progress_manager = ProgressManager(\n            max_workers=config.job.count,\n            use_colors=use_colors,\n            use_emojis=use_emojis\n        )\n        self._tqdm_class = tqdm_class or create_managed_tqdm_class(self._progress_manager)\n    else:\n        # Use traditional tqdm\n        self._progress_manager = None\n        self._tqdm_class = tqdm_class\n\n    self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n    self._concurrent_tasks: Set[asyncio.Task] = set()\n    self._lock = asyncio.Lock()\n    self._total_jobs_count = len(job_list)\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.add_jobs","title":"<code>add_jobs(*jobs)</code>  <code>async</code>","text":"<p>Add jobs to <code>self._job_queue</code></p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def add_jobs(self, *jobs: Job):\n    \"\"\"Add jobs to ``self._job_queue``\"\"\"\n    for job in jobs:\n        await self._job_queue.put(job)\n\n    # Update total job count for progress tracking\n    self._total_jobs_count += len(jobs)\n    if self._progress_manager:\n        self._progress_manager.set_job_totals(self._total_jobs_count)\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.cancel_downloader","title":"<code>cancel_downloader(target)</code>  <code>async</code>","text":"<p>Cancel downloader</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether cancelled successfully</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def cancel_downloader(self, target: Downloader) -&gt; bool:\n    \"\"\"\n    Cancel downloader\n\n    :return: Whether cancelled successfully\n    \"\"\"\n    task = self._downloaders_with_task[target]\n    if not task.done():\n        target.cancel()\n        return await self._force_cancel(task, 0) or task.done()\n    return True\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.processor","title":"<code>processor()</code>  <code>async</code>","text":"<p>Process each job in <code>self._job_queue</code></p> <p>Returns:</p> Type Description <code>int</code> <p>Number of jobs that failed</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def processor(self) -&gt; int:\n    \"\"\"\n    Process each job in ``self._job_queue``\n\n    :return: Number of jobs that failed\n    \"\"\"\n    failed_num = 0\n    async with httpx.AsyncClient(\n            verify=config.ssl_verify,\n            cookies={\"session\": config.api.session_key} if config.api.session_key else None\n    ) as client:\n        while not self._job_queue.empty():\n            job = await self._job_queue.get()\n\n            # Create downloader\n            url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n            url = str(urlunparse(url_parts))\n            downloader = Downloader(\n                url=url,\n                path=job.path,\n                client=client,\n                designated_filename=job.alt_filename,\n                server_path=job.server_path,\n                post=job.post\n            )\n\n            # Create task\n            task = asyncio.create_task(\n                downloader.run(\n                    tqdm_class=self._tqdm_class,\n                    progress=self._progress\n                )\n            )\n            self._downloaders_with_task[downloader] = task\n            # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n            #   Delete this for counting finished job tasks\n\n            # Run task\n            task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n            task_done = task_done_set.pop()\n            try:\n                exception = task_done.exception()\n            except CancelledError as e:\n                exception = e\n            if not exception:  # raise Exception when cancelled or other exceptions\n                ret = task_done.result()\n                if ret.code == RetCodeEnum.FileExisted:\n                    logger.debug(ret.message)\n                    # Treat file existed as successful download but mark as existed\n                    if self._progress_manager:\n                        # Increment existed count atomically and update completed based on current done_size\n                        try:\n                            self._progress_manager.increment_existed(1)\n                        except AttributeError:\n                            # Fallback if older ProgressManager doesn't have increment_existed\n                            self._progress_manager.update_job_progress(\n                                existed=self._progress_manager._existed_jobs + 1\n                            )\n                        self._progress_manager.update_job_progress(\n                            completed=self.done_size\n                        )\n                elif ret.code != RetCodeEnum.Success:\n                    logger.error(ret.message)\n                    failed_num += 1\n                    # Update progress manager with failed job\n                    if self._progress_manager:\n                        self._progress_manager.update_job_progress(\n                            failed=failed_num\n                        )\n                else:\n                    # Update progress manager with completed job\n                    if self._progress_manager:\n                        self._progress_manager.update_job_progress(\n                            completed=self.done_size\n                        )\n            elif isinstance(exception, CancelledError):\n                logger.warning(\n                    generate_msg(\n                        \"Download cancelled\",\n                        filename=job.alt_filename\n                    )\n                )\n            else:\n                logger.error(\n                    generate_msg(\n                        \"Download failed\",\n                        filename=job.alt_filename,\n                        exception=exception\n                    )\n                )\n                failed_num += 1\n                # Update progress manager with failed job\n                if self._progress_manager:\n                    self._progress_manager.update_job_progress(\n                        failed=failed_num\n                    )\n            self._job_queue.task_done()\n    await self._job_queue.join()\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start processing jobs concurrently</p> <p>It will Block until other call of <code>self.start()</code> method finished</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of jobs that failed</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def start(self) -&gt; int:\n    \"\"\"\n    Start processing jobs concurrently\n\n    It will **Block** until other call of ``self.start()`` method finished\n\n    :return: Number of jobs that failed\n    \"\"\"\n    failed_num = 0\n\n    # Initialize progress manager if using centralized progress\n    if self._progress_manager:\n        self._progress_manager.set_job_totals(self._total_jobs_count)\n        self._progress_manager.start_display()\n        # Setup logger integration to work with progress display\n        setup_logger_for_progress(self._progress_manager)\n\n    async with self._lock:\n        self._concurrent_tasks.clear()\n        for _ in range(config.job.count):\n            task = asyncio.create_task(self.processor())\n            self._concurrent_tasks.add(task)\n            task.add_done_callback(self._concurrent_tasks.discard)\n\n        # Start background display update if using centralized progress\n        display_task = None\n        if self._progress_manager:\n            display_task = asyncio.create_task(self._update_display_loop())\n\n        # Start watcher as a background task so we can cancel it promptly when downloads finish\n        watch_task = None\n        if self._progress_manager:\n            watch_task = asyncio.create_task(self._watch_status())\n\n        # Wait for all concurrent processor tasks to finish\n        task_done_set, _ = await asyncio.wait(self._concurrent_tasks)\n\n        # Cancel watcher promptly to avoid waiting for its sleep interval\n        if watch_task:\n            watch_task.cancel()\n            try:\n                await watch_task\n            except asyncio.CancelledError:\n                pass\n\n        if display_task:\n            display_task.cancel()\n            try:\n                await display_task\n            except asyncio.CancelledError:\n                pass\n\n        for task in task_done_set:\n            try:\n                failed_num += task.result()\n            except CancelledError:\n                pass\n\n        # Clean up progress manager\n        if self._progress_manager:\n            self._progress_manager.stop_display()\n            # Remove logger integration\n            setup_logger_for_progress(None)\n\n    if failed_num:\n        logger.warning(f\"{failed_num} jobs failed, download finished\")\n    else:\n        logger.success(\"All jobs in queue finished\")\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.model.__all__","title":"<code>__all__ = ['BaseKToolBoxData', 'SearchResult']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData","title":"<code>BaseKToolBoxData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all KToolBox data models.</p> Source code in <code>ktoolbox/model.py</code> <pre><code>class BaseKToolBoxData(BaseModel):\n    \"\"\"\n    Base class for all KToolBox data models.\n    \"\"\"\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        self.type = type(self)\n\n    version: str = __version__\n    type: Union[Type[\"BaseKToolBoxData\"], str] = None\n\n    @field_serializer('type')\n    def _(self, value: Type[\"BaseKToolBoxData\"], _info):\n        return str(value)\n</code></pre>"},{"location":"api/#ktoolbox.model.BaseKToolBoxData.type","title":"<code>type: Union[Type[BaseKToolBoxData], str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData.version","title":"<code>version: str = __version__</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData._","title":"<code>_(value, _info)</code>","text":"Source code in <code>ktoolbox/model.py</code> <pre><code>@field_serializer('type')\ndef _(self, value: Type[\"BaseKToolBoxData\"], _info):\n    return str(value)\n</code></pre>"},{"location":"api/#ktoolbox.model.BaseKToolBoxData.__init__","title":"<code>__init__(**data)</code>","text":"Source code in <code>ktoolbox/model.py</code> <pre><code>def __init__(self, **data: Any):\n    super().__init__(**data)\n    self.type = type(self)\n</code></pre>"},{"location":"api/#ktoolbox.model.SearchResult","title":"<code>SearchResult</code>","text":"<p>               Bases: <code>BaseKToolBoxData</code>, <code>Generic[_T]</code></p> <p>Cli search result</p> Source code in <code>ktoolbox/model.py</code> <pre><code>class SearchResult(BaseKToolBoxData, Generic[_T]):\n    \"\"\"Cli search result\"\"\"\n    result: List[_T] = []\n</code></pre>"},{"location":"api/#ktoolbox.model.SearchResult.result","title":"<code>result: List[_T] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress","title":"<code>progress</code>","text":"<p>Centralized Progress Management for KToolBox</p> <p>This module provides a centralized progress display system that prevents multiple concurrent progress bars from interfering with each other. Inspired by rclone's progress display approach with enhanced visual effects.</p>"},{"location":"api/#ktoolbox.progress.RICH_AVAILABLE","title":"<code>RICH_AVAILABLE = True</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.__all__","title":"<code>__all__ = ['ProgressManager', 'ManagedTqdm', 'ColorTheme', 'setup_logger_for_progress', 'create_managed_tqdm_class']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme","title":"<code>ColorTheme</code>","text":"<p>Rich-based color themes and styles for progress display</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>class ColorTheme:\n    \"\"\"Rich-based color themes and styles for progress display\"\"\"\n\n    # Rich console for color support detection and rendering\n    _console = Console() if RICH_AVAILABLE else None\n\n    # ANSI Color codes (fallback when Rich not available)\n    RESET = '\\033[0m'\n    BOLD = '\\033[1m'\n\n    # Basic colors\n    RED = '\\033[31m'\n    GREEN = '\\033[32m'\n    YELLOW = '\\033[33m'\n    BLUE = '\\033[34m'\n    MAGENTA = '\\033[35m'\n    CYAN = '\\033[36m'\n    WHITE = '\\033[37m'\n\n    # Bright colors\n    BRIGHT_RED = '\\033[91m'\n    BRIGHT_GREEN = '\\033[92m'\n    BRIGHT_YELLOW = '\\033[93m'\n    BRIGHT_BLUE = '\\033[94m'\n    BRIGHT_MAGENTA = '\\033[95m'\n    BRIGHT_CYAN = '\\033[96m'\n    BRIGHT_WHITE = '\\033[97m'\n\n    # Background colors\n    BG_GREEN = '\\033[42m'\n    BG_RED = '\\033[41m'\n    BG_YELLOW = '\\033[43m'\n\n    # Rich style mappings\n    if RICH_AVAILABLE:\n        RICH_STYLES = {\n            RED: \"red\",\n            GREEN: \"green\",\n            YELLOW: \"yellow\",\n            BLUE: \"blue\", \n            MAGENTA: \"magenta\",\n            CYAN: \"cyan\",\n            WHITE: \"white\",\n            BRIGHT_RED: \"bright_red\",\n            BRIGHT_GREEN: \"bright_green\",\n            BRIGHT_YELLOW: \"bright_yellow\",\n            BRIGHT_BLUE: \"bright_blue\",\n            BRIGHT_MAGENTA: \"bright_magenta\",\n            BRIGHT_CYAN: \"bright_cyan\",\n            BRIGHT_WHITE: \"bright_white\",\n        }\n    else:\n        RICH_STYLES = {}\n\n    # Emojis\n    DOWNLOAD = \"\ud83d\udce5\"\n    COMPLETED = \"\u2705\"\n    FAILED = \"\u274c\"\n    RUNNING = \"\ud83d\udd04\"\n    WAITING = \"\u23f3\"\n    SPEED = \"\u26a1\"\n    ROCKET = \"\ud83d\ude80\"\n\n    # Animation frames for spinner\n    SPINNER_FRAMES = [\"\u280b\", \"\u2819\", \"\u2839\", \"\u2838\", \"\u283c\", \"\u2834\", \"\u2826\", \"\u2827\", \"\u2807\", \"\u280f\"]\n\n    @classmethod\n    def colorize(cls, text: str, color: str, bold: bool = False) -&gt; str:\n        \"\"\"Apply color to text with optional bold using Rich when available\"\"\"\n        if not cls.supports_color():\n            return text\n\n        if RICH_AVAILABLE:\n            # Use Rich for more robust color support\n            rich_color = cls.RICH_STYLES.get(color, color)\n            style = f\"bold {rich_color}\" if bold else rich_color\n\n            # Create a Text object and render it to get the styled string\n            from rich.text import Text\n            from rich.console import Console\n\n            text_obj = Text(text, style=style)\n            # Create a temporary console that forces color output for testing\n            console = Console(force_terminal=True, width=1000)\n            with console.capture() as capture:\n                console.print(text_obj, end=\"\")\n            return capture.get()\n        else:\n            # Fallback to ANSI codes\n            prefix = cls.BOLD + color if bold else color\n            return f\"{prefix}{text}{cls.RESET}\"\n\n    @classmethod\n    def supports_color(cls) -&gt; bool:\n        \"\"\"Check if terminal supports color using Rich when available\"\"\"\n        if RICH_AVAILABLE and cls._console:\n            # Rich handles color support detection better\n            return cls._console.is_terminal and not cls._console.options.legacy_windows\n        else:\n            # Fallback to manual detection\n            return (\n                hasattr(sys.stdout, 'isatty') and sys.stdout.isatty() and\n                not sys.platform.startswith('win') or 'ANSICON' in os.environ\n            )\n</code></pre>"},{"location":"api/#ktoolbox.progress.ColorTheme.BG_GREEN","title":"<code>BG_GREEN = '\\x1b[42m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BG_RED","title":"<code>BG_RED = '\\x1b[41m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BG_YELLOW","title":"<code>BG_YELLOW = '\\x1b[43m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BLUE","title":"<code>BLUE = '\\x1b[34m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BOLD","title":"<code>BOLD = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BRIGHT_BLUE","title":"<code>BRIGHT_BLUE = '\\x1b[94m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BRIGHT_CYAN","title":"<code>BRIGHT_CYAN = '\\x1b[96m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BRIGHT_GREEN","title":"<code>BRIGHT_GREEN = '\\x1b[92m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BRIGHT_MAGENTA","title":"<code>BRIGHT_MAGENTA = '\\x1b[95m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BRIGHT_RED","title":"<code>BRIGHT_RED = '\\x1b[91m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BRIGHT_WHITE","title":"<code>BRIGHT_WHITE = '\\x1b[97m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.BRIGHT_YELLOW","title":"<code>BRIGHT_YELLOW = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.COMPLETED","title":"<code>COMPLETED = '\u2705'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.CYAN","title":"<code>CYAN = '\\x1b[36m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.DOWNLOAD","title":"<code>DOWNLOAD = '\ud83d\udce5'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.FAILED","title":"<code>FAILED = '\u274c'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.GREEN","title":"<code>GREEN = '\\x1b[32m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.MAGENTA","title":"<code>MAGENTA = '\\x1b[35m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.RED","title":"<code>RED = '\\x1b[31m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.RESET","title":"<code>RESET = '\\x1b[0m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.RICH_STYLES","title":"<code>RICH_STYLES = {RED: 'red', GREEN: 'green', YELLOW: 'yellow', BLUE: 'blue', MAGENTA: 'magenta', CYAN: 'cyan', WHITE: 'white', BRIGHT_RED: 'bright_red', BRIGHT_GREEN: 'bright_green', BRIGHT_YELLOW: 'bright_yellow', BRIGHT_BLUE: 'bright_blue', BRIGHT_MAGENTA: 'bright_magenta', BRIGHT_CYAN: 'bright_cyan', BRIGHT_WHITE: 'bright_white'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.ROCKET","title":"<code>ROCKET = '\ud83d\ude80'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.RUNNING","title":"<code>RUNNING = '\ud83d\udd04'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.SPEED","title":"<code>SPEED = '\u26a1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.SPINNER_FRAMES","title":"<code>SPINNER_FRAMES = ['\u280b', '\u2819', '\u2839', '\u2838', '\u283c', '\u2834', '\u2826', '\u2827', '\u2807', '\u280f']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.WAITING","title":"<code>WAITING = '\u23f3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.WHITE","title":"<code>WHITE = '\\x1b[37m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.YELLOW","title":"<code>YELLOW = '\\x1b[33m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ColorTheme.colorize","title":"<code>colorize(text, color, bold=False)</code>  <code>classmethod</code>","text":"<p>Apply color to text with optional bold using Rich when available</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>@classmethod\ndef colorize(cls, text: str, color: str, bold: bool = False) -&gt; str:\n    \"\"\"Apply color to text with optional bold using Rich when available\"\"\"\n    if not cls.supports_color():\n        return text\n\n    if RICH_AVAILABLE:\n        # Use Rich for more robust color support\n        rich_color = cls.RICH_STYLES.get(color, color)\n        style = f\"bold {rich_color}\" if bold else rich_color\n\n        # Create a Text object and render it to get the styled string\n        from rich.text import Text\n        from rich.console import Console\n\n        text_obj = Text(text, style=style)\n        # Create a temporary console that forces color output for testing\n        console = Console(force_terminal=True, width=1000)\n        with console.capture() as capture:\n            console.print(text_obj, end=\"\")\n        return capture.get()\n    else:\n        # Fallback to ANSI codes\n        prefix = cls.BOLD + color if bold else color\n        return f\"{prefix}{text}{cls.RESET}\"\n</code></pre>"},{"location":"api/#ktoolbox.progress.ColorTheme.supports_color","title":"<code>supports_color()</code>  <code>classmethod</code>","text":"<p>Check if terminal supports color using Rich when available</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>@classmethod\ndef supports_color(cls) -&gt; bool:\n    \"\"\"Check if terminal supports color using Rich when available\"\"\"\n    if RICH_AVAILABLE and cls._console:\n        # Rich handles color support detection better\n        return cls._console.is_terminal and not cls._console.options.legacy_windows\n    else:\n        # Fallback to manual detection\n        return (\n            hasattr(sys.stdout, 'isatty') and sys.stdout.isatty() and\n            not sys.platform.startswith('win') or 'ANSICON' in os.environ\n        )\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm","title":"<code>ManagedTqdm</code>","text":"<p>A tqdm-compatible progress bar that works with ProgressManager. This class mimics the tqdm interface but delegates to ProgressManager.</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>class ManagedTqdm:\n    \"\"\"\n    A tqdm-compatible progress bar that works with ProgressManager.\n    This class mimics the tqdm interface but delegates to ProgressManager.\n    \"\"\"\n\n    def __init__(self, desc=None, total=None, initial=0, disable=False,\n                 unit=\"it\", unit_scale=False, manager=None, **kwargs):\n        self._failed = False\n        self._paused = False\n        # If no manager provided or disabled, fall back to standard tqdm\n        if manager is None or disable:\n            self._fallback = std_tqdm(desc=desc, total=total, initial=initial,\n                                    disable=disable, unit=unit, unit_scale=unit_scale, **kwargs)\n            self.manager = None\n            self.progress_id = None\n        else:\n            self.manager = manager\n            self._fallback = None\n            self._current = initial\n            self._total = total\n            self._desc = desc or \"\"\n            self._disable = disable\n            self._unit = unit\n            self._unit_scale = unit_scale\n\n            # Create progress bar in manager\n            self.progress_id = f\"{desc}_{id(self)}\"\n            with self.manager._lock:\n                self.manager._progress_bars[self.progress_id] = ProgressState(\n                    desc=self._desc, total=total, current=initial,\n                    unit=unit, unit_scale=unit_scale\n                )\n                if self.progress_id not in self.manager._display_order:\n                    self.manager._display_order.append(self.progress_id)\n\n    def update(self, n: int = 1):\n        \"\"\"Update the progress bar by n units\"\"\"\n        if self._fallback:\n            return self._fallback.update(n)\n\n        self._current += n\n        self.manager.update_progress(self.progress_id, self._current, self._desc)\n        self.manager.update_display()\n        return None\n\n    def set_description(self, desc: str):\n        \"\"\"Set the description of the progress bar\"\"\"\n        if self._fallback:\n            return self._fallback.set_description(desc)\n\n        self._desc = desc\n        self.manager.update_progress(self.progress_id, self._current, desc)\n        return None\n\n    def close(self):\n        \"\"\"Close/finish the progress bar\"\"\"\n        if self._fallback:\n            return self._fallback.close()\n\n        if self.manager and self.progress_id:\n            self.manager.finish_progress(self.progress_id, failed=getattr(self, '_failed', False))\n        return None\n\n    def __enter__(self):\n        if self._fallback:\n            return self._fallback.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self._fallback:\n            return self._fallback.__exit__(exc_type, exc_val, exc_tb)\n        self.close()\n        return None\n\n    def set_failed(self, failed: bool = True):\n        \"\"\"Mark the progress bar as failed\"\"\"\n        if self._fallback:\n            return  # Not supported in fallback mode\n\n        self._failed = failed\n        if self.manager and self.progress_id:\n            self.manager.update_progress(self.progress_id, self._current, self._desc, failed=failed)\n\n    def set_paused(self, paused: bool = True):\n        \"\"\"Mark the progress bar as paused\"\"\"\n        if self._fallback:\n            return  # Not supported in fallback mode\n\n        self._paused = paused\n        if self.manager and self.progress_id:\n            with self.manager._lock:\n                if self.progress_id in self.manager._progress_bars:\n                    self.manager._progress_bars[self.progress_id].paused = paused\n\n    # Properties to maintain compatibility with tqdm\n    @property\n    def total(self):\n        if self._fallback:\n            return self._fallback.total\n        return self._total\n\n    @total.setter\n    def total(self, value):\n        if self._fallback:\n            self._fallback.total = value\n        else:\n            self._total = value\n\n    @property\n    def n(self):\n        if self._fallback:\n            return self._fallback.n\n        return self._current\n\n    @n.setter\n    def n(self, value):\n        if self._fallback:\n            self._fallback.n = value\n        else:\n            self._current = value\n            if self.manager:\n                self.manager.update_progress(self.progress_id, self._current, self._desc)\n\n    def __bool__(self):\n        \"\"\"For compatibility with tqdm boolean checks\"\"\"\n        return True\n\n    def __del__(self):\n        \"\"\"Cleanup when object is garbage collected\"\"\"\n        try:\n            self.close()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.manager","title":"<code>manager = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ManagedTqdm.n","title":"<code>n</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#ktoolbox.progress.ManagedTqdm.progress_id","title":"<code>progress_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ManagedTqdm.total","title":"<code>total</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#ktoolbox.progress.ManagedTqdm.__bool__","title":"<code>__bool__()</code>","text":"<p>For compatibility with tqdm boolean checks</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def __bool__(self):\n    \"\"\"For compatibility with tqdm boolean checks\"\"\"\n    return True\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.__del__","title":"<code>__del__()</code>","text":"<p>Cleanup when object is garbage collected</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def __del__(self):\n    \"\"\"Cleanup when object is garbage collected\"\"\"\n    try:\n        self.close()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>ktoolbox/progress.py</code> <pre><code>def __enter__(self):\n    if self._fallback:\n        return self._fallback.__enter__()\n    return self\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"Source code in <code>ktoolbox/progress.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    if self._fallback:\n        return self._fallback.__exit__(exc_type, exc_val, exc_tb)\n    self.close()\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.__init__","title":"<code>__init__(desc=None, total=None, initial=0, disable=False, unit='it', unit_scale=False, manager=None, **kwargs)</code>","text":"Source code in <code>ktoolbox/progress.py</code> <pre><code>def __init__(self, desc=None, total=None, initial=0, disable=False,\n             unit=\"it\", unit_scale=False, manager=None, **kwargs):\n    self._failed = False\n    self._paused = False\n    # If no manager provided or disabled, fall back to standard tqdm\n    if manager is None or disable:\n        self._fallback = std_tqdm(desc=desc, total=total, initial=initial,\n                                disable=disable, unit=unit, unit_scale=unit_scale, **kwargs)\n        self.manager = None\n        self.progress_id = None\n    else:\n        self.manager = manager\n        self._fallback = None\n        self._current = initial\n        self._total = total\n        self._desc = desc or \"\"\n        self._disable = disable\n        self._unit = unit\n        self._unit_scale = unit_scale\n\n        # Create progress bar in manager\n        self.progress_id = f\"{desc}_{id(self)}\"\n        with self.manager._lock:\n            self.manager._progress_bars[self.progress_id] = ProgressState(\n                desc=self._desc, total=total, current=initial,\n                unit=unit, unit_scale=unit_scale\n            )\n            if self.progress_id not in self.manager._display_order:\n                self.manager._display_order.append(self.progress_id)\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.close","title":"<code>close()</code>","text":"<p>Close/finish the progress bar</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def close(self):\n    \"\"\"Close/finish the progress bar\"\"\"\n    if self._fallback:\n        return self._fallback.close()\n\n    if self.manager and self.progress_id:\n        self.manager.finish_progress(self.progress_id, failed=getattr(self, '_failed', False))\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.set_description","title":"<code>set_description(desc)</code>","text":"<p>Set the description of the progress bar</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def set_description(self, desc: str):\n    \"\"\"Set the description of the progress bar\"\"\"\n    if self._fallback:\n        return self._fallback.set_description(desc)\n\n    self._desc = desc\n    self.manager.update_progress(self.progress_id, self._current, desc)\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.set_failed","title":"<code>set_failed(failed=True)</code>","text":"<p>Mark the progress bar as failed</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def set_failed(self, failed: bool = True):\n    \"\"\"Mark the progress bar as failed\"\"\"\n    if self._fallback:\n        return  # Not supported in fallback mode\n\n    self._failed = failed\n    if self.manager and self.progress_id:\n        self.manager.update_progress(self.progress_id, self._current, self._desc, failed=failed)\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.set_paused","title":"<code>set_paused(paused=True)</code>","text":"<p>Mark the progress bar as paused</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def set_paused(self, paused: bool = True):\n    \"\"\"Mark the progress bar as paused\"\"\"\n    if self._fallback:\n        return  # Not supported in fallback mode\n\n    self._paused = paused\n    if self.manager and self.progress_id:\n        with self.manager._lock:\n            if self.progress_id in self.manager._progress_bars:\n                self.manager._progress_bars[self.progress_id].paused = paused\n</code></pre>"},{"location":"api/#ktoolbox.progress.ManagedTqdm.update","title":"<code>update(n=1)</code>","text":"<p>Update the progress bar by n units</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def update(self, n: int = 1):\n    \"\"\"Update the progress bar by n units\"\"\"\n    if self._fallback:\n        return self._fallback.update(n)\n\n    self._current += n\n    self.manager.update_progress(self.progress_id, self._current, self._desc)\n    self.manager.update_display()\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressAwareHandler","title":"<code>ProgressAwareHandler</code>","text":"<p>Custom loguru handler that works with progress manager</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>class ProgressAwareHandler:\n    \"\"\"Custom loguru handler that works with progress manager\"\"\"\n\n    def __init__(self, original_handler):\n        self.original_handler = original_handler\n\n    def write(self, message):\n        global _active_progress_manager\n        if _active_progress_manager and _active_progress_manager._running:\n            # Temporarily clear progress display\n            _active_progress_manager.temporary_clear_for_log()\n            self.original_handler.write(message)\n            # Small delay to ensure message is visible\n            time.sleep(0.05)\n            # Restore progress display\n            _active_progress_manager.restore_display()\n        else:\n            self.original_handler.write(message)\n\n    def flush(self):\n        if hasattr(self.original_handler, 'flush'):\n            self.original_handler.flush()\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressAwareHandler.original_handler","title":"<code>original_handler = original_handler</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressAwareHandler.__init__","title":"<code>__init__(original_handler)</code>","text":"Source code in <code>ktoolbox/progress.py</code> <pre><code>def __init__(self, original_handler):\n    self.original_handler = original_handler\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressAwareHandler.flush","title":"<code>flush()</code>","text":"Source code in <code>ktoolbox/progress.py</code> <pre><code>def flush(self):\n    if hasattr(self.original_handler, 'flush'):\n        self.original_handler.flush()\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressAwareHandler.write","title":"<code>write(message)</code>","text":"Source code in <code>ktoolbox/progress.py</code> <pre><code>def write(self, message):\n    global _active_progress_manager\n    if _active_progress_manager and _active_progress_manager._running:\n        # Temporarily clear progress display\n        _active_progress_manager.temporary_clear_for_log()\n        self.original_handler.write(message)\n        # Small delay to ensure message is visible\n        time.sleep(0.05)\n        # Restore progress display\n        _active_progress_manager.restore_display()\n    else:\n        self.original_handler.write(message)\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager","title":"<code>ProgressManager</code>","text":"<p>Centralized progress manager that coordinates multiple progress bars in a fixed terminal display area with enhanced visual effects.</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>class ProgressManager:\n    \"\"\"\n    Centralized progress manager that coordinates multiple progress bars\n    in a fixed terminal display area with enhanced visual effects.\n    \"\"\"\n\n    def __init__(self, max_workers: int = 5, file: Optional[TextIO] = None,\n                 use_colors: bool = True, use_emojis: bool = True,\n                 update_interval: float = 0.1):\n        \"\"\"\n        Initialize the progress manager.\n\n        :param max_workers: Maximum number of concurrent progress bars to display\n        :param file: Output stream (defaults to sys.stdout)\n        :param use_colors: Enable color output\n        :param use_emojis: Enable emoji indicators\n        \"\"\"\n        self.max_workers = max_workers\n        self.file = file or sys.stdout\n        self.use_colors = use_colors and ColorTheme.supports_color()\n        self.use_emojis = use_emojis\n        self._progress_bars: Dict[str, ProgressState] = {}\n        self._display_order: List[str] = []\n        self._lock = threading.RLock()\n        self._display_task: Optional[asyncio.Task] = None\n        self._running = False\n        self._total_jobs = 0\n        self._completed_jobs = 0\n        self._failed_jobs = 0\n        self._existed_jobs = 0\n\n        # Terminal control\n        self._lines_written = 0\n        self._last_display_time = 0\n        # Update interval (seconds). When downloads change, refresh at most\n        # once per `update_interval`. Default is 1.0s to avoid excessive redraws.\n        self._update_interval = float(update_interval)\n\n        # Display deduplication\n        self._last_display_content = \"\"\n\n    def set_job_totals(self, total: int, completed: int = 0, failed: int = 0, existed: int = 0):\n        \"\"\"Set the total number of jobs for overall progress tracking\"\"\"\n        with self._lock:\n            self._total_jobs = total\n            self._completed_jobs = completed\n            self._failed_jobs = failed\n            self._existed_jobs = existed\n\n    def update_job_progress(self, completed: int = None, failed: int = None, existed: int = None):\n        \"\"\"Update overall job progress\"\"\"\n        with self._lock:\n            if completed is not None:\n                self._completed_jobs = completed\n            if failed is not None:\n                self._failed_jobs = failed\n            if existed is not None:\n                self._existed_jobs = existed\n\n    def increment_existed(self, n: int = 1) -&gt; int:\n        \"\"\"Atomically increment the existed count by n and return the new value\"\"\"\n        with self._lock:\n            self._existed_jobs += n\n            return self._existed_jobs\n\n    def create_progress_bar(self, desc: str, total: Optional[int] = None,\n                          unit: str = \"B\", unit_scale: bool = True) -&gt; 'ManagedTqdm':\n        \"\"\"Create a new managed progress bar\"\"\"\n        # Don't create progress state here - let ManagedTqdm do it with proper unique ID\n        return ManagedTqdm(desc=desc, total=total, unit=unit, unit_scale=unit_scale, manager=self)\n\n    def update_progress(self, progress_id: str, current: int, desc: str = None, failed: bool = False):\n        \"\"\"Update progress for a specific progress bar\"\"\"\n        with self._lock:\n            if progress_id in self._progress_bars:\n                state = self._progress_bars[progress_id]\n                state.current = current\n                state.failed = failed\n                if desc:\n                    state.desc = desc\n                state.last_update = time.time()\n\n                # Calculate rate\n                if hasattr(state, '_last_current') and hasattr(state, '_last_time'):\n                    time_diff = state.last_update - state._last_time\n                    if time_diff &gt; 0:\n                        current_diff = current - state._last_current\n                        state.rate = current_diff / time_diff\n\n                state._last_current = current\n                state._last_time = state.last_update\n\n    def finish_progress(self, progress_id: str, failed: bool = False):\n        \"\"\"Mark a progress bar as finished\"\"\"\n        with self._lock:\n            if progress_id in self._progress_bars:\n                self._progress_bars[progress_id].finished = True\n                self._progress_bars[progress_id].failed = failed\n                # Remove finished progress bar immediately in sync context\n                # to avoid coroutine warnings\n                try:\n                    loop = asyncio.get_running_loop()\n                    # Only create task if we're in an async context with a running loop\n                    loop.create_task(self._remove_finished_after_delay(progress_id))\n                except RuntimeError:\n                    # No event loop running, remove immediately\n                    if progress_id in self._progress_bars:\n                        del self._progress_bars[progress_id]\n                    if progress_id in self._display_order:\n                        self._display_order.remove(progress_id)\n\n    async def _remove_finished_after_delay(self, progress_id: str, delay: float = 1.0):\n        \"\"\"Remove a finished progress bar after a delay\"\"\"\n        await asyncio.sleep(delay)\n        with self._lock:\n            if progress_id in self._progress_bars and self._progress_bars[progress_id].finished:\n                del self._progress_bars[progress_id]\n                if progress_id in self._display_order:\n                    self._display_order.remove(progress_id)\n\n    def start_display(self):\n        \"\"\"Start the progress display loop\"\"\"\n        if not self._running and self.file.isatty():\n            self._running = True\n            # Hide cursor\n            self.file.write('\\033[?25l')\n            self.file.flush()\n            # Set as active progress manager for logger integration\n            setup_logger_for_progress(self)\n\n    def stop_display(self):\n        \"\"\"Stop the progress display loop\"\"\"\n        if self._running:\n            self._running = False\n            # Clear display area and show cursor\n            self._clear_display()\n            self.file.write('\\033[?25h\\n')\n            self.file.flush()\n            # Remove from logger integration\n            setup_logger_for_progress(None)\n\n    def _clear_display(self):\n        \"\"\"Clear the current display area\"\"\"\n        if self._lines_written &gt; 0 and self.file.isatty():\n            # Move cursor up to the start of our display area\n            self.file.write(f'\\033[{self._lines_written}A')\n            # Clear each line and move to next\n            for _ in range(self._lines_written):\n                self.file.write('\\033[2K\\033[1B')  # Clear line and move down\n            # Move cursor back to start of display area\n            self.file.write(f'\\033[{self._lines_written}A')\n            self.file.flush()\n            self._lines_written = 0\n\n    def temporary_clear_for_log(self, log_message: str = None):\n        \"\"\"Temporarily clear display to allow log output\"\"\"\n        if self._running and self.file.isatty():\n            self._clear_display()\n            # Reset last display content so we redraw after logging\n            self._last_display_content = \"\"\n            if log_message:\n                self.file.write(log_message + '\\n')\n                self.file.flush()\n\n    def restore_display(self):\n        \"\"\"Restore display after log output\"\"\"\n        if self._running and self.file.isatty():\n            # Force immediate display update\n            self.update_display()\n\n    @staticmethod\n    def _format_size(size: Optional[int], unit_scale: bool = True) -&gt; str:\n        \"\"\"Format a size value with appropriate units\"\"\"\n        if size is None:\n            return \"?\"\n\n        if not unit_scale:\n            return str(size)\n\n        units = ['B', 'KB', 'MB', 'GB', 'TB']\n        size_float = float(size)\n        unit_index = 0\n\n        while size_float &gt;= 1024 and unit_index &lt; len(units) - 1:\n            size_float /= 1024\n            unit_index += 1\n\n        if unit_index == 0:\n            return f\"{size}B\"\n        else:\n            return f\"{size_float:.1f}{units[unit_index]}\"\n\n    def _format_rate(self, rate: Optional[float]) -&gt; str:\n        \"\"\"Format a rate value\"\"\"\n        if rate is None:\n            return \"?/s\"\n        return f\"{self._format_size(int(rate))}/s\"\n\n    def _render_overall_progress(self) -&gt; List[str]:\n        \"\"\"Render the overall job progress with colors and emojis, including visual progress bar\"\"\"\n        lines = []\n\n        if self._total_jobs &gt; 0:\n            running = len([p for p in self._progress_bars.values() if not p.finished])\n            waiting = max(0, self._total_jobs - self._completed_jobs - self._failed_jobs - running)\n\n            progress_pct = (self._completed_jobs / self._total_jobs) * 100 if self._total_jobs &gt; 0 else 0\n            progress_ratio = self._completed_jobs / self._total_jobs if self._total_jobs &gt; 0 else 0\n\n            # Determine overall status emoji and color\n            if self.use_emojis:\n                if running &gt; 0:\n                    status_emoji = f\"{ColorTheme.RUNNING} \"\n                elif self._failed_jobs &gt; 0:\n                    status_emoji = f\"{ColorTheme.FAILED} \"\n                else:\n                    status_emoji = f\"{ColorTheme.COMPLETED} \"\n            else:\n                status_emoji = \"\"\n\n            # Create visual progress bar\n            bar_width = 30\n            filled = int(bar_width * progress_ratio)\n\n            if self.use_colors:\n                if progress_pct &gt;= 100:\n                    bar_filled = ColorTheme.colorize('=' * filled, ColorTheme.BRIGHT_GREEN)\n                    bar_empty = ColorTheme.colorize('-' * (bar_width - filled), ColorTheme.GREEN)\n                elif progress_pct &gt;= 75:\n                    bar_filled = ColorTheme.colorize('=' * filled, ColorTheme.BRIGHT_CYAN)\n                    bar_empty = ColorTheme.colorize('&gt;' + '-' * (bar_width - filled), ColorTheme.CYAN)\n                else:\n                    bar_filled = ColorTheme.colorize('=' * filled, ColorTheme.BRIGHT_YELLOW)\n                    bar_empty = ColorTheme.colorize('&gt;' + '-' * (bar_width - filled), ColorTheme.YELLOW)\n\n                bar_display = bar_filled + bar_empty\n            else:\n                bar_filled = '=' * filled\n                bar_empty = '-' * (bar_width - filled)\n                if filled &lt; bar_width and progress_pct &lt; 100:\n                    bar_display = bar_filled + '&gt;' + bar_empty[1:] if filled &gt; 0 else '&gt;' + bar_empty[1:]\n                else:\n                    bar_display = bar_filled + bar_empty\n\n            # Color the progress percentage\n            if self.use_colors:\n                if progress_pct &gt;= 100:\n                    pct_colored = ColorTheme.colorize(f\"{progress_pct:.0f}%\", ColorTheme.BRIGHT_GREEN, bold=True)\n                elif progress_pct &gt;= 75:\n                    pct_colored = ColorTheme.colorize(f\"{progress_pct:.0f}%\", ColorTheme.BRIGHT_CYAN, bold=True)\n                elif progress_pct &gt;= 50:\n                    pct_colored = ColorTheme.colorize(f\"{progress_pct:.0f}%\", ColorTheme.BRIGHT_YELLOW, bold=True)\n                else:\n                    pct_colored = ColorTheme.colorize(f\"{progress_pct:.0f}%\", ColorTheme.BRIGHT_WHITE, bold=True)\n            else:\n                pct_colored = f\"{progress_pct:.0f}%\"\n\n            # Color status numbers\n            if self.use_colors:\n                completed_colored = ColorTheme.colorize(str(self._completed_jobs), ColorTheme.BRIGHT_GREEN)\n                total_colored = ColorTheme.colorize(str(self._total_jobs), ColorTheme.BRIGHT_WHITE)\n                running_colored = ColorTheme.colorize(str(running), ColorTheme.BRIGHT_CYAN)\n                waiting_colored = ColorTheme.colorize(str(waiting), ColorTheme.BRIGHT_YELLOW)\n                existed_colored = ColorTheme.colorize(str(self._existed_jobs), ColorTheme.BRIGHT_WHITE)\n            else:\n                completed_colored = str(self._completed_jobs)\n                total_colored = str(self._total_jobs)\n                running_colored = str(running)\n                waiting_colored = str(waiting)\n                existed_colored = str(self._existed_jobs)\n\n            # Calculate overall download speed from active progress bars\n            total_rate = 0\n            active_count = 0\n            for state in self._progress_bars.values():\n                if not state.finished and state.rate and state.rate &gt; 0:\n                    total_rate += state.rate\n                    active_count += 1\n\n            # Format overall speed\n            if total_rate &gt; 0:\n                speed_str = self._format_rate(total_rate)\n                if self.use_colors:\n                    speed_str = ColorTheme.colorize(speed_str, ColorTheme.BRIGHT_MAGENTA)\n            else:\n                speed_str = \"\"\n\n            # Build the main progress line in the requested format\n            # [================&gt;----------------] 23% | Jobs: 10/44 | 4 running | 30 waiting | 4.5 MB/s\n            line_parts = []\n\n            if status_emoji:  # Only add emoji if it's not empty\n                line_parts.append(status_emoji)\n\n            line_parts.extend([\n                f\"[{bar_display}]\",\n                pct_colored,\n                f\"| Jobs: {completed_colored}/{total_colored}\",\n                f\"| {running_colored} running\",\n                f\"| {waiting_colored} waiting\",\n                f\"| {existed_colored} existed\"\n            ])\n\n            if speed_str:\n                line_parts.append(f\"| {speed_str}\")\n\n            line = \" \".join(line_parts)\n            lines.append(line)\n\n            # Show failed jobs on a separate line if any\n            if self._failed_jobs &gt; 0:\n                failed_emoji = f\"{ColorTheme.FAILED} \" if self.use_emojis else \"\"\n                if self.use_colors:\n                    failed_colored = ColorTheme.colorize(str(self._failed_jobs), ColorTheme.BRIGHT_RED, bold=True)\n                else:\n                    failed_colored = str(self._failed_jobs)\n                lines.append(f\"{failed_emoji}Failed: {failed_colored}\")\n\n        return lines\n\n    def _render_progress_bars(self) -&gt; List[str]:\n        \"\"\"Render individual progress bars\"\"\"\n        lines = []\n\n        # Show only active progress bars in stable order (up to max_workers)\n        # Use display_order to maintain consistent positioning instead of sorting by update time\n        active_progress = []\n        for progress_id in self._display_order:\n            if (progress_id in self._progress_bars and \n                not self._progress_bars[progress_id].finished):\n                active_progress.append((progress_id, self._progress_bars[progress_id]))\n\n        for progress_id, state in active_progress[:self.max_workers]:\n            line = self._render_single_progress_bar(state)\n            lines.append(line)\n\n        return lines\n\n    def _render_single_progress_bar(self, state: ProgressState) -&gt; str:\n        \"\"\"Render a single progress bar with colors and animations\"\"\"\n        # Progress bar width\n        bar_width = 30\n\n        # Determine status emoji\n        if self.use_emojis:\n            if state.failed:\n                status_emoji = ColorTheme.FAILED\n            elif state.finished:\n                status_emoji = ColorTheme.COMPLETED\n            elif state.paused:\n                status_emoji = ColorTheme.WAITING\n            else:\n                # Animated spinner for active downloads\n                # Advance spinner only when this progress state's content changed\n                # since the last render to avoid continuous terminal refreshes\n                # caused solely by animation frames.\n                current_time = time.time()\n                last_seen = getattr(state, '_last_render_seen', 0.0)\n                if state.last_update != last_seen:\n                    _animation_state['frame'] = (_animation_state['frame'] + 1) % len(ColorTheme.SPINNER_FRAMES)\n                    _animation_state['last_update'] = current_time\n                    state._last_render_seen = state.last_update\n                status_emoji = ColorTheme.SPINNER_FRAMES[_animation_state['frame']]\n        else:\n            status_emoji = \"\"\n\n        if state.total is not None and state.total &gt; 0:\n            progress = min(state.current / state.total, 1.0)\n            filled = int(bar_width * progress)\n\n            # Create colored progress bar with Unicode characters when Rich is available\n            if self.use_colors and RICH_AVAILABLE:\n                # Use Unicode characters: \u2501\u2501\u2501\u257a\u2501\u2501\u2501\u2501\u2501\u2501\u2501 with Rich colors\n                if state.failed:\n                    # Red for failed\n                    if filled &gt; 0:\n                        if filled &lt; bar_width:\n                            bar_filled = ColorTheme.colorize('\u2501' * (filled - 1), 'bright_red')\n                            bar_empty = ColorTheme.colorize('\u257a' + '\u2501' * (bar_width - filled), 'bright_black')\n                        else:\n                            bar_filled = ColorTheme.colorize('\u2501' * filled, 'bright_red')\n                            bar_empty = ''\n                    else:\n                        bar_filled = ''\n                        bar_empty = ColorTheme.colorize('\u2501' * bar_width, 'bright_black')\n                elif state.finished:\n                    # Green for completed\n                    bar_filled = ColorTheme.colorize('\u2501' * filled, 'bright_green')\n                    bar_empty = ColorTheme.colorize('\u2501' * (bar_width - filled), 'bright_black')\n                else:\n                    # Pink/Magenta for in progress\n                    if filled &gt; 0:\n                        if filled &lt; bar_width:\n                            bar_filled = ColorTheme.colorize('\u2501' * (filled - 1), 'bright_magenta')\n                            bar_empty = ColorTheme.colorize('\u257a' + '\u2501' * (bar_width - filled), 'bright_black')\n                        else:\n                            bar_filled = ColorTheme.colorize('\u2501' * filled, 'bright_magenta')\n                            bar_empty = ''\n                    else:\n                        bar_filled = ''\n                        bar_empty = ColorTheme.colorize('\u2501' * bar_width, 'bright_black')\n                bar = bar_filled + bar_empty\n            elif self.use_colors:\n                # Fallback to original characters with ANSI colors when Rich not available\n                if state.failed:\n                    # Red for failed\n                    bar_filled = ColorTheme.colorize('\u2588' * filled, ColorTheme.BRIGHT_RED)\n                    bar_empty = ColorTheme.colorize('\u2591' * (bar_width - filled), ColorTheme.RED)\n                elif state.finished:\n                    # Green for completed\n                    bar_filled = ColorTheme.colorize('\u2588' * filled, ColorTheme.BRIGHT_GREEN)\n                    bar_empty = ColorTheme.colorize('\u2591' * (bar_width - filled), ColorTheme.GREEN)\n                else:\n                    # Cyan for in progress\n                    bar_filled = ColorTheme.colorize('\u2588' * filled, ColorTheme.BRIGHT_CYAN)\n                    bar_empty = ColorTheme.colorize('\u2591' * (bar_width - filled), ColorTheme.CYAN)\n                bar = bar_filled + bar_empty\n            else:\n                # No colors - use original characters\n                bar = '\u2588' * filled + '\u2591' * (bar_width - filled)\n\n            # Color the percentage\n            percentage_val = progress * 100\n            if self.use_colors:\n                if percentage_val &gt;= 100:\n                    percentage = ColorTheme.colorize(f\"{percentage_val:5.1f}%\", ColorTheme.BRIGHT_GREEN, bold=True)\n                elif percentage_val &gt;= 75:\n                    percentage = ColorTheme.colorize(f\"{percentage_val:5.1f}%\", ColorTheme.BRIGHT_CYAN)\n                else:\n                    percentage = ColorTheme.colorize(f\"{percentage_val:5.1f}%\", ColorTheme.BRIGHT_WHITE)\n            else:\n                percentage = f\"{percentage_val:5.1f}%\"\n        else:\n            # Indeterminate progress with animated bar\n            if self.use_colors and RICH_AVAILABLE:\n                # Moving progress indicator with Unicode characters\n                pos = _animation_state['frame'] % bar_width\n                bar_chars = ['\u2501'] * bar_width\n                for i in range(max(0, pos-2), min(bar_width, pos+3)):\n                    bar_chars[i] = '\u2501'\n                bar_chars[pos] = '\u257a'  # Current position indicator\n                bar = ColorTheme.colorize(''.join(bar_chars), 'bright_yellow')\n            elif self.use_colors:\n                # Fallback to original characters\n                pos = _animation_state['frame'] % bar_width\n                bar_chars = ['\u2591'] * bar_width\n                for i in range(max(0, pos-2), min(bar_width, pos+3)):\n                    bar_chars[i] = '\u2588'\n                bar = ColorTheme.colorize(''.join(bar_chars), ColorTheme.BRIGHT_YELLOW)\n            else:\n                bar = '\u2588' * 3 + '\u2591' * (bar_width - 3)\n            percentage = ColorTheme.colorize(\"  ?  %\", ColorTheme.BRIGHT_YELLOW) if self.use_colors else \"  ?  %\"\n\n        # Format sizes with color\n        current_str = self._format_size(state.current, state.unit_scale)\n        total_str = self._format_size(state.total, state.unit_scale) if state.total else \"?\"\n\n        if self.use_colors:\n            current_str = ColorTheme.colorize(current_str, ColorTheme.BRIGHT_WHITE, bold=True)\n            total_str = ColorTheme.colorize(total_str, ColorTheme.BRIGHT_WHITE)\n\n        # Format rate with speed emoji\n        rate_str = self._format_rate(state.rate)\n        if self.use_colors and state.rate and state.rate &gt; 0:\n            rate_str = ColorTheme.colorize(rate_str, ColorTheme.BRIGHT_MAGENTA)\n\n        if self.use_emojis and state.rate and state.rate &gt; 0:\n            rate_str = f\"{ColorTheme.SPEED} {rate_str}\"\n\n        # Truncate description if too long and add color\n        desc = state.desc\n        if len(desc) &gt; 25:\n            desc = desc[:22] + \"...\"\n\n        if self.use_colors:\n            if state.failed:\n                desc = ColorTheme.colorize(desc, ColorTheme.BRIGHT_RED)\n            elif state.finished:\n                desc = ColorTheme.colorize(desc, ColorTheme.BRIGHT_GREEN)\n            else:\n                desc = ColorTheme.colorize(desc, ColorTheme.BRIGHT_CYAN)\n\n        # Add emoji prefix\n        if self.use_emojis:\n            desc = f\"{status_emoji} {desc}\"\n\n        return f\"{desc:30} |{bar}| {current_str}/{total_str} {percentage} {rate_str}\"\n\n    def update_display(self):\n        \"\"\"Update the terminal display\"\"\"\n        if not self._running or not self.file.isatty():\n            return\n\n        current_time = time.time()\n        if current_time - self._last_display_time &lt; self._update_interval:\n            return\n\n        self._last_display_time = current_time\n\n        with self._lock:\n            # Render new display\n            lines = []\n\n            # Overall progress\n            overall_lines = self._render_overall_progress()\n            if overall_lines:\n                lines.extend(overall_lines)\n                lines.append(\"\")  # Separator\n\n            # Individual progress bars\n            progress_lines = self._render_progress_bars()\n            lines.extend(progress_lines)\n\n            # Write to terminal only if we have content and it's different from last display\n            if lines:\n                # Remove trailing empty lines\n                while lines and lines[-1] == \"\":\n                    lines.pop()\n\n                if lines:  # Check again after removing empty lines\n                    display_content = '\\n'.join(lines)\n\n                    # Only update if content has changed\n                    if display_content != self._last_display_content:\n                        # Clear previous display\n                        self._clear_display()\n\n                        output = display_content + '\\n'\n                        self.file.write(output)\n                        self.file.flush()\n                        self._lines_written = len(lines)\n                        self._last_display_content = display_content\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.file","title":"<code>file = file or sys.stdout</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressManager.max_workers","title":"<code>max_workers = max_workers</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressManager.use_colors","title":"<code>use_colors = use_colors and ColorTheme.supports_color()</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressManager.use_emojis","title":"<code>use_emojis = use_emojis</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressManager.__init__","title":"<code>__init__(max_workers=5, file=None, use_colors=True, use_emojis=True, update_interval=0.1)</code>","text":"<p>Initialize the progress manager.</p> <p>Parameters:</p> Name Type Description Default <code>max_workers</code> <code>int</code> <p>Maximum number of concurrent progress bars to display</p> <code>5</code> <code>file</code> <code>Optional[TextIO]</code> <p>Output stream (defaults to sys.stdout)</p> <code>None</code> <code>use_colors</code> <code>bool</code> <p>Enable color output</p> <code>True</code> <code>use_emojis</code> <code>bool</code> <p>Enable emoji indicators</p> <code>True</code> Source code in <code>ktoolbox/progress.py</code> <pre><code>def __init__(self, max_workers: int = 5, file: Optional[TextIO] = None,\n             use_colors: bool = True, use_emojis: bool = True,\n             update_interval: float = 0.1):\n    \"\"\"\n    Initialize the progress manager.\n\n    :param max_workers: Maximum number of concurrent progress bars to display\n    :param file: Output stream (defaults to sys.stdout)\n    :param use_colors: Enable color output\n    :param use_emojis: Enable emoji indicators\n    \"\"\"\n    self.max_workers = max_workers\n    self.file = file or sys.stdout\n    self.use_colors = use_colors and ColorTheme.supports_color()\n    self.use_emojis = use_emojis\n    self._progress_bars: Dict[str, ProgressState] = {}\n    self._display_order: List[str] = []\n    self._lock = threading.RLock()\n    self._display_task: Optional[asyncio.Task] = None\n    self._running = False\n    self._total_jobs = 0\n    self._completed_jobs = 0\n    self._failed_jobs = 0\n    self._existed_jobs = 0\n\n    # Terminal control\n    self._lines_written = 0\n    self._last_display_time = 0\n    # Update interval (seconds). When downloads change, refresh at most\n    # once per `update_interval`. Default is 1.0s to avoid excessive redraws.\n    self._update_interval = float(update_interval)\n\n    # Display deduplication\n    self._last_display_content = \"\"\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.create_progress_bar","title":"<code>create_progress_bar(desc, total=None, unit='B', unit_scale=True)</code>","text":"<p>Create a new managed progress bar</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def create_progress_bar(self, desc: str, total: Optional[int] = None,\n                      unit: str = \"B\", unit_scale: bool = True) -&gt; 'ManagedTqdm':\n    \"\"\"Create a new managed progress bar\"\"\"\n    # Don't create progress state here - let ManagedTqdm do it with proper unique ID\n    return ManagedTqdm(desc=desc, total=total, unit=unit, unit_scale=unit_scale, manager=self)\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.finish_progress","title":"<code>finish_progress(progress_id, failed=False)</code>","text":"<p>Mark a progress bar as finished</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def finish_progress(self, progress_id: str, failed: bool = False):\n    \"\"\"Mark a progress bar as finished\"\"\"\n    with self._lock:\n        if progress_id in self._progress_bars:\n            self._progress_bars[progress_id].finished = True\n            self._progress_bars[progress_id].failed = failed\n            # Remove finished progress bar immediately in sync context\n            # to avoid coroutine warnings\n            try:\n                loop = asyncio.get_running_loop()\n                # Only create task if we're in an async context with a running loop\n                loop.create_task(self._remove_finished_after_delay(progress_id))\n            except RuntimeError:\n                # No event loop running, remove immediately\n                if progress_id in self._progress_bars:\n                    del self._progress_bars[progress_id]\n                if progress_id in self._display_order:\n                    self._display_order.remove(progress_id)\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.increment_existed","title":"<code>increment_existed(n=1)</code>","text":"<p>Atomically increment the existed count by n and return the new value</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def increment_existed(self, n: int = 1) -&gt; int:\n    \"\"\"Atomically increment the existed count by n and return the new value\"\"\"\n    with self._lock:\n        self._existed_jobs += n\n        return self._existed_jobs\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.restore_display","title":"<code>restore_display()</code>","text":"<p>Restore display after log output</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def restore_display(self):\n    \"\"\"Restore display after log output\"\"\"\n    if self._running and self.file.isatty():\n        # Force immediate display update\n        self.update_display()\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.set_job_totals","title":"<code>set_job_totals(total, completed=0, failed=0, existed=0)</code>","text":"<p>Set the total number of jobs for overall progress tracking</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def set_job_totals(self, total: int, completed: int = 0, failed: int = 0, existed: int = 0):\n    \"\"\"Set the total number of jobs for overall progress tracking\"\"\"\n    with self._lock:\n        self._total_jobs = total\n        self._completed_jobs = completed\n        self._failed_jobs = failed\n        self._existed_jobs = existed\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.start_display","title":"<code>start_display()</code>","text":"<p>Start the progress display loop</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def start_display(self):\n    \"\"\"Start the progress display loop\"\"\"\n    if not self._running and self.file.isatty():\n        self._running = True\n        # Hide cursor\n        self.file.write('\\033[?25l')\n        self.file.flush()\n        # Set as active progress manager for logger integration\n        setup_logger_for_progress(self)\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.stop_display","title":"<code>stop_display()</code>","text":"<p>Stop the progress display loop</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def stop_display(self):\n    \"\"\"Stop the progress display loop\"\"\"\n    if self._running:\n        self._running = False\n        # Clear display area and show cursor\n        self._clear_display()\n        self.file.write('\\033[?25h\\n')\n        self.file.flush()\n        # Remove from logger integration\n        setup_logger_for_progress(None)\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.temporary_clear_for_log","title":"<code>temporary_clear_for_log(log_message=None)</code>","text":"<p>Temporarily clear display to allow log output</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def temporary_clear_for_log(self, log_message: str = None):\n    \"\"\"Temporarily clear display to allow log output\"\"\"\n    if self._running and self.file.isatty():\n        self._clear_display()\n        # Reset last display content so we redraw after logging\n        self._last_display_content = \"\"\n        if log_message:\n            self.file.write(log_message + '\\n')\n            self.file.flush()\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.update_display","title":"<code>update_display()</code>","text":"<p>Update the terminal display</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def update_display(self):\n    \"\"\"Update the terminal display\"\"\"\n    if not self._running or not self.file.isatty():\n        return\n\n    current_time = time.time()\n    if current_time - self._last_display_time &lt; self._update_interval:\n        return\n\n    self._last_display_time = current_time\n\n    with self._lock:\n        # Render new display\n        lines = []\n\n        # Overall progress\n        overall_lines = self._render_overall_progress()\n        if overall_lines:\n            lines.extend(overall_lines)\n            lines.append(\"\")  # Separator\n\n        # Individual progress bars\n        progress_lines = self._render_progress_bars()\n        lines.extend(progress_lines)\n\n        # Write to terminal only if we have content and it's different from last display\n        if lines:\n            # Remove trailing empty lines\n            while lines and lines[-1] == \"\":\n                lines.pop()\n\n            if lines:  # Check again after removing empty lines\n                display_content = '\\n'.join(lines)\n\n                # Only update if content has changed\n                if display_content != self._last_display_content:\n                    # Clear previous display\n                    self._clear_display()\n\n                    output = display_content + '\\n'\n                    self.file.write(output)\n                    self.file.flush()\n                    self._lines_written = len(lines)\n                    self._last_display_content = display_content\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.update_job_progress","title":"<code>update_job_progress(completed=None, failed=None, existed=None)</code>","text":"<p>Update overall job progress</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def update_job_progress(self, completed: int = None, failed: int = None, existed: int = None):\n    \"\"\"Update overall job progress\"\"\"\n    with self._lock:\n        if completed is not None:\n            self._completed_jobs = completed\n        if failed is not None:\n            self._failed_jobs = failed\n        if existed is not None:\n            self._existed_jobs = existed\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressManager.update_progress","title":"<code>update_progress(progress_id, current, desc=None, failed=False)</code>","text":"<p>Update progress for a specific progress bar</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def update_progress(self, progress_id: str, current: int, desc: str = None, failed: bool = False):\n    \"\"\"Update progress for a specific progress bar\"\"\"\n    with self._lock:\n        if progress_id in self._progress_bars:\n            state = self._progress_bars[progress_id]\n            state.current = current\n            state.failed = failed\n            if desc:\n                state.desc = desc\n            state.last_update = time.time()\n\n            # Calculate rate\n            if hasattr(state, '_last_current') and hasattr(state, '_last_time'):\n                time_diff = state.last_update - state._last_time\n                if time_diff &gt; 0:\n                    current_diff = current - state._last_current\n                    state.rate = current_diff / time_diff\n\n            state._last_current = current\n            state._last_time = state.last_update\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressState","title":"<code>ProgressState</code>  <code>dataclass</code>","text":"<p>Represents the state of a single progress bar</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>@dataclass\nclass ProgressState:\n    \"\"\"Represents the state of a single progress bar\"\"\"\n    desc: str = \"\"\n    total: Optional[int] = None\n    current: int = 0\n    unit: str = \"it\"\n    unit_scale: bool = False\n    rate: Optional[float] = None\n    last_update: float = field(default_factory=time.time)\n    # Tracks the last state timestamp that was actually rendered.\n    # Used to avoid advancing animation frames or forcing redraws\n    # when nothing meaningful has changed.\n    _last_render_seen: float = 0.0\n    finished: bool = False\n    failed: bool = False\n    paused: bool = False\n</code></pre>"},{"location":"api/#ktoolbox.progress.ProgressState.current","title":"<code>current: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.desc","title":"<code>desc: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.failed","title":"<code>failed: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.finished","title":"<code>finished: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.last_update","title":"<code>last_update: float = field(default_factory=time.time)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.paused","title":"<code>paused: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.rate","title":"<code>rate: Optional[float] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.total","title":"<code>total: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.unit","title":"<code>unit: str = 'it'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.unit_scale","title":"<code>unit_scale: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.progress.ProgressState.__init__","title":"<code>__init__(desc='', total=None, current=0, unit='it', unit_scale=False, rate=None, last_update=time.time(), _last_render_seen=0.0, finished=False, failed=False, paused=False)</code>","text":""},{"location":"api/#ktoolbox.progress.create_managed_tqdm_class","title":"<code>create_managed_tqdm_class(progress_manager)</code>","text":"<p>Create a tqdm class factory that uses the given ProgressManager. This allows us to create a drop-in replacement for tqdm.</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def create_managed_tqdm_class(progress_manager: ProgressManager):\n    \"\"\"\n    Create a tqdm class factory that uses the given ProgressManager.\n    This allows us to create a drop-in replacement for tqdm.\n    \"\"\"\n    class ManagedTqdmClass(ManagedTqdm):\n        def __init__(self, *args, **kwargs):\n            kwargs['manager'] = progress_manager\n            super().__init__(*args, **kwargs)\n\n    return ManagedTqdmClass\n</code></pre>"},{"location":"api/#ktoolbox.progress.setup_logger_for_progress","title":"<code>setup_logger_for_progress(progress_manager=None)</code>","text":"<p>Setup logger to work with progress manager</p> Source code in <code>ktoolbox/progress.py</code> <pre><code>def setup_logger_for_progress(progress_manager: 'ProgressManager' = None):\n    \"\"\"Setup logger to work with progress manager\"\"\"\n    global _active_progress_manager\n    _active_progress_manager = progress_manager\n</code></pre>"},{"location":"api/#ktoolbox.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.utils.__all__","title":"<code>__all__ = ['BaseRet', 'generate_msg', 'logger_init', 'dump_search', 'parse_webpage_url', 'uvloop_init', 'extract_external_links', 'check_for_updates']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet","title":"<code>BaseRet</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[_T]</code></p> <p>Base data model of function return value</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>class BaseRet(BaseModel, Generic[_T]):\n    \"\"\"Base data model of function return value\"\"\"\n    code: int = RetCodeEnum.Success.value\n    message: str = ''\n    exception: Optional[Exception] = None\n    data: Optional[_T] = None\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __bool__(self):\n        return self.code == RetCodeEnum.Success\n</code></pre>"},{"location":"api/#ktoolbox.utils.BaseRet.code","title":"<code>code: int = RetCodeEnum.Success.value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.data","title":"<code>data: Optional[_T] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.exception","title":"<code>exception: Optional[Exception] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.message","title":"<code>message: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.__bool__","title":"<code>__bool__()</code>","text":"Source code in <code>ktoolbox/utils.py</code> <pre><code>def __bool__(self):\n    return self.code == RetCodeEnum.Success\n</code></pre>"},{"location":"api/#ktoolbox.utils.check_for_updates","title":"<code>check_for_updates()</code>  <code>async</code>","text":"<p>Check for updates from GitHub and PyPI (backup). Show information if a newer version is available.</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>async def check_for_updates() -&gt; None:\n    \"\"\"\n    Check for updates from GitHub and PyPI (backup).\n    Show information if a newer version is available.\n    \"\"\"\n    try:\n        import httpx\n        from ktoolbox import __version__\n\n        current_version = __version__.lstrip('v')  # Remove 'v' prefix if present\n\n        # First try GitHub API\n        try:\n            async with httpx.AsyncClient(timeout=5.0) as client:\n                response = await client.get(\"https://api.github.com/repos/Ljzd-PRO/KToolBox/releases/latest\")\n                if response.status_code == 200:\n                    data = response.json()\n                    latest_version = data[\"tag_name\"].lstrip('v')\n                    if latest_version != current_version:\n                        logger.info(f\"Update available: {latest_version} (current: {current_version})\")\n                        logger.info(f\"Release URL: {data['html_url']}\")\n                        return\n                    else:\n                        logger.debug(\"You are using the latest version\")\n                        return\n        except Exception as e:\n            logger.debug(f\"Failed to check GitHub for updates: {e}\")\n\n        # Fallback to PyPI API\n        try:\n            async with httpx.AsyncClient(timeout=5.0) as client:\n                response = await client.get(\"https://pypi.org/pypi/ktoolbox/json\")\n                if response.status_code == 200:\n                    data = response.json()\n                    latest_version = data[\"info\"][\"version\"].lstrip('v')\n                    if latest_version != current_version:\n                        logger.info(f\"Update available: {latest_version} (current: {current_version})\")\n                        logger.info(\"Run 'pip install --upgrade ktoolbox' or 'pipx upgrade ktoolbox' to update\")\n                    else:\n                        logger.debug(\"You are using the latest version\")\n        except Exception as e:\n            logger.debug(f\"Failed to check PyPI for updates: {e}\")\n\n    except Exception as e:\n        logger.warning(f\"Update check encountered an unexpected error: {e!r}\")\n</code></pre>"},{"location":"api/#ktoolbox.utils.dump_search","title":"<code>dump_search(result, path)</code>  <code>async</code>","text":"Source code in <code>ktoolbox/utils.py</code> <pre><code>async def dump_search(result: List[BaseModel], path: Path):\n    async with aiofiles.open(str(path), \"w\", encoding=\"utf-8\") as f:\n        await f.write(\n            SearchResult(result=result)\n            .model_dump_json(indent=config.json_dump_indent)\n        )\n</code></pre>"},{"location":"api/#ktoolbox.utils.extract_external_links","title":"<code>extract_external_links(content, custom_patterns=None)</code>","text":"<p>Extract external file sharing links from text content.</p> <p>Targets common cloud storage and file sharing services like: - Google Drive - MEGA - Dropbox - OneDrive - MediaFire - And other common file hosting services</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Text content to extract links from</p> required <code>custom_patterns</code> <code>Optional[List[str]]</code> <p>Custom regex patterns to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set of unique external links found</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def extract_external_links(content: str, custom_patterns: Optional[List[str]] = None) -&gt; Set[str]:\n    \"\"\"\n    Extract external file sharing links from text content.\n\n    Targets common cloud storage and file sharing services like:\n    - Google Drive\n    - MEGA\n    - Dropbox\n    - OneDrive\n    - MediaFire\n    - And other common file hosting services\n\n    :param content: Text content to extract links from\n    :param custom_patterns: Custom regex patterns to use.\n    :return: Set of unique external links found\n    \"\"\"\n    if not content:\n        return set()\n\n    external_link_patterns = custom_patterns if custom_patterns is not None else []\n\n    links = set()\n\n    # Combine all patterns\n    combined_pattern = '|'.join(f'({pattern})' for pattern in external_link_patterns)\n\n    # Find all matches\n    matches = re.finditer(combined_pattern, content, re.IGNORECASE)\n\n    for match in matches:\n        # Get the full matched URL\n        url = match.group(0)\n\n        # Clean up HTML markup and common trailing punctuation that might be part of text\n        # Stop at common HTML boundary characters and quotes\n        url = re.sub(r'[\"\\'&gt;][^&lt;]*$', '', url)  # Remove quote + content to end\n\n        # Additional cleanup: Remove HTML tags that might have been captured\n        url = re.sub(r'&lt;[^&gt;]*&gt;.*$', '', url)  # Remove any HTML tags and everything after\n        url = re.sub(r'\"[^\"]*$', '', url)  # Remove quote and everything after it\n\n        # Remove trailing HTML tag fragments and punctuation\n        url = re.sub(r'&lt;/[^&gt;]*&gt;?$', '', url)  # Remove closing tags or partial tags at end\n        url = re.sub(r'[.,;!?)\\]}&gt;\"\\'\\s]+$', '', url)  # Remove trailing punctuation\n\n        # Decode HTML entities (like &amp;amp; -&gt; &amp;, &amp;lt; -&gt; &lt;, etc.)\n        url = html.unescape(url)\n\n        # Validate that it looks like a proper URL\n        if len(url) &gt; 10 and '.' in url:\n            links.add(url)\n\n    return links\n</code></pre>"},{"location":"api/#ktoolbox.utils.generate_msg","title":"<code>generate_msg(title=None, **kwargs)</code>","text":"<p>Generate message for <code>BaseRet</code> and logger</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Message title</p> <code>None</code> <code>kwargs</code> <p>Extra data</p> <code>{}</code> Source code in <code>ktoolbox/utils.py</code> <pre><code>def generate_msg(title: str = None, **kwargs):\n    \"\"\"\n    Generate message for ``BaseRet`` and logger\n\n    :param title: Message title\n    :param kwargs: Extra data\n    \"\"\"\n    title: str = title or \"\"\n    extra_data = \", \".join(f\"{k}: {v}\" for k, v in kwargs.items())\n    if title:\n        return f\"{title} - {extra_data}\" if kwargs else title\n    else:\n        return extra_data if kwargs else \"\"\n</code></pre>"},{"location":"api/#ktoolbox.utils.logger_init","title":"<code>logger_init(cli_use=False, disable_stdout=False)</code>","text":"<p>Initialize <code>loguru</code> logger</p> <p>Parameters:</p> Name Type Description Default <code>cli_use</code> <code>bool</code> <p>Set logger level <code>INFO</code> and filter out <code>SUCCESS</code></p> <code>False</code> <code>disable_stdout</code> <code>bool</code> <p>Disable default output stream</p> <code>False</code> Source code in <code>ktoolbox/utils.py</code> <pre><code>def logger_init(cli_use: bool = False, disable_stdout: bool = False):\n    \"\"\"\n    Initialize ``loguru`` logger\n\n    :param cli_use: Set logger level ``INFO`` and filter out ``SUCCESS``\n    :param disable_stdout: Disable default output stream\n    \"\"\"\n    if disable_stdout:\n        logger.remove()\n    elif cli_use:\n        logger.remove()\n        logger.add(\n            tqdm.write,\n            colorize=True,\n            format=\"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss}&lt;/green&gt; | \"\n                   \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n                   \"&lt;cyan&gt;{name}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;\",\n            level=logging.INFO,\n            filter=lambda record: record[\"level\"].name != \"DEBUG\"\n        )\n    if path := config.logger.path:\n        path.mkdir(exist_ok=True)\n        if path is not None:\n            logger.add(\n                path / DataStorageNameEnum.LogData.value,\n                level=config.logger.level,\n                rotation=config.logger.rotation,\n                diagnose=True\n            )\n</code></pre>"},{"location":"api/#ktoolbox.utils.parse_webpage_url","title":"<code>parse_webpage_url(url)</code>","text":"<p>Fetch service, user_id, post_id, revision_id from webpage url</p> <p>Each part can be <code>None</code> if not found in url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Kemono Webpage url</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str], Optional[str], Optional[str]]</code> <p>Tuple of service, user_id, post_id, revision_id</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def parse_webpage_url(url: str) -&gt; Tuple[Optional[str], Optional[str], Optional[str], Optional[str]]:\n    # noinspection SpellCheckingInspection\n    \"\"\"\n    Fetch **service**, **user_id**, **post_id**, **revision_id** from webpage url\n\n    Each part can be ``None`` if not found in url.\n\n    :param url: Kemono Webpage url\n    :return: Tuple of **service**, **user_id**, **post_id**, **revision_id**\n    \"\"\"\n    path_url = Path(url)\n    parts = path_url.parts\n    if (url_parts_len := len(parts)) &lt; 9:\n        # Pad to full size (now supporting revision URLs)\n        parts += tuple(None for _ in range(9 - url_parts_len))\n    _scheme, _netloc, service, _user_key, user_id, _post_key, post_id, _revision_key, revision_id = parts\n\n    # Only return revision_id if we have the revision keyword\n    if _revision_key != \"revision\":\n        revision_id = None\n\n    return service, user_id, post_id, revision_id\n</code></pre>"},{"location":"api/#ktoolbox.utils.uvloop_init","title":"<code>uvloop_init()</code>","text":"<p>Set event loop policy to uvloop or winloop if available.</p> <p>Uses winloop on Windows and uvloop on Unix-like systems for performance optimization.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If event loop policy was set successfully</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def uvloop_init() -&gt; bool:\n    \"\"\"\n    Set event loop policy to uvloop or winloop if available.\n\n    Uses winloop on Windows and uvloop on Unix-like systems for performance optimization.\n\n    :return: If event loop policy was set successfully\n    \"\"\"\n    if config.use_uvloop:\n        if sys.platform == \"win32\":\n            # Try to use winloop on Windows\n            try:\n                # noinspection PyUnresolvedReferences\n                import winloop\n            except ModuleNotFoundError:\n                logger.debug(\n                    \"winloop is not installed, but it's optional. \"\n                    \"You can install it with `pip install ktoolbox[winloop]`\"\n                )\n            else:\n                asyncio.set_event_loop_policy(winloop.EventLoopPolicy())\n                logger.success(\"Set event loop policy to winloop successfully.\")\n                return True\n        else:\n            # Try to use uvloop on Unix-like systems\n            try:\n                # noinspection PyUnresolvedReferences\n                import uvloop\n            except ModuleNotFoundError:\n                logger.debug(\n                    \"uvloop is not installed, but it's optional. \"\n                    \"You can install it with `pip install ktoolbox[uvloop]`\"\n                )\n            else:\n                asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n                logger.success(\"Set event loop policy to uvloop successfully.\")\n                return True\n    return False\n</code></pre>"},{"location":"coomer/","title":"Coomer","text":"<p>KToolBox support downloading from Coomer.st / Coomer.su / Coomer.party</p> <p>You need to modify the configuration by <code>.env</code> or <code>prod.env</code> dotenv file or system environment variables: <pre><code># For Coomer API\nKTOOLBOX_API__NETLOC=coomer.st\n\n# For downloading files from Coomer server\nKTOOLBOX_API__FILES_NETLOC=coomer.st\n</code></pre></p>"},{"location":"coomer/#about-coomer","title":"About Coomer","text":"<p>Description from https://coomer.st :</p> <p>Coomer is a public archiver for:</p> <ul> <li>OnlyFans</li> <li>Fansly</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. To get started viewing content, either search for creators on the creators page, or search for content on the posts page. If you want to contribute content, head over to the import page.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-to-solve-the-failure-of-uvloopwinloop-installation","title":"How to solve the failure of uvloop/winloop installation?","text":"<p>It's optional</p> <p>Event loop optimization (uvloop/winloop) can improve concurrent performance, but it's optional.  If you don't want to install these packages, you can ignore this step.</p> <p>KToolBox now supports platform-specific event loop optimization:</p> <ul> <li>Windows: Uses <code>winloop</code> for improved performance</li> <li>Linux/macOS: Uses <code>uvloop</code> for improved performance</li> </ul>"},{"location":"faq/#installing-event-loop-optimizations","title":"Installing event loop optimizations","text":"WindowsLinux/macOS <pre><code>pip install ktoolbox[winloop]\n</code></pre> <pre><code>pip install ktoolbox[uvloop]\n</code></pre> <p>If you failed installing uvloop on Linux or macOS, you can try to install it with system package manager like apt, yum or brew, as package managers provide prebuilt wheels for uvloop.</p> <ul> <li>Install with apt     <pre><code>sudo apt install python3-uvloop\n</code></pre></li> </ul>"},{"location":"faq/#attachments-folder-inside-post-directory-is-no-need-for-me","title":"<code>attachments</code> folder inside post directory is no need for me","text":"<p>You can set configuration option <code>job.post_structure.attachments</code> to <code>./</code></p> <p>Set the configuration by <code>prod.env</code> dotenv file or system environment variables: <pre><code>KTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n</code></pre></p> <p><code>./</code> means attachments will be downloaded directly into the post directory.</p> <p>Notice</p> <p>For more information, please visit Configuration-Guide page.</p>"},{"location":"faq/#how-to-disable-cover-image-download","title":"How to disable cover image download?","text":"<p>You can set configuration option <code>job.download_file</code> to <code>False</code> to disable cover image (file) download functionality.</p> <p>Set the configuration by <code>prod.env</code> dotenv file or system environment variables: <pre><code># Disable cover image download\nKTOOLBOX_JOB__DOWNLOAD_FILE=False\n\n# If you also want to disable attachment downloads, you can set\n#KTOOLBOX_JOB__DOWNLOAD_ATTACHMENTS=False\n</code></pre></p> <p>With this setting, KToolBox will only download attachments and skip file downloads. This is useful when some authors have garbled image names that require renaming functionality to sort by webpage order.</p> <p>Notice</p> <ul> <li><code>download_file</code>: Controls whether to download post file (usually cover image)</li> <li><code>download_attachments</code>: Controls whether to download post attachments  </li> <li>Both options default to <code>True</code> for backward compatibility</li> </ul>"},{"location":"faq/#commands-and-flags-should-use-or-_-as-seperator","title":"Commands and flags should use <code>-</code> or <code>_</code> as seperator?","text":"<p>Both is support, <code>-</code> is suggested.</p>"},{"location":"faq/#filename-too-long","title":"Filename too long","text":"<p>In some cases, the filename or the post directory name can be too long and caused download failure. To solve this issue, you can set sequential filename or use custom post directory name</p> <p>Set the configuration by <code>prod.env</code> dotenv file or system environment variables: <pre><code># Rename attachments in numerical order, e.g. `1.png`, `2.png`, ...\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# Set the post directory name to its release/publish date and ID, e.g. `[2024-1-1]11223344`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{id}\n</code></pre></p>"},{"location":"faq/#how-to-configure-a-proxy","title":"How to Configure a Proxy?","text":"<p>You can set the <code>HTTPS_PROXY</code>, <code>HTTP_PROXY</code>, and <code>ALL_PROXY</code> environment variables to achieve this.</p> <p>Refer to: HTTPX - Environment Variables</p> <p>For example, set it like this:</p> <pre><code># Unix Shell\nexport HTTPS_PROXY=http://127.0.0.1:7897\nexport HTTP_PROXY=http://127.0.0.1:7897\nexport ALL_PROXY=socks5://127.0.0.1:7897\n</code></pre> <pre><code># Windows PowerShell\n$env:HTTP_PROXY=\"http://127.0.0.1:7897\"; $env:HTTPS_PROXY=\"http://127.0.0.1:7897\"\n</code></pre>"},{"location":"faq/#gui-configuration-editor-cannot-be-opened","title":"GUI Configuration Editor Cannot Be Opened","text":"<p>Note</p> <p><code>ktoolbox-pure-py</code> does not support the graphical configuration editor.</p> <p>By default, the dependencies for the graphical configuration editor are not installed. You can install them using the following command:</p> <pre><code>pip3 install ktoolbox[urwid]\n</code></pre> <p>If you are using pipx:</p> <pre><code>pipx install ktoolbox[urwid] --force\n</code></pre>"},{"location":"faq/#kemono-api-call-failed","title":"Kemono API Call Failed","text":"<p>For example:</p> <pre><code>ktoolbox sync-creator \"https://coomer.su/onlyfans/user/hollyharper11\" --start-time=\"2020-05-01\" --end-time=\"2025-01-01\"\n\n2024-05-12 12:52:51.477 | INFO     | ktoolbox.cli:sync_creator:271 - Got creator information - {'name': 'hollyharper11', 'id': 'hollyharper11'}\n2024-05-12 12:52:51.479 | INFO     | ktoolbox.action.job:create_job_from_creator:148 - Start fetching posts from creator hollyharper11\n2024-05-12 12:52:56.477 | ERROR    | ktoolbox.api.base:_retry_error_callback:37 - Kemono API call failed - {'ret': APIRet(code=1002, message=\"1 validation error for Response\\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\\\n&lt;html&gt;\\\\...&gt;\\\\n  &lt;/body&gt;\\\\n&lt;/html&gt;\\\\n', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\", exception=1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid, data=None)}\n1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\n</code></pre> <ol> <li> <p>This is generally caused by frequent requests, so you can try setting a higher number of API retry attempts.     <pre><code># .env / prod.env\nKTOOLBOX_API__RETRY_TIMES=10\n</code></pre></p> </li> <li> <p>You can set session key (can be found in cookies after a successful login) for download     <pre><code># .env / prod.env\nKTOOLBOX_API__SESSION_KEY=\"xxxxxxx\"\n</code></pre></p> </li> </ol> <p>You can also set these through the graphical configuration editor: <code>API - retry_times</code> and <code>API -&gt; session_key</code>.</p>"},{"location":"faq/#frequently-encounter-403-errors-during-downloads","title":"Frequently encounter 403 errors during downloads","text":"<p>The solution is the same as above.</p>"},{"location":"faq/#antivirus-software-flags-the-executable-as-a-virusthreat","title":"Antivirus software flags the executable as a virus/threat","text":"<p>This is a false positive. KToolBox is completely safe and open-source software.</p> <p>Why this happens: - PyInstaller executables are commonly flagged by antivirus engines due to their packing method - Downloaded executables from the internet are often treated with suspicion - Some heuristic engines flag any \"download manager\" type software</p> <p>Solutions: 1. Add an exception in your antivirus software for the KToolBox executable 2. Use pipx or pip installation instead 3. Build from source if you're still concerned:    <pre><code>git clone https://github.com/Ljzd-PRO/KToolBox.git\ncd KToolBox\npoetry install --with pyinstaller\npoetry run pyinstaller ktoolbox.spec\n</code></pre></p> <p>Security assurance: - All releases are built automatically using GitHub Actions (publicly visible) - Source code is completely open and auditable - No malicious code exists in this project</p>"},{"location":"faq/#post-title-too-long-to-create-directory-or-download-file","title":"Post title too long to create directory or download file","text":"<p>Tip</p> <p>For more information about Python format specification mini-language, please refer to Format Specification Mini-Language</p> <p>In some cases, overly long post titles may cause download failures. To solve this problem, you can use the Python format specification mini-language to limit the title length in the custom post directory name format.</p> <p>You can set this configuration via the graphical configuration editor, dotenv file <code>.env</code>, or system environment variables: <pre><code># Set the post directory name to the first 30 characters of its title\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT={title:.30}\n\n# If you need to include the title in a custom filename format, you can also limit its length\nKTOOLBOX_JOB__FILENAME_FORMAT={title:.30}_{}\n</code></pre></p>"},{"location":"faq/#where-can-i-find-more-information-about-ktoolbox","title":"Where can I find more information about KToolBox?","text":"<ul> <li>Guide: Use AI(Copilot Spaces) for command params and configuration help: #304</li> <li>A community-shared usage guide: #141</li> </ul>"},{"location":"more/","title":"More","text":""},{"location":"more/#other-branches","title":"Other Branches","text":"<ul> <li>Pure Python branch: \ud83d\udd17pure-py</li> </ul> <p>About</p> <ul> <li>Use pydantic v1 so that cargo is not needed for installation</li> <li>For example, you can use it on iOS terminal App a-Shell</li> <li>\ud83d\udd17PyPI</li> </ul> <ul> <li>Development branch: \ud83d\udd17devel</li> </ul>"},{"location":"more/#code-coverage","title":"Code Coverage","text":""},{"location":"more/#license","title":"License","text":"<p>KToolBox is licensed under BSD 3-Clause.</p> <p>Copyright \u00a9 2023 by Ljzd-PRO.</p>"},{"location":"shortcut/","title":"Shortcuts for iOS","text":"<p>You can run KToolBox using iOS terminal App a-Shell, and the following shortcuts  can help you automatically install KToolBox and download posts</p>"},{"location":"shortcut/#get-the-shortcuts","title":"Get the shortcuts","text":"<p>Visit shortcut URLs below or download shortcut files at <code>shortcuts/</code></p>"},{"location":"shortcut/#english","title":"English","text":"<ul> <li>KToolBox Manager</li> <li>Download Kemono Post</li> </ul>"},{"location":"shortcut/#chinese","title":"Chinese","text":"<ul> <li>KToolBox \u7ba1\u7406\u5668</li> <li>\u4e0b\u8f7d Kemono \u5e16\u5b50</li> </ul>"},{"location":"shortcut/#usage","title":"Usage","text":"<ul> <li>Use \"KToolBox Manager\" to install, update, uninstall KToolBox in a-Shell</li> <li>You can trigger \"Download Kemono Post\" by web page share view, or run directly in Shortcuts App</li> </ul>"},{"location":"commands/guide/","title":"Guide","text":"<p>Check Reference for all commands and their flags / parameters.</p>"},{"location":"commands/guide/#get-general-help","title":"Get general help","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox -h\n</code></pre>"},{"location":"commands/guide/#get-help-of-a-command","title":"Get help of a command","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"commands/guide/#launch-the-graphical-configuration-editor","title":"Launch the graphical configuration editor","text":"<p><code>config-editor</code></p> <pre><code>ktoolbox config-editor\n</code></pre>"},{"location":"commands/guide/#generate-an-example-configuration-file-envprodenv","title":"Generate an example configuration file (<code>.env</code>/<code>prod.env</code>)","text":"<p><code>example-env</code></p> <pre><code>ktoolbox example-env\n</code></pre>"},{"location":"commands/guide/#download-a-specific-post","title":"Download a specific post","text":"<p><code>download-post</code></p> <pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> If some files failed to download <p>If some files failed to download, you can try to execute the command line again,  the downloaded files will be skipped.</p>"},{"location":"commands/guide/#download-all-posts-from-a-creator","title":"Download all posts from a creator","text":"<p><code>sync-creator</code></p> <pre><code># Download all posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016\n</code></pre> Update creator directory <p>You can rerun the command, files with the same filename will be skipped.</p>"},{"location":"commands/guide/#download-a-specified-number-of-posts-from-the-creator","title":"Download a specified number of posts from the creator","text":"<p><code>sync-creator</code></p> <ul> <li><code>--offset</code>: Posts result offset (or start offset)</li> <li><code>--length</code>: The number of posts to fetch, defaults to fetching all posts</li> </ul> <pre><code># Download latest 10 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# Download latest No.11-No.15 posts of the creator/artist\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n</code></pre>"},{"location":"commands/guide/#download-posts-that-published-within-the-specified-time-range","title":"Download posts that published within the specified time range","text":"<p><code>sync-creator</code></p> <ul> <li><code>--start-time</code>: Start time of the published time range for posts downloading.</li> <li><code>--end-time</code>: End time of the published time range for posts downloading.</li> </ul> <pre><code># From 2023-8-5 to 2023-12-6\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5 --end-time=2023-12-6\n\n# From 2023-8-5 to now\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5\n\n# Before 2023-8-5\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --end-time=2023-8-5\n</code></pre>"},{"location":"commands/guide/#time-format","title":"Time Format","text":"<p>The time value should match <code>%Y-%m-%d</code>, for example:</p> <ul> <li><code>2023-12-7</code></li> <li><code>2023-12-07</code></li> <li><code>2023-12-31</code></li> </ul>"},{"location":"commands/reference/","title":"Reference","text":""},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.config_editor","title":"<code>config_editor</code>","text":"<p>Launch graphical KToolBox configuration editor</p>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.download_post","title":"<code>download_post</code>","text":"<p>Download a specific post or revision</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service name</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The creator's ID</p> <code>None</code> <code>post_id</code> <code>str</code> <p>The post ID</p> <code>None</code> <code>revision_id</code> <code>str</code> <p>The revision ID (optional, for revision posts)</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>dump_post_data</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.example_env","title":"<code>example_env</code>","text":"<p>Generate an example configuration <code>.env</code> file.</p>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.get_post","title":"<code>get_post</code>","text":"<p>Get a specific post or revision</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required <code>revision_id</code> <code>str</code> <p>The revision ID (optional, for revision posts)</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.search_creator","title":"<code>search_creator</code>","text":"<p>Search creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.search_creator_post","title":"<code>search_creator_post</code>","text":"<p>Search posts from creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.site_version","title":"<code>site_version</code>","text":"<p>Show current Kemono site app commit hash</p>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.sync_creator","title":"<code>sync_creator</code>","text":"<p>Sync posts from a creator</p> <p>You can update the directory anytime after download finished,         such as to update after creator published new posts.</p> <ul> <li><code>start_time</code> &amp; <code>end_time</code> example: <code>2023-12-7</code>, <code>2023-12-07</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service where the post is located</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>Save all_pages files from different posts at same path,             <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> <code>start_time</code> <code>str</code> <p>Start time of the published time range for posts downloading.             Set to <code>0</code> if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>end_time</code> <code>str</code> <p>End time of the published time range for posts downloading.             Set to latest time (infinity) if <code>None</code> was given.             Time format: <code>%Y-%m-%d</code></p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset (or start offset)</p> <code>0</code> <code>length</code> <code>int</code> <p>The number of posts to fetch, defaults to fetching all posts after <code>offset</code>.</p> <code>None</code> <code>keywords</code> <code>Tuple[str]</code> <p>Comma-separated keywords to filter posts by title (case-insensitive)</p> <code>None</code> <code>keywords_exclude</code> <code>Tuple[str]</code> <p>Comma-separated keywords to exclude posts by title (case-insensitive)</p> <code>None</code>"},{"location":"commands/reference/#ktoolbox.cli.KToolBoxCli.version","title":"<code>version</code>","text":"<p>Show KToolBox version</p>"},{"location":"configuration/guide/","title":"Guide","text":"<p>Graphical Configuration Editor</p> UsageScreenshot <p>Run <code>ktoolbox config-editor</code> to launch,  it will make configuration editing simple and convenient.</p> <ul> <li>Press <code>&lt;Esc&gt;</code> for back, <code>&lt;Enter&gt;</code> for select</li> <li>You can also use the GUI with the mouse</li> </ul> <p> </p> <p>Generate Example <code>.env</code> File</p> <p>Run <code>ktoolbox example-env</code> to generate a complete sample configuration file.</p> <ul> <li>KToolBox load <code>.env</code> or <code>prod.env</code> file in the working directory or environment variables to store configuration</li> <li>The working directory refers to the directory where you execute the <code>ktoolbox</code> command, it is not necessarily the directory where the <code>ktoolbox</code> executable is located. It reads from where you execute it.</li> <li>Check Reference for all configuration options</li> <li>Use <code>__</code> to specify the sub option, like <code>KTOOLBOX_API__SCHEME</code> means <code>api.scheme</code></li> <li>All configuration options are optional</li> </ul>"},{"location":"configuration/guide/#env-prodenv-file-example","title":"<code>.env</code> / <code>prod.env</code> file example","text":"<pre><code>##############################################################################\n#  It is recommended to use the graphical configuration editor for editing.  #\n#  Run `ktoolbox config-editor` to launch it.                                #\n##############################################################################\n\n# (Optional) Session key that can be found in cookies after a successful login\n# Use when 403 Error\n#KTOOLBOX_API__SESSION_KEY=xxxxx\n\n# Download 10 files at the same time.\nKTOOLBOX_JOB__COUNT=10\n\n# Set post attachments directory path as `./`, it means to save all attachments files in post directory\n# without making a new sub directory to storage them\nKTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n\n# Rename attachments in numerical order, e.g. `1.png`, `2.png`, ...\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# Customize the filename format by inserting an empty `{}` to represent the basic filename.\n# Similar to `post_dirname_format`, you can use some of the properties in `Post`.\n# For example: `{title}_{}` &gt; `HelloWorld_b4b41de2-8736-480d-b5c3-ebf0d917561b`, etc.\n# You can also use it with `sequential_filename`. For instance,\n# `[{published}]_{}` &gt; `[2024-1-1]_1.png`, `[2024-1-1]_2.png`, etc.\nKTOOLBOX_JOB__FILENAME_FORMAT=[{published}]_{title}_{id}_{}\n\n# Prefix the post directory name with its release/publish date, e.g. `[2024-1-1]HelloWorld`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{title}\n</code></pre>"},{"location":"configuration/reference/","title":"Reference","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>KToolBox Configuration</p> <p>Attributes:</p> Name Type Description Default <code>api</code> <code>APIConfiguration</code> <p>Kemono API Configuration</p> <code>                       APIConfiguration()               </code> <code>downloader</code> <code>DownloaderConfiguration</code> <p>File Downloader Configuration</p> <code>                       DownloaderConfiguration()               </code> <code>job</code> <code>JobConfiguration</code> <p>Download jobs Configuration</p> <code>                       JobConfiguration()               </code> <code>logger</code> <code>LoggerConfiguration</code> <p>Logger configuration</p> <code>                       LoggerConfiguration()               </code> <code>ssl_verify</code> <code>bool</code> <p>Enable SSL certificate verification for Kemono API server and download server</p> <code>                       True               </code> <code>json_dump_indent</code> <code>int</code> <p>Indent of JSON file dump</p> <code>                       4               </code> <code>use_uvloop</code> <code>bool</code> <p>Use uvloop/winloop for asyncio performance optimization     Uses winloop on Windows and uvloop on Unix-like systems for better concurrent performance.     Install winloop on Windows with <code>pip install ktoolbox[winloop]</code>     or uvloop on Unix with <code>pip install ktoolbox[uvloop]</code>.</p> <code>                       True               </code>"},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration","title":"<code>APIConfiguration</code>","text":"<p>Kemono API Configuration</p> <p>Attributes:</p> Name Type Description Default <code>scheme</code> <code>Literal['http', 'https']</code> <p>Kemono API URL scheme</p> <code>                       'https'               </code> <code>netloc</code> <code>str</code> <p>Kemono API URL netloc</p> <code>                       'kemono.cr'               </code> <code>statics_netloc</code> <code>str</code> <p>URL netloc of Kemono server for static files (e.g. images)</p> <code>                       'img.kemono.cr'               </code> <code>files_netloc</code> <code>str</code> <p>URL netloc of Kemono server for post files</p> <code>                       'kemono.cr'               </code> <code>path</code> <code>str</code> <p>Kemono API URL root path</p> <code>                       '/api/v1'               </code> <code>timeout</code> <code>float</code> <p>API request timeout</p> <code>                       5.0               </code> <code>retry_times</code> <code>int</code> <p>API request retry times (when request failed)</p> <code>                       3               </code> <code>retry_interval</code> <code>float</code> <p>Seconds of API request retry interval</p> <code>                       2.0               </code> <code>session_key</code> <code>str</code> <p>Session key that can be found in cookies after a successful login</p> <code>                       ''               </code>"},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration","title":"<code>DownloaderConfiguration</code>","text":"<p>File Downloader Configuration</p> <p>Attributes:</p> Name Type Description Default <code>scheme</code> <code>Literal['http', 'https']</code> <p>Downloader URL scheme</p> <code>                       'https'               </code> <code>timeout</code> <code>float</code> <p>Downloader request timeout</p> <code>                       30.0               </code> <code>encoding</code> <code>str</code> <p>Charset for filename parsing and post <code>content</code>, <code>external_links</code> saving</p> <code>                       'utf-8'               </code> <code>buffer_size</code> <code>int</code> <p>Number of bytes of file I/O buffer for each downloading file</p> <code>                       20480               </code> <code>chunk_size</code> <code>int</code> <p>Number of bytes of chunk of downloader stream</p> <code>                       1024               </code> <code>temp_suffix</code> <code>str</code> <p>Temp filename suffix of downloading files</p> <code>                       'tmp'               </code> <code>retry_times</code> <code>int</code> <p>Downloader retry times (when download failed)</p> <code>                       10               </code> <code>retry_stop_never</code> <code>bool</code> <p>Never stop downloader from retrying (when download failed)     (<code>retry_times</code> will be ignored when enabled)</p> <code>                       False               </code> <code>retry_interval</code> <code>float</code> <p>Seconds of downloader retry interval</p> <code>                       3.0               </code> <code>tps_limit</code> <code>float</code> <p>Maximum connections established per second</p> <code>                       5.0               </code> <code>use_bucket</code> <code>bool</code> <p>Enable local storage bucket mode</p> <code>                       False               </code> <code>bucket_path</code> <code>Path</code> <p>Path of local storage bucket</p> <code>                       Path('./.ktoolbox/bucket_storage')               </code> <code>reverse_proxy</code> <code>str</code> <p>Reverse proxy format for download URL.     Customize the filename format by inserting an empty <code>{}</code> to represent the original URL.     For example: <code>https://example.com/{}</code> will be <code>https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg</code>;      <code>https://example.com/?url={}</code> will be <code>https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg</code></p> <code>                       '{}'               </code> <code>keep_metadata</code> <code>bool</code> <p>Keep the file metadata when downloading files (e.g. last modified time, etc.)</p> <code>                       True               </code>"},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration","title":"<code>PostStructureConfiguration</code>","text":"<p>Post path structure model</p> <ul> <li> <p>Default: <pre><code>..\n\u251c\u2500 content.txt\n\u251c\u2500 external_links.txt\n\u251c\u2500 {id}_{}.png (file)\n\u251c\u2500 post.json (metadata)\n\u251c\u2500 attachments\n\u2502    \u251c\u2500 1.png\n\u2502    \u2514\u2500 2.png\n\u2514\u2500 revisions\n     \u251c\u2500 &lt;PostStructure&gt;\n     \u2502    \u251c\u2500 ...\n     \u2502    \u2514\u2500 ...\n     \u2514\u2500 &lt;PostStructure&gt;\n          \u251c\u2500 ...\n          \u2514\u2500 ...\n</code></pre></p> </li> <li> <p>Available properties for <code>file</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> </ul> <p>Attributes:</p> Name Type Description Default <code>attachments</code> <code>Path</code> <p>Sub path of attachment directory</p> <code>                       Path('attachments')               </code> <code>content</code> <code>Path</code> <p>Sub path of post content file</p> <code>                       Path('content.txt')               </code> <code>external_links</code> <code>Path</code> <p>Sub path of external links file (for cloud storage links found in content)</p> <code>                       Path('external_links.txt')               </code> <code>file</code> <code>str</code> <p>The format of the post <code>file</code> filename (<code>file</code> is not <code>attachment</code>, each post has only one <code>file</code>, usually the cover image)     Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename.     You can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_Stelle_lv5_logo.gif</code>, <code>TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code>, etc.     Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example:     <code>{title:.6}_{}</code> could shorten the title length to 6 characters like     <code>HiEveryoneThisIsALongTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code> to <code>HiEver_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code></p> <code>                       '{id}_{}'               </code> <code>revisions</code> <code>Path</code> <p>Sub path of revisions directory</p> <code>                       Path('revisions')               </code>"},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration","title":"<code>JobConfiguration</code>","text":"<p>Download jobs Configuration</p> <ul> <li> <p>Available properties for <code>post_dirname_format</code> and <code>filename_format</code></p> Property Type <code>id</code> String <code>user</code> String <code>service</code> String <code>title</code> String <code>added</code> Date <code>published</code> Date <code>edited</code> Date </li> <li> <p>Available properties for <code>year_dirname_format</code> and <code>month_dirname_format</code></p> Property Type <code>year</code> String <code>month</code> String </li> <li> <p>Python Format Specification Mini-Language reference:</p> <p>https://docs.python.org/3.13/library/string.html#format-specification-mini-language</p> </li> </ul> <p>Attributes:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of coroutines for concurrent download</p> <code>                       4               </code> <code>include_revisions</code> <code>bool</code> <p>Include and download revision posts when available</p> <code>                       False               </code> <code>post_dirname_format</code> <code>str</code> <p>Customize the post directory name format, you can use some of the     properties in <code>Post</code>.     e.g. <code>[{published}]{id}</code> could result dirname <code>[2024-1-1]123123</code>,     <code>{user}_{published}_{title}</code> could result dirname like <code>234234_2024-1-1_TheTitle</code>.     Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example:     <code>{title:.6}</code> could shorten the title length to 6 characters like <code>HiEveryoneThisIsALongTitle</code> to <code>HiEver</code></p> <code>                       '{title}'               </code> <code>post_structure</code> <code>PostStructureConfiguration</code> <p>Post path structure</p> <code>                       PostStructureConfiguration()               </code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path in creator directory.     It would not create any post directory, and <code>CreatorIndices</code> would not been recorded.</p> <code>                       False               </code> <code>sequential_filename</code> <code>bool</code> <p>Rename attachments in numerical order, e.g. <code>1.png</code>, <code>2.png</code>, ...</p> <code>                       False               </code> <code>sequential_filename_excludes</code> <code>Set[str]</code> <p>File extensions to exclude from sequential naming when <code>sequential_filename</code> is enabled.     Files with these extensions will keep their original names. e.g. <code>[\".psd\", \".zip\", \".mp4\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>filename_format</code> <code>str</code> <p>Customize the filename format by inserting an empty <code>{}</code> to represent the basic filename. Similar to post_dirname_format, you can use some of the properties     in Post. For example: <code>{title}_{}</code> could result in filenames like     <code>TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b</code>, <code>TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90</code>, etc.     You can also use it with <code>sequential_filename</code>. For instance,     <code>[{published}]_{}</code> could result in filenames like <code>[2024-1-1]_1.png</code>, <code>[2024-1-1]_2.png</code>, etc.     Meanwhile, you can also use the formatting feature of the Python Format Specification Mini-Language, for example:     <code>{title:.6}</code> could shorten the title length to 6 characters like <code>HiEveryoneThisIsALongTitle</code> to <code>HiEver</code></p> <code>                       '{}'               </code> <code>allow_list</code> <code>Set[str]</code> <p>Download files which match these patterns (Unix shell-style), e.g. <code>[\"*.png\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>block_list</code> <code>Set[str]</code> <p>Not to download files which match these patterns (Unix shell-style), e.g. <code>[\"*.psd\",\"*.zip\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>extract_content</code> <code>bool</code> <p>Extract post content and save to separate file (filename was defined in <code>config.job.post_structure.content</code>)</p> <code>                       False               </code> <code>extract_content_images</code> <code>bool</code> <p>Extract images from post content and download them.</p> <code>                       False               </code> <code>extract_external_links</code> <code>bool</code> <p>Extract external file sharing links from post content and save to separate file     (filename was defined in <code>config.job.post_structure.external_links</code>)</p> <code>                       False               </code> <code>external_link_patterns</code> <code>List[str]</code> <p>Regex patterns for extracting external links.</p> <code>                       ['https?://drive\\\\.google\\\\.com/[^\\\\s]+', 'https?://docs\\\\.google\\\\.com/[^\\\\s]+', 'https?://mega\\\\.nz/[^\\\\s]+', 'https?://mega\\\\.co\\\\.nz/[^\\\\s]+', 'https?://(?:www\\\\.)?dropbox\\\\.com/[^\\\\s]+', 'https?://db\\\\.tt/[^\\\\s]+', 'https?://onedrive\\\\.live\\\\.com/[^\\\\s]+', 'https?://1drv\\\\.ms/[^\\\\s]+', 'https?://(?:www\\\\.)?mediafire\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?wetransfer\\\\.com/[^\\\\s]+', 'https?://we\\\\.tl/[^\\\\s]+', 'https?://(?:www\\\\.)?sendspace\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?4shared\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?zippyshare\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?uploadfiles\\\\.io/[^\\\\s]+', 'https?://(?:www\\\\.)?box\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?pcloud\\\\.com/[^\\\\s]+', 'https?://disk\\\\.yandex\\\\.[a-z]+/[^\\\\s]+', 'https?://[^\\\\s]*(?:file|upload|share|download|drive|storage)[^\\\\s]*\\\\.[a-z]{2,4}/[^\\\\s]+']               </code> <code>group_by_year</code> <code>bool</code> <p>Group posts by year in separate directories based on published date</p> <code>                       False               </code> <code>group_by_month</code> <code>bool</code> <p>Group posts by month in separate directories based on published date (requires group_by_year)</p> <code>                       False               </code> <code>year_dirname_format</code> <code>str</code> <p>Customize the year directory name format. Available properties: <code>year</code>.     e.g. <code>{year}</code> &gt; <code>2024</code>, <code>Year_{year}</code> &gt; <code>Year_2024</code></p> <code>                       '{year}'               </code> <code>month_dirname_format</code> <code>str</code> <p>Customize the month directory name format. Available properties: <code>year</code>, <code>month</code>.     e.g. <code>{year}-{month}</code> &gt; <code>2024-01</code>, <code>{year}_{month}</code> &gt; <code>2024_01</code></p> <code>                       '{year}-{month:02d}'               </code> <code>keywords</code> <code>Set[str]</code> <p>keywords to filter posts by title (case-insensitive)</p> <code>                       Field(default_factory=set)               </code> <code>keywords_exclude</code> <code>Set[str]</code> <p>keywords to exclude posts by title (case-insensitive)</p> <code>                       Field(default_factory=set)               </code> <code>download_file</code> <code>bool</code> <p>Download post file (usually cover image). Set to False to skip file downloads.</p> <code>                       True               </code> <code>download_attachments</code> <code>bool</code> <p>Download post attachments. Set to False to skip attachment downloads.</p> <code>                       True               </code> <code>min_file_size</code> <code>Optional[int]</code> <p>Minimum file size in bytes to download. Files smaller than this will be skipped.     Set to None to disable minimum size filtering.</p> <code>                       None               </code> <code>max_file_size</code> <code>Optional[int]</code> <p>Maximum file size in bytes to download. Files larger than this will be skipped.     Set to None to disable maximum size filtering.</p> <code>                       None               </code>"},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration","title":"<code>LoggerConfiguration</code>","text":"<p>Logger configuration</p> <p>Attributes:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to save logs, <code>None</code> for disable log file output</p> <code>                       None               </code> <code>level</code> <code>Union[str, int]</code> <p>Log filter level</p> <code>                       logging.getLevelName(logging.DEBUG)               </code> <code>rotation</code> <code>Union[str, int, time, timedelta]</code> <p>Log rotation</p> <code>                       '1 week'               </code>"},{"location":"zh/","title":"\u6b22\u8fce\u4f7f\u7528 KToolBox","text":"KToolBox  <p>   KToolBox \u662f\u4e00\u4e2a\u7528\u4e8e\u4e0b\u8f7d   Kemono.su / Kemono.party   \u4e2d\u5e16\u5b50\u5185\u5bb9\u7684\u5b9e\u7528\u547d\u4ee4\u884c\u5de5\u5177 </p> <p> </p> <p> </p>"},{"location":"zh/#_1","title":"\u529f\u80fd","text":"<ul> <li>\u652f\u6301\u591a\u6587\u4ef6\u5e76\u53d1\u4e0b\u8f7d</li> <li>API \u8c03\u7528\u548c\u4e0b\u8f7d\u5931\u8d25\u540e \u81ea\u52a8\u91cd\u8bd5</li> <li>\u652f\u6301\u4e0b\u8f7d\u5355\u4e2a\u5e16\u5b50\u4ee5\u53ca\u6307\u5b9a\u7684\u753b\u5e08\u7684 \u5168\u90e8\u5e16\u5b50</li> <li>\u53ef \u66f4\u65b0\u5df2\u4e0b\u8f7d \u7684\u753b\u5e08\u76ee\u5f55\u81f3\u6700\u65b0\u72b6\u6001</li> <li>\u652f\u6301\u81ea\u5b9a\u4e49\u4e0b\u8f7d\u7684\u5e16\u5b50/\u753b\u5e08\u7684 \u6587\u4ef6\u548c\u76ee\u5f55\u540d\u683c\u5f0f\u3001\u76ee\u5f55\u7ed3\u6784</li> <li>\u4f8b\u5982\u5e16\u5b50\u76ee\u5f55\u53ef\u8bbe\u7f6e\u4e3a <code>[2025-01-02]_TheTitle</code> \u7684\u683c\u5f0f\uff0c\u56fe\u7247\u6587\u4ef6\u8bbe\u7f6e\u4e3a\u6309\u987a\u5e8f\u7684 <code>1.jpg</code>\u3001<code>2.jpg</code> \u7b49</li> <li>\u5f53\u4f60\u5e0c\u671b\u5c06\u67d0\u4f5c\u8005\u7684\u6240\u6709\u5e16\u5b50\u56fe\u7247\u7edf\u4e00\u5b58\u653e\u81f3\u4e00\u4e2a\u76ee\u5f55\u4e0b\uff0c\u4ee5\u4fbf\u9884\u89c8\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>job.mix_posts</code> \u914d\u7f6e\u9879\u642d\u914d\u81ea\u5b9a\u4e49\u6587\u4ef6\u540d\u683c\u5f0f\uff0c\u4f60\u5c06\u5f97\u5230\u51e0\u767e\u4e0a\u5343\u5f20\u56fe\u7247\u7684\u76ee\u5f55<ul> <li>\u5982 <code>[2025-01-02]_TheTitle_1.jpg</code>\u3001<code>[2025-01-02]_TheTitle_2.jpg</code>\u3001<code>[2025-01-02]_TheTitle_3.jpg</code> \u7b49</li> </ul> </li> <li>\u652f\u6301\u6392\u9664 \u6307\u5b9a\u683c\u5f0f \u7684\u6587\u4ef6\u6216\u4ec5\u4e0b\u8f7d\u6307\u5b9a\u683c\u5f0f\u7684\u6587\u4ef6</li> <li>\u4f8b\u5982\u5f53\u4f60\u4e0d\u60f3\u4e0b\u8f7d\u5e9e\u5927\u91cd\u590d\u7684 PSD \u548c\u538b\u7f29\u5305\u6587\u4ef6\u65f6\uff0c\u53ef\u4ee5\u5728\u914d\u7f6e\u4e2d\u6392\u9664 <code>.psd</code> \u548c <code>.zip</code> \u6587\u4ef6</li> <li>\u652f\u6301\u6309**\u6587\u4ef6\u5927\u5c0f**\u8fc7\u6ee4\u4e0b\u8f7d</li> <li>\u4f8b\u5982\uff0c\u5982\u679c\u4f60\u60f3\u5728\u78c1\u76d8\u7a7a\u95f4\u4e0d\u8db3\u65f6\u907f\u514d\u4e0b\u8f7d\u5927\u578b\u89c6\u9891\u6587\u4ef6\uff0c\u53ef\u4ee5\u5728\u914d\u7f6e\u4e2d\u8bbe\u7f6e\u6700\u5927\u6587\u4ef6\u5927\u5c0f\u9650\u5236</li> <li>\u4f60\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\u6700\u5c0f\u6587\u4ef6\u5927\u5c0f\uff0c\u4ee5\u8df3\u8fc7\u4e0b\u8f7d\u7f29\u7565\u56fe\u6216\u9884\u89c8\u56fe\u7247</li> <li>\u652f\u6301\u6309\u5e16\u5b50**\u6807\u9898\u5173\u952e\u8bcd**\u8fc7\u6ee4\u4e0b\u8f7d</li> <li>\u4f8b\u5982\u4f60\u53ea\u60f3\u4e0b\u8f7d\u6807\u9898\u4e2d\u5305\u542b\u201c\u8868\u60c5\u3001\u52b9\u679c\u97f3\u5dee\u5206\u201d\u7684\u5e16\u5b50\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>sync-creator</code> \u547d\u4ee4\u7684 <code>--keywords</code> \u9009\u9879</li> <li>\u5982\u679c\u4f60\u60f3\u6392\u9664\u6807\u9898\u4e2d\u5305\u542b\u6307\u5b9a\u5173\u952e\u8bcd\u7684\u5e16\u5b50\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>--keywords-exclude</code> \u9009\u9879</li> <li>\u652f\u6301\u6309\u5e16\u5b50\u53d1\u5e03\u65e5\u671f**\u65f6\u95f4\u8303\u56f4**\u8fc7\u6ee4\u4e0b\u8f7d</li> <li>\u80fd\u591f\u89e3\u6790\u5e16\u5b50\u9875\u9762 HTML \u591a\u4fe1\u606f\u6587\u672c\u4e2d\u5305\u542b\u7684\u56fe\u7247\u5e76\u4e0b\u8f7d</li> <li>\u8fd9\u7c7b\u5e16\u5b50\u7279\u5f81\u4e3a\uff1a\u6d4f\u89c8\u5668\u9875\u9762\u521a\u8fdb\u5165\u65f6\u56fe\u7247\u53ef\u80fd\u6ca1\u6709\u52a0\u8f7d\u51fa\u6765\uff0c\u4e14\u6ca1\u6709\u9884\u89c8\u56fe</li> <li>\u80fd\u591f\u6536\u96c6\u5e16\u5b50\u9875\u9762\u4e2d\u5217\u51fa\u7684**\u7f51\u76d8\u94fe\u63a5**\u5e76\u4fdd\u5b58\u81f3\u6587\u672c\u6587\u4ef6</li> <li>\u53ef\u641c\u7d22\u753b\u5e08\u548c\u5e16\u5b50\uff0c\u5e76\u5bfc\u51fa\u7ed3\u679c</li> <li>\u5982\u679c\u4f60\u5e0c\u671b\u81ea\u5df1\u5904\u7406\u753b\u5e08\u548c\u5e16\u5b50\u6570\u636e\uff0c\u53ef\u4ee5\u4f7f\u7528\u8be5\u529f\u80fd\u5bfc\u51fa JSON \u6570\u636e</li> <li>\u652f\u6301\u5168\u5e73\u53f0\uff0c\u5e76\u63d0\u4f9b iOS \u5feb\u6377\u6307\u4ee4</li> <li>\u7eaf Python \u5206\u652f\u53ef\u5728 iOS \u7684 a-Shell \u6216\u6d4f\u89c8\u5668\u7684 Pyodide \u4e0a\u8fd0\u884c</li> <li>\u5bf9\u4e8e Coomer.st / Coomer.su / Coomer.party \u7684\u652f\u6301\uff0c\u8bf7\u67e5\u770b\u6587\u6863 Coomer</li> </ul>"},{"location":"zh/#_2","title":"\u4f7f\u7528\u65b9\u6cd5","text":""},{"location":"zh/#_3","title":"\u5b89\u88c5","text":"<p>\u4f60\u53ef\u4ee5\u4ece releases \u9875\u9762\u4e0b\u8f7d\u53ef\u6267\u884c\u6587\u4ef6\u4f7f\u7528</p> \u4e00\u822c\u60c5\u51b5 <p>\u63a8\u8350\u4f7f\u7528 pipx    <pre><code>pip3 install pipx\n# Windows\npipx install ktoolbox[urwid,winloop]\n# Linux / macOS\npipx install ktoolbox[urwid,uvloop]\n</code></pre></p> \u7eaf Python <p>\u5982\u679c\u4f60\u5728\u4f7f\u7528 pyodide\uff0c\u6216\u8005\u5982\u679c\u4f60\u53ea\u80fd\u4f7f\u7528\u7eafPython\uff0c\u65e0\u6cd5\u7f16\u8bd1 pydantic v2.x.x    <pre><code>pip3 install pipx\npipx install ktoolbox\n</code></pre></p> \u5bf9\u4e8e iOS a-Shell <pre><code>pip3 install ktoolbox-pure-py\n</code></pre> <p>\u5173\u4e8e a-Shell</p> <p>a-Shell \u662f\u4e00\u4e2a iOS \u7ec8\u7aef App\uff0c\u5b83\u53ea\u80fd\u8fd0\u884c\u7eaf Python \u811a\u672c</p>"},{"location":"zh/#_4","title":"\u547d\u4ee4","text":"<p>\u4f7f\u7528\u5e2e\u52a9\u547d\u4ee4\u6216\u524d\u5f80 \u547d\u4ee4 \u9875\u9762\u67e5\u770b\u66f4\u591a\u5e2e\u52a9\u3002</p>"},{"location":"zh/#_5","title":"\u2753 \u83b7\u53d6\u5e2e\u52a9\u603b\u89c8","text":"<pre><code>ktoolbox -h\n</code></pre>"},{"location":"zh/#_6","title":"\u2753 \u83b7\u53d6\u67d0\u4e2a\u547d\u4ee4\u7684\u5e2e\u52a9\u4fe1\u606f","text":"<pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"zh/#_7","title":"\u2b07\ufe0f\ud83d\uddbc\ufe0f \u4e0b\u8f7d\u6307\u5b9a\u7684\u5e16\u5b50","text":"<pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> \u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25 <p>\u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25\uff0c\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u91cd\u65b0\u8fd0\u884c\u547d\u4ee4\uff0c\u5df2\u4e0b\u8f7d\u5b8c\u6210\u7684\u6587\u4ef6\u4f1a\u88ab \u8df3\u8fc7\u3002</p>"},{"location":"zh/#_8","title":"\u2b07\ufe0f\ud83d\udd8c\ufe0f \u4e0b\u8f7d\u4f5c\u8005\u7684\u6240\u6709\u5e16\u5b50","text":"<pre><code># \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u7684\u6240\u6709\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684 10 \u4e2a\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684\u7b2c 11 \u81f3 15 \u4e2a\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u4ece 2024-1-1 \u5230 2024-3-1 \u7684\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --start-time=2024-1-1 --end-time=2024-3-1\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6807\u9898\u4e2d\u5305\u542b\u201c\u8868\u60c5\u201d\u7684\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --keywords \"\u8868\u60c5\"\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6807\u9898\u4e2d\u5305\u542b\u201c\u8868\u60c5\u3001\u52b9\u679c\u97f3\u5dee\u5206\u201d\u7684\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --keywords \"\u8868\u60c5,\u52b9\u679c\u97f3\u5dee\u5206\"\n</code></pre>"},{"location":"zh/#_9","title":"\u914d\u7f6e","text":"<ul> <li>\u540c\u65f6\u4e0b\u8f7d10\u4e2a\u6587\u4ef6</li> <li>\u6309\u7167\u6570\u5b57\u987a\u5e8f\u91cd\u547d\u540d\u9644\u4ef6, \u4f8b\u5982 <code>1.png</code>, <code>2.png</code>, ...</li> <li>\u5c06\u53d1\u5e03\u65e5\u671f\u4f5c\u4e3a\u5e16\u5b50\u76ee\u5f55\u540d\u7684\u5f00\u5934\uff0c\u4f8b\u5982 <code>[2024-1-1]HelloWorld</code></li> <li>\u5c06\u5e16\u5b50\u6807\u9898\u4f5c\u4e3a\u6587\u4ef6\u540d\u7684\u5f00\u5934\uff0c\u4f8b\u5982 <code>HelloWorld_1.png</code>, <code>HelloWorld_2.png</code>, ...</li> <li>\u4e0b\u8f7d\u5e16\u5b50\u4fee\u8ba2\u7248\u672c</li> <li>\u6392\u9664\u4e0b\u8f7d <code>.psd</code> \u548c <code>.zip</code> \u6587\u4ef6</li> <li>\u4ece\u5e16\u5b50\u4e2d\u63d0\u53d6\u4e91\u76d8\u94fe\u63a5\u5e76\u4fdd\u5b58\u5230\u6587\u672c\u6587\u4ef6</li> <li>...</li> </ul> <p>\u524d\u5f80 \u914d\u7f6e-\u5411\u5bfc \u9875\u9762\u67e5\u770b\u66f4\u591a\u8be6\u60c5\u3002</p>"},{"location":"zh/about-kemono/","title":"\u5173\u4e8e Kemono","text":"<p>\u5b98\u7f51 https://kemono.cr \u7684\u4ecb\u7ecd\uff1a</p> <p>Kemono is a public archiver for:</p> <ul> <li>Patreon</li> <li>Pixiv Fanbox</li> <li>Discord</li> <li>Fantia</li> <li>Afdian</li> <li>Boosty</li> <li>DLsite</li> <li>Gumroad</li> <li>SubscribeStar</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. \\ To get started viewing content, either search for creators on the artists page, or search for content on the posts page.</p>"},{"location":"zh/api/","title":"API \u6587\u6863","text":""},{"location":"zh/coomer/","title":"Coomer","text":"<p>KToolBox \u652f\u6301\u4ece Coomer.st / Coomer.su / Coomer.party \u4e0b\u8f7d</p> <p>\u4f60\u9700\u8981\u901a\u8fc7 dotenv\u6587\u4ef6 <code>.env</code> \u6216 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u4fee\u6539\u914d\u7f6e\uff1a <pre><code># Coomer API\nKTOOLBOX_API__NETLOC=coomer.st\n\n# \u7528\u4e8e\u4ece Coomer \u670d\u52a1\u5668\u4e0b\u8f7d\u6587\u4ef6\nKTOOLBOX_API__FILES_NETLOC=coomer.st\n</code></pre></p>"},{"location":"zh/coomer/#coomer_1","title":"\u5173\u4e8e Coomer","text":"<p>\u5b98\u7f51 https://coomer.st \u7684\u4ecb\u7ecd\uff1a</p> <p>Coomer is a public archiver for:</p> <ul> <li>OnlyFans</li> <li>Fansly</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. To get started viewing content, either search for creators on the creators page, or search for content on the posts page. If you want to contribute content, head over to the import page.</p>"},{"location":"zh/faq/","title":"\u5e38\u89c1\u95ee\u9898","text":""},{"location":"zh/faq/#uvloopwinloop","title":"\u5982\u4f55\u89e3\u51b3 uvloop/winloop \u5b89\u88c5\u5931\u8d25\u7684\u95ee\u9898\uff1f","text":"<p>\u8fd9\u662f\u53ef\u9009\u7684</p> <p>\u4e8b\u4ef6\u5faa\u73af\u4f18\u5316\uff08uvloop/winloop\uff09\u53ef\u4ee5\u63d0\u9ad8\u5e76\u53d1\u6027\u80fd\uff0c\u4f46\u5b83\u662f \u53ef\u9009\u7684\u3002\u5982\u679c\u4f60\u4e0d\u60f3\u5b89\u88c5\u8fd9\u4e9b\u5305\uff0c\u4f60\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e2a\u6b65\u9aa4\u3002</p> <p>KToolBox \u73b0\u5728\u652f\u6301\u5e73\u53f0\u7279\u5b9a\u7684\u4e8b\u4ef6\u5faa\u73af\u4f18\u5316\uff1a</p> <ul> <li>Windows: \u4f7f\u7528 <code>winloop</code> \u6765\u63d0\u5347\u6027\u80fd</li> <li>Linux/macOS: \u4f7f\u7528 <code>uvloop</code> \u6765\u63d0\u5347\u6027\u80fd</li> </ul>"},{"location":"zh/faq/#_2","title":"\u5b89\u88c5\u4e8b\u4ef6\u5faa\u73af\u4f18\u5316","text":"WindowsLinux/macOS <pre><code>pip install ktoolbox[winloop]\n</code></pre> <pre><code>pip install ktoolbox[uvloop]\n</code></pre> <p>\u5982\u679c\u4f60\u5728 Linux \u6216 macOS \u5b89\u88c5 uvloop \u5931\u8d25\uff0c  \u4f60\u53ef\u4ee5\u5c1d\u8bd5\u7528\u4f8b\u5982 apt\u3001yum\u3001brew \u7684\u7cfb\u7edf\u5305\u7ba1\u7406\u5668\u5b89\u88c5\uff0c\u5305\u7ba1\u7406\u5668\u63d0\u4f9b\u6784\u5efa\u597d\u7684 uvloop \u5305\u3002</p> <ul> <li>\u4f7f\u7528 apt \u5b89\u88c5     <pre><code>sudo apt install python3-uvloop\n</code></pre></li> </ul>"},{"location":"zh/faq/#attachments","title":"\u6211\u4e0d\u9700\u8981\u5e16\u5b50\u76ee\u5f55\u4e0b\u7684 <code>attachments</code> \u6587\u4ef6\u5939","text":"<p>\u4f60\u53ef\u4ee5\u8bbe\u7f6e\u914d\u7f6e\u9009\u9879 <code>job.post_structure.attachments</code> \u4e3a <code>./</code></p> <p>\u901a\u8fc7 dotenv \u6587\u4ef6 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u8bbe\u7f6e\u914d\u7f6e\uff1a <pre><code>KTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n</code></pre></p> <p><code>./</code> \u8868\u793a\u9644\u4ef6\u6587\u4ef6\u5c06\u4f1a\u76f4\u63a5\u4e0b\u8f7d\u5230\u5e16\u5b50\u76ee\u5f55\u4e0b\u3002</p> <p>\u63d0\u793a</p> <p>\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u8003 \u914d\u7f6e-\u5411\u5bfc \u9875\u9762\u3002</p>"},{"location":"zh/faq/#_3","title":"\u5982\u4f55\u5173\u95ed\u5c01\u9762\u56fe\u529f\u80fd\uff1f","text":"<p>\u4f60\u53ef\u4ee5\u8bbe\u7f6e\u914d\u7f6e\u9009\u9879 <code>job.download_file</code> \u4e3a <code>False</code> \u6765\u5173\u95ed\u5c01\u9762\u56fe\uff08\u6587\u4ef6\uff09\u4e0b\u8f7d\u529f\u80fd\u3002</p> <p>\u901a\u8fc7 dotenv \u6587\u4ef6 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u8bbe\u7f6e\u914d\u7f6e\uff1a <pre><code># \u5173\u95ed\u5c01\u9762\u56fe\u4e0b\u8f7d\nKTOOLBOX_JOB__DOWNLOAD_FILE=False\n\n# \u5982\u679c\u4f60\u4e5f\u60f3\u5173\u95ed\u9644\u4ef6\u4e0b\u8f7d\uff0c\u53ef\u4ee5\u8bbe\u7f6e\n#KTOOLBOX_JOB__DOWNLOAD_ATTACHMENTS=False\n</code></pre></p> <p>\u8fd9\u6837\u8bbe\u7f6e\u540e\uff0cKToolBox \u5c06\u53ea\u4e0b\u8f7d\u9644\u4ef6\uff08attachments\uff09\uff0c\u8df3\u8fc7\u5c01\u9762\u56fe\uff08file\uff09\u4e0b\u8f7d\u3002\u8fd9\u5bf9\u4e8e\u6709\u4e9b\u4f5c\u8005\u7684\u56fe\u7247\u540d\u79f0\u662f\u4e71\u7801\u3001\u9700\u8981\u4f9d\u8d56\u91cd\u547d\u540d\u529f\u80fd\u6309\u7f51\u9875\u987a\u5e8f\u6392\u5e8f\u7684\u60c5\u51b5\u5f88\u6709\u7528\u3002</p> <p>\u63d0\u793a</p> <ul> <li><code>download_file</code>: \u63a7\u5236\u662f\u5426\u4e0b\u8f7d\u5e16\u5b50\u6587\u4ef6\uff08\u901a\u5e38\u4e3a\u5c01\u9762\u56fe\u7247\uff09</li> <li><code>download_attachments</code>: \u63a7\u5236\u662f\u5426\u4e0b\u8f7d\u5e16\u5b50\u9644\u4ef6</li> <li>\u4e24\u4e2a\u9009\u9879\u90fd\u9ed8\u8ba4\u4e3a <code>True</code>\uff0c\u786e\u4fdd\u5411\u540e\u517c\u5bb9\u6027</li> </ul>"},{"location":"zh/faq/#-_","title":"\u547d\u4ee4\u548c\u6807\u5fd7\uff08\u9009\u9879\uff09\u5e94\u5f53\u4f7f\u7528 <code>-</code> \u8fd8\u662f <code>_</code> \u4f5c\u4e3a\u5206\u9694\u7b26\uff1f","text":"<p>\u4e24\u8005\u90fd\u652f\u6301\uff0c\u63a8\u8350\u4f7f\u7528 <code>-</code>\u3002</p>"},{"location":"zh/faq/#_4","title":"\u6587\u4ef6\u540d\u8fc7\u957f","text":"<p>\u5728\u4e00\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6587\u4ef6\u540d\u6216\u5e16\u5b50\u76ee\u5f55\u540d\u8fc7\u957f\u800c\u5bfc\u81f4\u4e0b\u8f7d\u5931\u8d25\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f60\u53ef\u4ee5\u8bbe\u7f6e \u5e8f\u5217\u5316\u6587\u4ef6\u540d \u6216\u4f7f\u7528 \u81ea\u5b9a\u4e49\u5e16\u5b50\u76ee\u5f55\u540d</p> <p>\u901a\u8fc7 dotenv \u6587\u4ef6 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u8bbe\u7f6e\u914d\u7f6e\uff1a <pre><code># \u6309\u7167\u6570\u5b57\u987a\u5e8f\u91cd\u547d\u540d\u9644\u4ef6, \u4f8b\u5982 `1.png`, `2.png`, ...\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# \u8bbe\u7f6e\u5e16\u5b50\u76ee\u5f55\u540d\u4e3a\u5176\u53d1\u5e03\u65e5\u671f\u548cID\uff0c\u4f8b\u5982 `[2024-1-1]11223344`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{id}\n</code></pre></p>"},{"location":"zh/faq/#_5","title":"\u5982\u4f55\u914d\u7f6e\u4ee3\u7406\uff1f","text":"<p>\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e <code>HTTPS_PROXY</code>, <code>HTTP_PROXY</code>, <code>ALL_PROXY</code> \u73af\u5883\u53d8\u91cf\u5b9e\u73b0</p> <p>\u53c2\u8003\uff1aHTTPX - Environment Variables</p> <p>\u4f8b\u5982\u8fd9\u6837\u8bbe\u7f6e\uff1a</p> <pre><code># Unix Shell\nexport HTTPS_PROXY=http://127.0.0.1:7897\nexport HTTP_PROXY=http://127.0.0.1:7897\nexport ALL_PROXY=socks5://127.0.0.1:7897\n</code></pre> <pre><code># Windows PowerShell\n$env:HTTP_PROXY=\"http://127.0.0.1:7897\"; $env:HTTPS_PROXY=\"http://127.0.0.1:7897\"\n</code></pre>"},{"location":"zh/faq/#_6","title":"\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u65e0\u6cd5\u6253\u5f00","text":"<p>\u6ce8\u610f</p> <p><code>ktoolbox-pure-py</code> \u4e0d\u652f\u6301\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u7684\u76f8\u5173\u4f9d\u8d56\u4e0d\u4f1a\u88ab\u5b89\u88c5\uff0c\u53ef\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u9644\u5e26\u5b89\u88c5\uff1a</p> <pre><code>pip3 install ktoolbox[urwid]\n</code></pre> <p>\u5982\u679c\u4f60\u7528\u7684\u662f pipx\uff1a</p> <pre><code>pipx install ktoolbox[urwid] --force\n</code></pre>"},{"location":"zh/faq/#kemono-api","title":"Kemono API \u8c03\u7528\u5931\u8d25","text":"<p>\u4f8b\u5982\uff1a</p> <pre><code>ktoolbox sync-creator \"https://coomer.su/onlyfans/user/hollyharper11\" --start-time=\"2020-05-01\" --end-time=\"2025-01-01\"\n\n2024-05-12 12:52:51.477 | INFO     | ktoolbox.cli:sync_creator:271 - Got creator information - {'name': 'hollyharper11', 'id': 'hollyharper11'}\n2024-05-12 12:52:51.479 | INFO     | ktoolbox.action.job:create_job_from_creator:148 - Start fetching posts from creator hollyharper11\n2024-05-12 12:52:56.477 | ERROR    | ktoolbox.api.base:_retry_error_callback:37 - Kemono API call failed - {'ret': APIRet(code=1002, message=\"1 validation error for Response\\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\\\n&lt;html&gt;\\\\...&gt;\\\\n  &lt;/body&gt;\\\\n&lt;/html&gt;\\\\n', input_type=str]\\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\", exception=1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid, data=None)}\n1 validation error for Response\n  Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\...&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.7/v/json_invalid\n</code></pre> <ol> <li> <p>\u786e\u4fdd\u66f4\u65b0\u5230\u4e86 v0.14.0 \u6216\u4ee5\u4e0a\u7248\u672c</p> </li> <li> <p>\u4e00\u822c\u53ef\u80fd\u662f\u56e0\u4e3a\u8bf7\u6c42\u9891\u7e41\u5bfc\u81f4\uff0c\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u8bbe\u7f6e\u66f4\u591a\u7684 API \u91cd\u8bd5\u6b21\u6570     <pre><code># .env / prod.env\nKTOOLBOX_API__RETRY_TIMES=10\n</code></pre></p> </li> <li> <p>\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u8bbe\u7f6e\u4e0b\u8f7d\u6240\u7528\u7684 session key \uff08\u767b\u5f55\u6210\u529f\u540e\u53ef\u5728 Cookies \u4e2d\u67e5\u770b\uff09     <pre><code># .env / prod.env\nKTOOLBOX_API__SESSION_KEY=\"xxxxxxx\"\n</code></pre></p> </li> </ol> <p>\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u8bbe\u7f6e\uff1a<code>API - retry_times</code> \u548c <code>API -&gt; session_key</code>.</p>"},{"location":"zh/faq/#403","title":"\u4e0b\u8f7d\u65f6\u9891\u7e41\u51fa\u73b0 403 \u9519\u8bef","text":"<p>\u89e3\u51b3\u65b9\u6cd5\u540c\u4e0a</p>"},{"location":"zh/faq/#_7","title":"\u6740\u6bd2\u8f6f\u4ef6\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u6807\u8bb0\u4e3a\u75c5\u6bd2/\u5a01\u80c1","text":"<p>\u8fd9\u662f**\u8bef\u62a5**\u3002KToolBox \u662f\u5b8c\u5168\u5b89\u5168\u7684\u5f00\u6e90\u8f6f\u4ef6\u3002</p> <p>\u4e3a\u4ec0\u4e48\u4f1a\u53d1\u751f\u8fd9\u79cd\u60c5\u51b5\uff1a - PyInstaller \u53ef\u6267\u884c\u6587\u4ef6\u7531\u4e8e\u5176\u6253\u5305\u65b9\u6cd5\u7ecf\u5e38\u88ab\u6740\u6bd2\u5f15\u64ce\u6807\u8bb0 - \u4ece\u7f51\u7edc\u4e0b\u8f7d\u7684\u53ef\u6267\u884c\u6587\u4ef6\u901a\u5e38\u88ab\u6000\u7591\u5bf9\u5f85 - \u4e00\u4e9b\u542f\u53d1\u5f0f\u5f15\u64ce\u4f1a\u6807\u8bb0\u4efb\u4f55\"\u4e0b\u8f7d\u7ba1\u7406\u5668\"\u7c7b\u578b\u7684\u8f6f\u4ef6</p> <p>\u89e3\u51b3\u65b9\u6848\uff1a 1. \u5728\u6740\u6bd2\u8f6f\u4ef6\u4e2d\u6dfb\u52a0\u4f8b\u5916 \u5bf9 KToolBox \u53ef\u6267\u884c\u6587\u4ef6 2. \u4f7f\u7528 pipx \u6216 pip \u5b89\u88c5 3. \u4ece\u6e90\u7801\u6784\u5efa \u5982\u679c\u4f60\u4ecd\u6709\u987e\u8651\uff1a    <pre><code>git clone https://github.com/Ljzd-PRO/KToolBox.git\ncd KToolBox\npoetry install --with pyinstaller\npoetry run pyinstaller ktoolbox.spec\n</code></pre></p> <p>\u5b89\u5168\u4fdd\u8bc1\uff1a - \u6240\u6709\u53d1\u5e03\u7248\u672c\u90fd\u4f7f\u7528 GitHub Actions \u81ea\u52a8\u6784\u5efa\uff08\u516c\u5f00\u53ef\u89c1\uff09 - \u6e90\u4ee3\u7801\u5b8c\u5168\u5f00\u653e\u4e14\u53ef\u5ba1\u8ba1 - \u6b64\u9879\u76ee\u4e2d\u4e0d\u5b58\u5728\u6076\u610f\u4ee3\u7801</p>"},{"location":"zh/faq/#_8","title":"\u5e16\u5b50\u6807\u9898\u592a\u957f\u5bfc\u81f4\u65e0\u6cd5\u521b\u5efa\u76ee\u5f55\u6216\u4e0b\u8f7d\u6587\u4ef6","text":"<p>\u63d0\u793a</p> <p>Python \u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u8003 \u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00</p> <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5e16\u5b50\u6807\u9898\u8fc7\u957f\u4f1a\u5bfc\u81f4\u4e0b\u8f7d\u5931\u8d25\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f60\u53ef\u4ee5\u5728 \u81ea\u5b9a\u4e49\u5e16\u5b50\u76ee\u5f55\u540d\u683c\u5f0f \u4e2d\u4f7f\u7528 Python \u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\u5bf9\u6807\u9898\u8fdb\u884c\u957f\u5ea6\u9650\u5236\u3002</p> <p>\u901a\u8fc7\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u6216 dotenv \u6587\u4ef6 <code>.env</code> \u548c\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u8bbe\u7f6e\u914d\u7f6e\uff1a <pre><code># \u8bbe\u7f6e\u5e16\u5b50\u76ee\u5f55\u540d\u4e3a\u5176\u6807\u9898\u7684\u524d 30 \u4e2a\u5b57\u7b26\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT={title:.30}\n\n# \u5982\u679c\u4f60\u9700\u8981\u5728\u81ea\u5b9a\u4e49\u7684\u6587\u4ef6\u540d\u683c\u5f0f\u4e2d\u6dfb\u52a0\u6807\u9898\uff0c\u4e5f\u53ef\u4ee5\u8fdb\u884c\u957f\u5ea6\u9650\u5236\nKTOOLBOX_JOB__FILENAME_FORMAT={title:.30}_{}\n</code></pre></p>"},{"location":"zh/faq/#_9","title":"\u6211\u5728\u54ea\u91cc\u53ef\u4ee5\u627e\u5230\u66f4\u591a\u5e2e\u52a9\uff1f","text":"<ul> <li>\u5411\u5bfc\uff1a\u7528 AI\uff08Copilot Spaces\uff09 \u83b7\u53d6\u547d\u4ee4\u53c2\u6570\u548c\u914d\u7f6e\u5e2e\u52a9\uff1a#304</li> <li>\u4e00\u4e2a\u793e\u533a\u5206\u4eab\u7684\u4f7f\u7528\u5411\u5bfc\uff1a#141</li> </ul>"},{"location":"zh/more/","title":"\u66f4\u591a","text":""},{"location":"zh/more/#_2","title":"\u5176\u4ed6\u5206\u652f","text":"<ul> <li>\u7eaf Python \u5206\u652f\uff1a\ud83d\udd17pure-py</li> </ul> <p>\u5173\u4e8e</p> <ul> <li>\u4f7f\u7528 pydantic v1 \u56e0\u6b64\u5b89\u88c5\u65f6\u4e0d\u9700\u8981 cargo</li> <li>\u4f8b\u5982\u4f60\u53ef\u4ee5\u5728 iOS \u7684\u7ec8\u7aef App a-Shell \u8fd0\u884c</li> <li>\ud83d\udd17PyPI</li> </ul> <ul> <li>\u5f00\u53d1\u7248\u5206\u652f\uff1a\ud83d\udd17devel</li> </ul>"},{"location":"zh/more/#_3","title":"\u4ee3\u7801\u8986\u76d6\u7387","text":""},{"location":"zh/more/#_4","title":"\u8bb8\u53ef\u8bc1","text":"<p>KToolBox \u4f7f\u7528 BSD 3-Clause \u8bb8\u53ef\u8bc1.</p> <p>Copyright \u00a9 2023 by Ljzd-PRO.</p>"},{"location":"zh/shortcut/","title":"iOS \u5feb\u6377\u6307\u4ee4","text":"<p>\u4f60\u53ef\u4ee5\u5728 iOS \u7ec8\u7aef App a-Shell \u8fd0\u884c KToolBox\uff0c\u4e0b\u5217\u5feb\u6377\u6307\u4ee4\u53ef\u4ee5\u5e2e\u52a9\u4f60\u81ea\u52a8\u5b8c\u6210 KToolBox \u7684\u5b89\u88c5\u4ee5\u53ca\u5e16\u5b50\u4e0b\u8f7d</p>"},{"location":"zh/shortcut/#_1","title":"\u83b7\u53d6\u5feb\u6377\u6307\u4ee4","text":"<p>\u8bbf\u95ee\u4e0b\u9762\u7684\u5feb\u6377\u6307\u4ee4 URL \u6216\u524d\u5f80 <code>shortcuts/</code> \u4e0b\u8f7d\u5feb\u6377\u6307\u4ee4\u6587\u4ef6</p>"},{"location":"zh/shortcut/#_2","title":"\u82f1\u6587","text":"<ul> <li>KToolBox Manager</li> <li>Download Kemono Post</li> </ul>"},{"location":"zh/shortcut/#_3","title":"\u4e2d\u6587","text":"<ul> <li>KToolBox \u7ba1\u7406\u5668</li> <li>\u4e0b\u8f7d Kemono \u5e16\u5b50</li> </ul>"},{"location":"zh/shortcut/#_4","title":"\u7528\u6cd5","text":"<ul> <li>\u4f7f\u7528 \u201cKToolBox \u7ba1\u7406\u5668\u201d \u4ee5\u5728 a-Shell \u4e2d \u5b89\u88c5\u3001\u66f4\u65b0\u3001\u5378\u8f7d KToolBox</li> <li>\u4f60\u53ef\u4ee5\u901a\u8fc7\u7f51\u9875\u5171\u4eab\u754c\u9762\u89e6\u53d1\u201c\u4e0b\u8f7d Kemono \u5e16\u5b50\u201d\uff0c\u6216\u76f4\u63a5\u5728\u5feb\u6377\u6307\u4ee4 App \u8fd0\u884c</li> </ul>"},{"location":"zh/commands/guide/","title":"\u5411\u5bfc","text":"<p>\u524d\u5f80 \u53c2\u8003 \u6240\u6709\u547d\u4ee4\u4ee5\u53ca\u5b83\u4eec\u7684\u6807\u5fd7/\u53c2\u6570.</p>"},{"location":"zh/commands/guide/#_2","title":"\u83b7\u53d6\u5e2e\u52a9\u603b\u89c8","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox -h\n</code></pre>"},{"location":"zh/commands/guide/#_3","title":"\u83b7\u53d6\u67d0\u4e2a\u547d\u4ee4\u7684\u5e2e\u52a9\u4fe1\u606f","text":"<ul> <li><code>--help</code>, <code>-h</code></li> </ul> <pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"zh/commands/guide/#_4","title":"\u542f\u52a8\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668","text":"<p><code>config-editor</code></p> <pre><code>ktoolbox config-editor\n</code></pre>"},{"location":"zh/commands/guide/#envprodenv","title":"\u751f\u6210\u4e00\u4e2a\u914d\u7f6e\u6587\u4ef6\u6837\u4f8b (<code>.env</code>/<code>prod.env</code>)","text":"<p><code>example-env</code></p> <pre><code>ktoolbox example-env\n</code></pre>"},{"location":"zh/commands/guide/#_5","title":"\u4e0b\u8f7d\u6307\u5b9a\u7684\u5e16\u5b50","text":"<p><code>download-post</code></p> <pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> \u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25 <p>\u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25\uff0c\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u91cd\u65b0\u8fd0\u884c\u547d\u4ee4\uff0c\u5df2\u4e0b\u8f7d\u5b8c\u6210\u7684\u6587\u4ef6\u4f1a\u88ab \u8df3\u8fc7\u3002</p>"},{"location":"zh/commands/guide/#_6","title":"\u4e0b\u8f7d\u4f5c\u8005\u7684\u6240\u6709\u5e16\u5b50","text":"<p><code>sync-creator</code></p> <pre><code># \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u7684\u6240\u6709\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n</code></pre> \u66f4\u65b0\u4f5c\u8005\u76ee\u5f55 <p>\u4f60\u53ef\u4ee5\u518d\u6b21\u8fd0\u884c\u547d\u4ee4\uff0c\u6587\u4ef6\u540d\u76f8\u540c\u7684\u6587\u4ef6\u5c06\u4f1a\u88ab\u8df3\u8fc7\u3002</p>"},{"location":"zh/commands/guide/#_7","title":"\u4e0b\u8f7d\u6307\u5b9a\u6570\u91cf\u7684\u5e16\u5b50","text":"<p><code>sync-creator</code></p> <ul> <li><code>--offset</code>\uff1a\u5e16\u5b50\u7ed3\u679c\u504f\u79fb\u91cf\uff08\u6216\u8d77\u59cb\u504f\u79fb\u91cf\uff09</li> <li><code>--length</code>\uff1a\u8981\u83b7\u53d6\u7684\u5e16\u5b50\u6570\u91cf\uff0c\u9ed8\u8ba4\u83b7\u53d6\u6240\u6709\u5e16\u5b50</li> </ul> <pre><code># \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684 10 \u4e2a\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --length=10\n\n# \u4e0b\u8f7d\u4f5c\u8005/\u753b\u5e08\u6700\u65b0\u7684\u7b2c 11 \u81f3 15 \u4e2a\u5e16\u5b50\nktoolbox sync-creator https://kemono.su/fanbox/user/9016 --offset=10 --length=5\n</code></pre>"},{"location":"zh/commands/guide/#_8","title":"\u4e0b\u8f7d\u5728\u6307\u5b9a\u65f6\u95f4\u8303\u56f4\u5185\u53d1\u5e03\u7684\u5e16\u5b50","text":"<p><code>sync-creator</code></p> <ul> <li><code>--start-time</code>\uff1a\u4e0b\u8f7d\u6307\u5b9a\u5f00\u59cb\u65f6\u95f4\u8303\u56f4\u5185\u7684\u5e16\u5b50</li> <li><code>--end-time</code>\uff1a\u4e0b\u8f7d\u6307\u5b9a\u7ed3\u675f\u65f6\u95f4\u8303\u56f4\u5185\u7684\u5e16\u5b50</li> </ul> <pre><code># \u4ece 2023-8-5 \u5230 2023-12-6\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5 --end-time=2023-12-6\n\n# \u4ece 2023-8-5 \u5230 \u73b0\u5728\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --start-time=2023-8-5\n\n# 2023-8-5 \u4e4b\u524d\nktoolbox sync-creator https://kemono.su/fanbox/user/641955 --end-time=2023-8-5\n</code></pre>"},{"location":"zh/commands/guide/#_9","title":"\u65f6\u95f4\u683c\u5f0f","text":"<p>\u65f6\u95f4\u503c\u5e94\u5f53\u7b26\u5408 <code>%Y-%m-%d</code> \u683c\u5f0f\uff0c\u4f8b\u5982\uff1a</p> <ul> <li><code>2023-12-7</code></li> <li><code>2023-12-07</code></li> <li><code>2023-12-31</code></li> </ul>"},{"location":"zh/commands/reference/","title":"\u53c2\u8003","text":"<p>               Bases: <code>KToolBoxCli</code></p>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.config_editor","title":"<code>config_editor</code>","text":"<p>\u542f\u52a8\u56fe\u5f62\u5316 KToolBox \u914d\u7f6e\u7f16\u8f91\u5668</p>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.download_post","title":"<code>download_post</code>","text":"<p>\u4e0b\u8f7d\u6307\u5b9a\u5e16\u5b50\u6216\u4fee\u8ba2\u7248\u672c</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>\u5e16\u5b50\u94fe\u63a5</p> <code>None</code> <code>service</code> <code>str</code> <p>\u5e73\u53f0\u540d\u79f0</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>\u521b\u4f5c\u8005 ID</p> <code>None</code> <code>post_id</code> <code>str</code> <p>\u5e16\u5b50 ID</p> <code>None</code> <code>revision_id</code> <code>str</code> <p>\u4fee\u8ba2\u7248\u672c ID\uff08\u53ef\u9009\uff09</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>\u4e0b\u8f7d\u8def\u5f84\uff0c\u9ed8\u8ba4\u4e3a\u5f53\u524d\u76ee\u5f55</p> <code>Path('.')</code> <code>dump_post_data</code> <p>\u662f\u5426\u5728\u5e16\u5b50\u76ee\u5f55\u4e2d\u4fdd\u5b58 post.json \u6570\u636e</p> <code>True</code>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.example_env","title":"<code>example_env</code>","text":"<p>\u751f\u6210\u793a\u4f8b\u914d\u7f6e <code>.env</code> \u6587\u4ef6</p>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.get_post","title":"<code>get_post</code>","text":"<p>\u83b7\u53d6\u6307\u5b9a\u5e16\u5b50\u6216\u4fee\u8ba2\u7248\u672c</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>\u5e73\u53f0\u540d\u79f0</p> required <code>creator_id</code> <code>str</code> <p>\u521b\u4f5c\u8005 ID</p> required <code>post_id</code> <code>str</code> <p>\u5e16\u5b50 ID</p> required <code>revision_id</code> <code>str</code> <p>\u4fee\u8ba2\u7248\u672c ID\uff08\u53ef\u9009\uff09</p> <code>None</code> <code>dump</code> <code>Path</code> <p>\u5c06\u7ed3\u679c\u5bfc\u51fa\u4e3a JSON \u6587\u4ef6</p> <code>None</code>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.search_creator","title":"<code>search_creator</code>","text":"<p>\u641c\u7d22\u521b\u4f5c\u8005\uff0c\u53ef\u4f7f\u7528\u591a\u4e2a\u53c2\u6570\u4f5c\u4e3a\u5173\u952e\u8bcd\u3002</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>\u521b\u4f5c\u8005 ID</p> <code>None</code> <code>name</code> <code>str</code> <p>\u521b\u4f5c\u8005\u540d\u79f0</p> <code>None</code> <code>service</code> <code>str</code> <p>\u521b\u4f5c\u8005\u6240\u5c5e\u5e73\u53f0</p> <code>None</code> <code>dump</code> <code>Path</code> <p>\u5c06\u7ed3\u679c\u5bfc\u51fa\u4e3a JSON \u6587\u4ef6</p> <code>None</code>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.search_creator_post","title":"<code>search_creator_post</code>","text":"<p>\u641c\u7d22\u521b\u4f5c\u8005\u7684\u5e16\u5b50\uff0c\u53ef\u4f7f\u7528\u591a\u4e2a\u53c2\u6570\u4f5c\u4e3a\u5173\u952e\u8bcd\u3002</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>\u521b\u4f5c\u8005 ID</p> <code>None</code> <code>name</code> <code>str</code> <p>\u521b\u4f5c\u8005\u540d\u79f0</p> <code>None</code> <code>service</code> <code>str</code> <p>\u521b\u4f5c\u8005\u6240\u5c5e\u5e73\u53f0</p> <code>None</code> <code>q</code> <code>str</code> <p>\u641c\u7d22\u5173\u952e\u8bcd</p> <code>None</code> <code>o</code> <code>int</code> <p>\u7ed3\u679c\u504f\u79fb\u91cf\uff0c\u6b65\u957f\u4e3a 50</p> <code>None</code> <code>dump</code> <code>Path</code> <p>\u5c06\u7ed3\u679c\u5bfc\u51fa\u4e3a JSON \u6587\u4ef6</p> <code>None</code>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.site_version","title":"<code>site_version</code>","text":"<p>\u663e\u793a\u5f53\u524d Kemono \u7ad9\u70b9\u5e94\u7528\u63d0\u4ea4\u54c8\u5e0c</p>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.sync_creator","title":"<code>sync_creator</code>","text":"<p>\u540c\u6b65\u521b\u4f5c\u8005\u6240\u6709\u5e16\u5b50</p> <p>\u53ef\u5728\u4e0b\u8f7d\u5b8c\u6210\u540e\u968f\u65f6\u66f4\u65b0\u76ee\u5f55\uff0c\u4f8b\u5982\u521b\u4f5c\u8005\u53d1\u5e03\u65b0\u5e16\u5b50\u540e\u8fdb\u884c\u66f4\u65b0\u3002</p> <ul> <li><code>start_time</code> \u548c <code>end_time</code> \u793a\u4f8b\uff1a<code>2023-12-7</code>\uff0c<code>2023-12-07</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>\u5e16\u5b50\u94fe\u63a5</p> <code>None</code> <code>service</code> <code>str</code> <p>\u5e73\u53f0\u540d\u79f0</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>\u521b\u4f5c\u8005 ID</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>\u4e0b\u8f7d\u8def\u5f84\uff0c\u9ed8\u8ba4\u4e3a\u5f53\u524d\u76ee\u5f55</p> <code>Path('.')</code> <code>save_creator_indices</code> <code>bool</code> <p>\u662f\u5426\u8bb0\u5f55 CreatorIndices \u6570\u636e</p> <code>False</code> <code>mix_posts</code> <code>bool</code> <p>\u662f\u5426\u5c06\u4e0d\u540c\u5e16\u5b50\u7684\u6240\u6709\u6587\u4ef6\u4fdd\u5b58\u5230\u540c\u4e00\u8def\u5f84</p> <code>None</code> <code>start_time</code> <code>str</code> <p>\u5e16\u5b50\u53d1\u5e03\u65f6\u95f4\u8303\u56f4\u8d77\u59cb\uff0c\u683c\u5f0f <code>%Y-%m-%d</code></p> <code>None</code> <code>end_time</code> <code>str</code> <p>\u5e16\u5b50\u53d1\u5e03\u65f6\u95f4\u8303\u56f4\u7ed3\u675f\uff0c\u683c\u5f0f <code>%Y-%m-%d</code></p> <code>None</code> <code>offset</code> <code>int</code> <p>\u7ed3\u679c\u504f\u79fb\u91cf</p> <code>0</code> <code>length</code> <code>int</code> <p>\u83b7\u53d6\u5e16\u5b50\u6570\u91cf\uff0c\u9ed8\u8ba4\u4e3a\u5168\u90e8</p> <code>None</code> <code>keywords</code> <code>str</code> <p>\u6309\u6807\u9898\u8fc7\u6ee4\u5e16\u5b50\uff0c\u9017\u53f7\u5206\u9694\u5173\u952e\u8bcd</p> <code>None</code> <code>keywords_exclude</code> <code>str</code> <p>\u6309\u6807\u9898\u6392\u9664\u5e16\u5b50\uff0c\u9017\u53f7\u5206\u9694\u5173\u952e\u8bcd</p> <code>None</code>"},{"location":"zh/commands/reference/#ktoolbox._cli_zh.KToolBoxCli.version","title":"<code>version</code>","text":"<p>\u663e\u793a KToolBox \u7248\u672c\u53f7</p>"},{"location":"zh/configuration/guide/","title":"\u5411\u5bfc","text":"<p>\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668</p> \u7528\u6cd5\u622a\u56fe <p>\u8fd0\u884c <code>ktoolbox config-editor</code> \u6765\u542f\u52a8\uff0c\u8fd9\u4f1a\u4f7f\u914d\u7f6e\u7f16\u8f91\u53d8\u5f97\u7b80\u5355\u65b9\u4fbf\u3002</p> <ul> <li>\u6309\u4e0b <code>&lt;Esc&gt;</code> \u6765\u8fd4\u56de\uff0c\u6309 <code>&lt;Enter&gt;</code> \u6765\u9009\u62e9 </li> <li>\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u9f20\u6807\u4f7f\u7528\u8fd9\u4e2a GUI</li> </ul> <p> </p> <p>\u751f\u6210\u793a\u4f8b <code>.env</code> \u6587\u4ef6</p> <p>\u8fd0\u884c <code>ktoolbox example-env</code> \u6765\u751f\u6210\u5b8c\u6574\u7684\u914d\u7f6e\u6587\u4ef6\u6837\u4f8b\u3002</p> <ul> <li>KToolBox \u8bfb\u53d6 \u5de5\u4f5c\u76ee\u5f55 \u4e0b\u7684 <code>.env</code> \u6216 <code>prod.env</code> \u6587\u4ef6 \u6216 \u73af\u5883\u53d8\u91cf \u6765\u8bbe\u5b9a\u914d\u7f6e</li> <li>\u5de5\u4f5c\u76ee\u5f55\u6307\u7684\u662f\u4f60\u6267\u884c <code>ktoolbox</code> \u547d\u4ee4\u7684\u76ee\u5f55\u4f4d\u7f6e\uff0c\u4e0d\u4e00\u5b9a\u662f <code>ktoolbox</code> \u53ef\u6267\u884c\u6587\u4ef6\u6240\u5728\u7684\u76ee\u5f55\u3002\u5728\u54ea\u91cc\u6267\u884c\u5c31\u5728\u54ea\u91cc\u8bfb\u53d6\u3002</li> <li>\u524d\u5f80 \u53c2\u8003 \u67e5\u770b\u6240\u6709\u914d\u7f6e\u9009\u9879</li> <li>\u7528 <code>__</code> \u6765\u6307\u5b9a\u5b50\u9009\u9879, \u4f8b\u5982 <code>KTOOLBOX_API__SCHEME</code> \u76f8\u5f53\u4e8e <code>api.scheme</code></li> <li>\u6240\u6709\u914d\u7f6e\u9009\u9879\u90fd\u662f\u53ef\u9009\u7684</li> </ul>"},{"location":"zh/configuration/guide/#env-prodenv","title":"<code>.env</code> / <code>prod.env</code> \u6587\u4ef6\u793a\u4f8b","text":"<pre><code>##############################################################################\n#  \u63a8\u8350\u4f7f\u7528\u56fe\u5f62\u5316\u914d\u7f6e\u7f16\u8f91\u5668\u8fdb\u884c\u7f16\u8f91\u3002                                         #\n#  \u8fd0\u884c `ktoolbox config-editor` \u542f\u52a8\u7f16\u8f91\u5668\u3002                                #\n##############################################################################\n\n# \uff08\u53ef\u9009\uff09\u4f1a\u8bdd\u5bc6\u94a5\uff0c\u53ef\u5728\u6210\u529f\u767b\u5f55\u540e\u7684 cookies \u4e2d\u627e\u5230\n# 403 \u9519\u8bef\u65f6\u4f7f\u7528\n#KTOOLBOX_API__SESSION_KEY=xxxxx\n\n# \u540c\u65f6\u4e0b\u8f7d 10 \u4e2a\u6587\u4ef6\u3002\nKTOOLBOX_JOB__COUNT=10\n\n# \u8bbe\u7f6e\u5e16\u5b50\u9644\u4ef6\u76ee\u5f55\u8def\u5f84\u4e3a `./`\uff0c\u8868\u793a\u5c06\u6240\u6709\u9644\u4ef6\u6587\u4ef6\u4fdd\u5b58\u5728\u5e16\u5b50\u76ee\u5f55\u4e0b\n# \u4e0d\u4f1a\u4e3a\u9644\u4ef6\u5355\u72ec\u521b\u5efa\u5b50\u76ee\u5f55\nKTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n\n# \u9644\u4ef6\u6309\u6570\u5b57\u987a\u5e8f\u91cd\u547d\u540d\uff0c\u4f8b\u5982 `1.png`\u3001`2.png`\u3001\u2026\u2026\nKTOOLBOX_JOB__SEQUENTIAL_FILENAME=True\n\n# \u901a\u8fc7\u63d2\u5165\u7a7a\u7684 `{}` \u81ea\u5b9a\u4e49\u6587\u4ef6\u540d\u683c\u5f0f\uff0c\u8868\u793a\u57fa\u7840\u6587\u4ef6\u540d\u3002\n# \u7c7b\u4f3c\u4e8e `post_dirname_format`\uff0c\u53ef\u4ee5\u4f7f\u7528 `Post` \u4e2d\u7684\u4e00\u4e9b\u5c5e\u6027\u3002\n# \u4f8b\u5982\uff1a`{title}_{}` &gt; `HelloWorld_b4b41de2-8736-480d-b5c3-ebf0d917561b` \u7b49\u3002\n# \u4e5f\u53ef\u4ee5\u4e0e `sequential_filename` \u4e00\u8d77\u4f7f\u7528\u3002\u4f8b\u5982\uff0c\n# `[{published}]_{}` &gt; `[2024-1-1]_1.png`\u3001`[2024-1-1]_2.png` \u7b49\u3002\nKTOOLBOX_JOB__FILENAME_FORMAT=[{published}]_{title}_{id}_{}\n\n# \u5e16\u5b50\u76ee\u5f55\u540d\u4ee5\u53d1\u5e03\u65f6\u95f4\u4f5c\u4e3a\u524d\u7f00\uff0c\u4f8b\u5982 `[2024-1-1]HelloWorld`\nKTOOLBOX_JOB__POST_DIRNAME_FORMAT=[{published}]{title}\n</code></pre>"},{"location":"zh/configuration/reference/","title":"\u53c2\u8003","text":""},{"location":"zh/configuration/reference/#ktoolbox._configuration_zh.Configuration","title":"<code>Configuration</code>","text":"<p>KToolBox \u914d\u7f6e</p> <p>Attributes:</p> Name Type Description Default <code>api</code> <code>APIConfiguration</code> <p>Kemono API \u914d\u7f6e</p> <code>                       APIConfiguration()               </code> <code>downloader</code> <code>DownloaderConfiguration</code> <p>\u6587\u4ef6\u4e0b\u8f7d\u5668\u914d\u7f6e</p> <code>                       DownloaderConfiguration()               </code> <code>job</code> <code>JobConfiguration</code> <p>\u4e0b\u8f7d\u4efb\u52a1\u914d\u7f6e</p> <code>                       JobConfiguration()               </code> <code>logger</code> <code>LoggerConfiguration</code> <p>\u65e5\u5fd7\u914d\u7f6e</p> <code>                       LoggerConfiguration()               </code> <code>ssl_verify</code> <code>bool</code> <p>\u5bf9 Kemono API \u670d\u52a1\u5668\u548c\u4e0b\u8f7d\u670d\u52a1\u5668\u542f\u7528 SSL \u8bc1\u4e66\u9a8c\u8bc1</p> <code>                       True               </code> <code>json_dump_indent</code> <code>int</code> <p>JSON \u6587\u4ef6\u4fdd\u5b58\u65f6\u7684\u7f29\u8fdb</p> <code>                       4               </code> <code>use_uvloop</code> <code>bool</code> <p>\u4f7f\u7528 uvloop/winloop \u4f18\u5316 asyncio \u6027\u80fd     Windows \u4e0b\u4f7f\u7528 winloop\uff0c\u7c7b Unix \u7cfb\u7edf\u4e0b\u4f7f\u7528 uvloop\uff0c\u63d0\u9ad8\u5e76\u53d1\u6027\u80fd\u3002    Windows \u4e0b\u5b89\u88c5 winloop\uff1a<code>pip install ktoolbox[winloop]</code>     Unix \u4e0b\u5b89\u88c5 uvloop\uff1a<code>pip install ktoolbox[uvloop]</code></p> <code>                       True               </code>"},{"location":"zh/configuration/reference/#ktoolbox._configuration_zh.APIConfiguration","title":"<code>APIConfiguration</code>","text":"<p>Kemono API \u914d\u7f6e</p> <p>Attributes:</p> Name Type Description Default <code>scheme</code> <code>Literal['http', 'https']</code> <p>Kemono API \u7684 URL \u534f\u8bae</p> <code>                       'https'               </code> <code>netloc</code> <code>str</code> <p>Kemono API \u7684\u4e3b\u673a\u5730\u5740</p> <code>                       'kemono.cr'               </code> <code>statics_netloc</code> <code>str</code> <p>Kemono \u670d\u52a1\u5668\u9759\u6001\u6587\u4ef6\uff08\u5982\u56fe\u7247\uff09\u7684\u4e3b\u673a\u5730\u5740</p> <code>                       'img.kemono.cr'               </code> <code>files_netloc</code> <code>str</code> <p>Kemono \u670d\u52a1\u5668\u5e16\u5b50\u6587\u4ef6\u7684\u4e3b\u673a\u5730\u5740</p> <code>                       'kemono.cr'               </code> <code>path</code> <code>str</code> <p>Kemono API \u7684\u6839\u8def\u5f84</p> <code>                       '/api/v1'               </code> <code>timeout</code> <code>float</code> <p>API \u8bf7\u6c42\u8d85\u65f6\u65f6\u95f4</p> <code>                       5.0               </code> <code>retry_times</code> <code>int</code> <p>API \u8bf7\u6c42\u5931\u8d25\u65f6\u91cd\u8bd5\u6b21\u6570</p> <code>                       3               </code> <code>retry_interval</code> <code>float</code> <p>API \u8bf7\u6c42\u91cd\u8bd5\u95f4\u9694\u79d2\u6570</p> <code>                       2.0               </code> <code>session_key</code> <code>str</code> <p>\u767b\u5f55\u6210\u529f\u540e\u53ef\u5728 Cookie \u4e2d\u627e\u5230\u7684\u4f1a\u8bdd\u5bc6\u94a5</p> <code>                       ''               </code>"},{"location":"zh/configuration/reference/#ktoolbox._configuration_zh.DownloaderConfiguration","title":"<code>DownloaderConfiguration</code>","text":"<p>\u6587\u4ef6\u4e0b\u8f7d\u5668\u914d\u7f6e</p> <p>Attributes:</p> Name Type Description Default <code>scheme</code> <code>Literal['http', 'https']</code> <p>\u4e0b\u8f7d\u5668\u7684 URL \u534f\u8bae</p> <code>                       'https'               </code> <code>timeout</code> <code>float</code> <p>\u4e0b\u8f7d\u5668\u8bf7\u6c42\u8d85\u65f6\u65f6\u95f4</p> <code>                       30.0               </code> <code>encoding</code> <code>str</code> <p>\u6587\u4ef6\u540d\u89e3\u6790\u548c\u5e16\u5b50 <code>\u5185\u5bb9</code>\u3001<code>external_links</code> \u4fdd\u5b58\u7684\u5b57\u7b26\u96c6</p> <code>                       'utf-8'               </code> <code>buffer_size</code> <code>int</code> <p>\u6bcf\u4e2a\u4e0b\u8f7d\u6587\u4ef6\u7684\u6587\u4ef6 I/O \u7f13\u51b2\u533a\u5b57\u8282\u6570</p> <code>                       20480               </code> <code>chunk_size</code> <code>int</code> <p>\u4e0b\u8f7d\u5668\u6d41\u7684\u5206\u5757\u5b57\u8282\u6570</p> <code>                       1024               </code> <code>temp_suffix</code> <code>str</code> <p>\u4e0b\u8f7d\u6587\u4ef6\u7684\u4e34\u65f6\u6587\u4ef6\u540d\u540e\u7f00</p> <code>                       'tmp'               </code> <code>retry_times</code> <code>int</code> <p>\u4e0b\u8f7d\u5931\u8d25\u65f6\u91cd\u8bd5\u6b21\u6570</p> <code>                       10               </code> <code>retry_stop_never</code> <code>bool</code> <p>\u6c38\u4e0d\u505c\u6b62\u4e0b\u8f7d\u5668\u91cd\u8bd5\uff08\u542f\u7528\u65f6\u5ffd\u7565 retry_times\uff09</p> <code>                       False               </code> <code>retry_interval</code> <code>float</code> <p>\u4e0b\u8f7d\u5668\u91cd\u8bd5\u95f4\u9694\u79d2\u6570</p> <code>                       3.0               </code> <code>tps_limit</code> <code>float</code> <p>\u6bcf\u79d2\u6700\u5927\u8fde\u63a5\u6570</p> <code>                       5.0               </code> <code>use_bucket</code> <code>bool</code> <p>\u542f\u7528\u672c\u5730\u5b58\u50a8\u6876\u6a21\u5f0f</p> <code>                       False               </code> <code>bucket_path</code> <code>Path</code> <p>\u672c\u5730\u5b58\u50a8\u6876\u8def\u5f84</p> <code>                       Path('./.ktoolbox/bucket_storage')               </code> <code>reverse_proxy</code> <code>str</code> <p>\u4e0b\u8f7d URL \u7684\u53cd\u5411\u4ee3\u7406\u683c\u5f0f\u3002\u901a\u8fc7\u63d2\u5165\u7a7a\u7684 <code>{}</code> \u81ea\u5b9a\u4e49\u6587\u4ef6\u540d\u683c\u5f0f\u4ee5\u8868\u793a\u539f\u59cb URL\u3002    \u4f8b\u5982\uff1a<code>https://example.com/{}</code> \u4f1a\u53d8\u6210 <code>https://example.com/https://n1.kemono.su/data/66/83/xxxxx.jpg</code>\uff1b    <code>https://example.com/?url={}</code> \u4f1a\u53d8\u6210 <code>https://example.com/?url=https://n1.kemono.su/data/66/83/xxxxx.jpg</code></p> <code>                       '{}'               </code> <code>keep_metadata</code> <code>bool</code> <p>\u4e0b\u8f7d\u6587\u4ef6\u65f6\u4fdd\u7559\u6587\u4ef6\u5143\u6570\u636e\uff08\u4f8b\u5982\u6700\u540e\u4fee\u6539\u65f6\u95f4\u7b49\uff09</p> <code>                       True               </code>"},{"location":"zh/configuration/reference/#ktoolbox._configuration_zh.PostStructureConfiguration","title":"<code>PostStructureConfiguration</code>","text":"<p>\u5e16\u5b50\u8def\u5f84\u7ed3\u6784\u6a21\u578b</p> <ul> <li> <p>\u9ed8\u8ba4\u7ed3\u6784: <pre><code>..\n\u251c\u2500 content.txt\n\u251c\u2500 external_links.txt\n\u251c\u2500 {id}_{}.png (\u6587\u4ef6)\n\u251c\u2500 post.json (\u5143\u6570\u636e)\n\u251c\u2500 attachments\n\u2502    \u251c\u2500 1.png\n\u2502    \u2514\u2500 2.png\n\u2514\u2500 revisions\n     \u251c\u2500 &lt;PostStructure&gt;\n     \u2502    \u251c\u2500 ...\n     \u2502    \u2514\u2500 ...\n     \u2514\u2500 &lt;PostStructure&gt;\n          \u251c\u2500 ...\n          \u2514\u2500 ...\n</code></pre></p> </li> <li> <p><code>file</code> \u53ef\u7528\u5c5e\u6027</p> \u5c5e\u6027 \u7c7b\u578b <code>id</code> \u5b57\u7b26\u4e32 <code>user</code> \u5b57\u7b26\u4e32 <code>service</code> \u5b57\u7b26\u4e32 <code>title</code> \u5b57\u7b26\u4e32 <code>added</code> \u65e5\u671f <code>published</code> \u65e5\u671f <code>edited</code> \u65e5\u671f </li> </ul> <p>Attributes:</p> Name Type Description Default <code>attachments</code> <code>Path</code> <p>\u9644\u4ef6\u76ee\u5f55\u7684\u5b50\u8def\u5f84</p> <code>                       Path('attachments')               </code> <code>content</code> <code>Path</code> <p>\u5e16\u5b50\u5185\u5bb9\u6587\u4ef6\u7684\u5b50\u8def\u5f84</p> <code>                       Path('content.txt')               </code> <code>external_links</code> <code>Path</code> <p>\u5916\u90e8\u94fe\u63a5\u6587\u4ef6\u7684\u5b50\u8def\u5f84\uff08\u7528\u4e8e\u4fdd\u5b58\u5185\u5bb9\u4e2d\u53d1\u73b0\u7684\u4e91\u5b58\u50a8\u94fe\u63a5\uff09</p> <code>                       Path('external_links.txt')               </code> <code>file</code> <code>str</code> <p>\u5e16\u5b50 <code>file</code> \u6587\u4ef6\u540d\u7684\u683c\u5f0f\uff08<code>file</code> \u4e0d\u662f <code>attachment</code>\uff0c\u6bcf\u4e2a\u5e16\u5b50\u53ea\u6709\u4e00\u4e2a <code>file</code>\uff0c\u901a\u5e38\u4e3a\u5c01\u9762\u56fe\u7247\uff09\u3002    \u901a\u8fc7\u63d2\u5165\u7a7a\u7684 <code>{}</code> \u81ea\u5b9a\u4e49\u6587\u4ef6\u540d\u683c\u5f0f\u3002\u53ef\u4f7f\u7528 \u5c5e\u6027\u3002    \u4f8b\u5982\uff1a<code>{title}_{}</code> \u53ef\u80fd\u751f\u6210 <code>TheTitle_Stelle_lv5_logo.gif</code>\u3001<code>TheTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code> \u7b49\u6587\u4ef6\u540d\u3002    \u540c\u65f6\uff0c\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528 Python \u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\u7684\u683c\u5f0f\u5316\u529f\u80fd\uff0c\u4f8b\u5982\uff1a<code>{title:.6}_{}</code> \u53ef\u4ee5\u5c06\u6807\u9898\u957f\u5ea6\u7f29\u77ed\u4e3a 6 \u4e2a\u5b57\u7b26\uff0c    \u50cf <code>HiEveryoneThisIsALongTitle_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code> \u4f1a\u53d8\u6210 <code>HiEver_ScxHjZIdxt5cnjaAwf3ql2p7.jpg</code></p> <code>                       '{id}_{}'               </code> <code>revisions</code> <code>Path</code> <p>\u4fee\u8ba2\u76ee\u5f55\u7684\u5b50\u8def\u5f84</p> <code>                       Path('revisions')               </code>"},{"location":"zh/configuration/reference/#ktoolbox._configuration_zh.JobConfiguration","title":"<code>JobConfiguration</code>","text":"<p>\u4e0b\u8f7d\u4efb\u52a1\u914d\u7f6e</p> <ul> <li> <p><code>post_dirname_format</code> \u548c <code>filename_format</code> \u53ef\u7528\u5c5e\u6027</p> \u5c5e\u6027 \u7c7b\u578b <code>id</code> \u5b57\u7b26\u4e32 <code>user</code> \u5b57\u7b26\u4e32 <code>service</code> \u5b57\u7b26\u4e32 <code>title</code> \u5b57\u7b26\u4e32 <code>added</code> \u65e5\u671f <code>published</code> \u65e5\u671f <code>edited</code> \u65e5\u671f </li> <li> <p><code>year_dirname_format</code> \u548c <code>month_dirname_format</code> \u53ef\u7528\u5c5e\u6027</p> \u5c5e\u6027 \u7c7b\u578b <code>year</code> \u5b57\u7b26\u4e32 <code>month</code> \u5b57\u7b26\u4e32 </li> <li> <p>Python \u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\u53c2\u8003\u6587\u6863</p> <p>https://docs.python.org/zh-cn/3.13/library/string.html#format-specification-mini-language</p> </li> </ul> <p>Attributes:</p> Name Type Description Default <code>count</code> <code>int</code> <p>\u5e76\u53d1\u4e0b\u8f7d\u7684\u534f\u7a0b\u6570\u91cf</p> <code>                       4               </code> <code>include_revisions</code> <code>bool</code> <p>\u4e0b\u8f7d\u65f6\u5305\u542b\u4fee\u8ba2\u5e16\u5b50</p> <code>                       False               </code> <code>post_dirname_format</code> <code>str</code> <p>\u81ea\u5b9a\u4e49\u5e16\u5b50\u76ee\u5f55\u540d\u683c\u5f0f\uff0c\u53ef\u4f7f\u7528 \u5c5e\u6027\u3002    \u4f8b\u5982\uff1a<code>[{published}]{id}</code> \u53ef\u4ee5\u751f\u6210\u7c7b\u4f3c <code>[2024-1-1]123123</code> \u7684\u76ee\u5f55\u540d\uff0c    <code>{user}_{published}_{title}</code> \u53ef\u4ee5\u751f\u6210\u7c7b\u4f3c <code>234234_2024-1-1_TheTitle</code> \u7684\u76ee\u5f55\u540d\u3002    \u540c\u65f6\uff0c\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528 Python \u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\u7684\u683c\u5f0f\u5316\u529f\u80fd\uff0c\u4f8b\u5982\uff1a<code>{title:.6}</code> \u53ef\u4ee5\u5c06\u6807\u9898\u957f\u5ea6\u7f29\u77ed\u4e3a 6 \u4e2a\u5b57\u7b26\uff0c\u50cf <code>HiEveryoneThisIsALongTitle</code> \u4f1a\u53d8\u6210 <code>HiEver</code></p> <code>                       '{title}'               </code> <code>post_structure</code> <code>PostStructureConfiguration</code> <p>\u5e16\u5b50\u8def\u5f84\u7ed3\u6784</p> <code>                       PostStructureConfiguration()               </code> <code>mix_posts</code> <code>bool</code> <p>\u5728\u521b\u4f5c\u8005\u76ee\u5f55\u4e0b\u5c06\u4e0d\u540c\u5e16\u5b50\u7684\u6240\u6709\u6587\u4ef6\u4fdd\u5b58\u5230\u540c\u4e00\u8def\u5f84\uff0c\u4e0d\u521b\u5efa\u5e16\u5b50\u76ee\u5f55\uff0c\u4e14\u4e0d\u4f1a\u8bb0\u5f55 <code>CreatorIndices</code></p> <code>                       False               </code> <code>sequential_filename</code> <code>bool</code> <p>\u9644\u4ef6\u6309\u6570\u5b57\u987a\u5e8f\u91cd\u547d\u540d\uff0c\u5982 <code>1.png</code>\u3001<code>2.png</code> \u7b49</p> <code>                       False               </code> <code>sequential_filename_excludes</code> <code>Set[str]</code> <p>\u542f\u7528 <code>sequential_filename</code> \u65f6\u6392\u9664\u6309\u987a\u5e8f\u547d\u540d\u7684\u6587\u4ef6\u6269\u5c55\u540d\uff0c\u8fd9\u4e9b\u6587\u4ef6\u5c06\u4fdd\u7559\u539f\u59cb\u540d\u79f0\u3002\u4f8b\u5982 <code>[\".psd\", \".zip\", \".mp4\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>filename_format</code> <code>str</code> <p>\u901a\u8fc7\u63d2\u5165\u7a7a\u7684 <code>{}</code> \u81ea\u5b9a\u4e49\u6587\u4ef6\u540d\u683c\u5f0f\uff0c\u8868\u793a\u57fa\u672c\u6587\u4ef6\u540d\u3002\u53ef\u4f7f\u7528 \u5c5e\u6027\u3002    \u4f8b\u5982\uff1a<code>{title}_{}</code> \u53ef\u80fd\u751f\u6210 <code>TheTitle_b4b41de2-8736-480d-b5c3-ebf0d917561b</code>\u3001<code>TheTitle_af349b25-ac08-46d7-98fb-6ce99a237b90</code> \u7b49\u3002    \u4e5f\u53ef\u4e0e <code>sequential_filename</code> \u7ed3\u5408\u4f7f\u7528\uff0c\u5982 <code>[{published}]_{}</code> \u53ef\u80fd\u751f\u6210 <code>[2024-1-1]_1.png</code>\u3001<code>[2024-1-1]_2.png</code> \u7b49\u3002    \u540c\u65f6\uff0c\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528 Python \u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\u7684\u683c\u5f0f\u5316\u529f\u80fd\uff0c\u4f8b\u5982\uff1a<code>{title:.6}</code> \u53ef\u4ee5\u5c06\u6807\u9898\u957f\u5ea6\u7f29\u77ed\u4e3a 6 \u4e2a\u5b57\u7b26\uff0c\u50cf <code>HiEveryoneThisIsALongTitle</code> \u4f1a\u53d8\u6210 <code>HiEver</code></p> <code>                       '{}'               </code> <code>allow_list</code> <code>Set[str]</code> <p>\u4e0b\u8f7d\u5339\u914d\u8fd9\u4e9b\u6a21\u5f0f\uff08Unix shell \u98ce\u683c\uff09\u7684\u6587\u4ef6\uff0c\u5982 <code>[\"*.png\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>block_list</code> <code>Set[str]</code> <p>\u4e0d\u4e0b\u8f7d\u5339\u914d\u8fd9\u4e9b\u6a21\u5f0f\uff08Unix shell \u98ce\u683c\uff09\u7684\u6587\u4ef6\uff0c\u5982 <code>[\"*.psd\",\"*.zip\"]</code></p> <code>                       Field(default_factory=set)               </code> <code>extract_content</code> <code>bool</code> <p>\u63d0\u53d6\u5e16\u5b50\u5185\u5bb9\u5e76\u4fdd\u5b58\u5230\u5355\u72ec\u6587\u4ef6\uff08\u6587\u4ef6\u540d\u7531 <code>config.job.post_structure.content</code> \u5b9a\u4e49\uff09</p> <code>                       False               </code> <code>extract_external_links</code> <code>bool</code> <p>\u4ece\u5e16\u5b50\u5185\u5bb9\u4e2d\u63d0\u53d6\u5916\u90e8\u6587\u4ef6\u5206\u4eab\u94fe\u63a5\u5e76\u4fdd\u5b58\u5230\u5355\u72ec\u6587\u4ef6\uff08\u6587\u4ef6\u540d\u7531 <code>config.job.post_structure.external_links</code> \u5b9a\u4e49\uff09</p> <code>                       False               </code> <code>external_link_patterns</code> <code>List[str]</code> <p>\u7528\u4e8e\u63d0\u53d6\u5916\u90e8\u94fe\u63a5\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u6a21\u5f0f</p> <code>                       ['https?://drive\\\\.google\\\\.com/[^\\\\s]+', 'https?://docs\\\\.google\\\\.com/[^\\\\s]+', 'https?://mega\\\\.nz/[^\\\\s]+', 'https?://mega\\\\.co\\\\.nz/[^\\\\s]+', 'https?://(?:www\\\\.)?dropbox\\\\.com/[^\\\\s]+', 'https?://db\\\\.tt/[^\\\\s]+', 'https?://onedrive\\\\.live\\\\.com/[^\\\\s]+', 'https?://1drv\\\\.ms/[^\\\\s]+', 'https?://(?:www\\\\.)?mediafire\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?wetransfer\\\\.com/[^\\\\s]+', 'https?://we\\\\.tl/[^\\\\s]+', 'https?://(?:www\\\\.)?sendspace\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?4shared\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?zippyshare\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?uploadfiles\\\\.io/[^\\\\s]+', 'https?://(?:www\\\\.)?box\\\\.com/[^\\\\s]+', 'https?://(?:www\\\\.)?pcloud\\\\.com/[^\\\\s]+', 'https?://disk\\\\.yandex\\\\.[a-z]+/[^\\\\s]+', 'https?://[^\\\\s]*(?:file|upload|share|download|drive|storage)[^\\\\s]*\\\\.[a-z]{2,4}/[^\\\\s]+']               </code> <code>group_by_year</code> <code>bool</code> <p>\u6839\u636e\u53d1\u5e03\u65e5\u671f\u6309\u5e74\u5206\u7ec4\u5230\u4e0d\u540c\u76ee\u5f55</p> <code>                       False               </code> <code>group_by_month</code> <code>bool</code> <p>\u6839\u636e\u53d1\u5e03\u65e5\u671f\u6309\u6708\u5206\u7ec4\u5230\u4e0d\u540c\u76ee\u5f55\uff08\u9700\u8981\u542f\u7528 group_by_year\uff09</p> <code>                       False               </code> <code>year_dirname_format</code> <code>str</code> <p>\u81ea\u5b9a\u4e49\u5e74\u4efd\u76ee\u5f55\u540d\u683c\u5f0f\u3002\u53ef\u7528\u5c5e\u6027\uff1a<code>year</code>\u3002\u4f8b\u5982\uff1a<code>{year}</code> &gt; <code>2024</code>\uff0c<code>Year_{year}</code> &gt; <code>Year_2024</code></p> <code>                       '{year}'               </code> <code>month_dirname_format</code> <code>str</code> <p>\u81ea\u5b9a\u4e49\u6708\u4efd\u76ee\u5f55\u540d\u683c\u5f0f\u3002\u53ef\u7528\u5c5e\u6027\uff1a<code>year</code>\u3001<code>month</code>\u3002\u4f8b\u5982\uff1a<code>{year}-{month}</code> &gt; <code>2024-01</code>\uff0c<code>{year}_{month}</code> &gt; <code>2024_01</code></p> <code>                       '{year}-{month:02d}'               </code> <code>keywords</code> <code>Set[str]</code> <p>\u6309\u5e16\u5b50\u6807\u9898\u5173\u952e\u8bcd\u8fc7\u6ee4\uff08\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff09</p> <code>                       Field(default_factory=set)               </code> <code>keywords_exclude</code> <code>Set[str]</code> <p>\u6309\u5e16\u5b50\u6807\u9898\u5173\u952e\u8bcd\u6392\u9664\uff08\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff09</p> <code>                       Field(default_factory=set)               </code> <code>download_file</code> <code>bool</code> <p>\u662f\u5426\u4e0b\u8f7d\u5e16\u5b50\u6587\u4ef6\uff08\u901a\u5e38\u4e3a\u5c01\u9762\u56fe\u7247\uff09\u3002\u8bbe\u7f6e\u4e3a False \u53ef\u8df3\u8fc7\u6587\u4ef6\u4e0b\u8f7d\u3002</p> <code>                       True               </code> <code>download_attachments</code> <code>bool</code> <p>\u662f\u5426\u4e0b\u8f7d\u5e16\u5b50\u9644\u4ef6\u3002\u8bbe\u7f6e\u4e3a False \u53ef\u8df3\u8fc7\u9644\u4ef6\u4e0b\u8f7d\u3002</p> <code>                       True               </code> <code>min_file_size</code> <code>Optional[int]</code> <p>\u6700\u5c0f\u6587\u4ef6\u5927\u5c0f\uff08\u5b57\u8282\uff09\u3002\u5c0f\u4e8e\u6b64\u5927\u5c0f\u7684\u6587\u4ef6\u5c06\u88ab\u8df3\u8fc7\u3002\u8bbe\u7f6e\u4e3a None \u7981\u7528\u6700\u5c0f\u6587\u4ef6\u5927\u5c0f\u8fc7\u6ee4\u3002</p> <code>                       None               </code> <code>max_file_size</code> <code>Optional[int]</code> <p>\u6700\u5927\u6587\u4ef6\u5927\u5c0f\uff08\u5b57\u8282\uff09\u3002\u5927\u4e8e\u6b64\u5927\u5c0f\u7684\u6587\u4ef6\u5c06\u88ab\u8df3\u8fc7\u3002\u8bbe\u7f6e\u4e3a None \u7981\u7528\u6700\u5927\u6587\u4ef6\u5927\u5c0f\u8fc7\u6ee4\u3002</p> <code>                       None               </code>"},{"location":"zh/configuration/reference/#ktoolbox._configuration_zh.LoggerConfiguration","title":"<code>LoggerConfiguration</code>","text":"<p>\u65e5\u5fd7\u914d\u7f6e</p> <p>Attributes:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>\u65e5\u5fd7\u4fdd\u5b58\u8def\u5f84\uff0c<code>None</code> \u8868\u793a\u4e0d\u8f93\u51fa\u65e5\u5fd7\u6587\u4ef6</p> <code>                       None               </code> <code>level</code> <code>Union[str, int]</code> <p>\u65e5\u5fd7\u8fc7\u6ee4\u7ea7\u522b</p> <code>                       logging.getLevelName(logging.DEBUG)               </code> <code>rotation</code> <code>Union[str, int, time, timedelta]</code> <p>\u65e5\u5fd7\u8f6e\u6362\u5468\u671f</p> <code>                       '1 week'               </code>"}]}