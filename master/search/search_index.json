{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KToolBox","text":"KToolBox  <p>   KToolBox is a useful CLI tool for downloading posts content in   Kemono.party / Kemono.su </p> <p> </p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Support for multi-thread downloads (technically, coroutine).</li> <li>Ability to download individual post as well as all post by a specified creator/artist.</li> <li>Update downloaded creator/artist directories to the latest status.</li> <li>Customize the structure of downloaded post/creator directories.</li> <li>Search for creators/artists and posts, and export the results.</li> <li>Cross-platform support &amp; iOS shortcuts available.</li> </ul>"},{"location":"#tutorial","title":"Tutorial","text":""},{"location":"#installation","title":"Installation","text":"NormalFor iOS a-Shell <pre><code>pip3 install ktoolbox\n</code></pre> <pre><code>pip3 install ktoolbox-pure-py\n</code></pre> <p>About a-Shell</p> <p>a-Shell is an iOS terminal App,  it can only run pure python scripts.</p>"},{"location":"#command","title":"Command","text":"<p>For more information, use the help command or goto Commands page.</p>"},{"location":"#get-general-help","title":"\u2753 Get general help","text":"<pre><code>ktoolbox -h\n</code></pre>"},{"location":"#get-help-of-a-command","title":"\u2753 Get help of a command","text":"<pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"#download-a-specific-post","title":"\u2b07\ufe0f\ud83d\uddbc\ufe0f Download a specific post","text":"<pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> If some files failed to download <p>If some files failed to download, you can try to execute the command line again,  the downloaded files will be skipped.</p>"},{"location":"#download-all-posts-from-a-creator","title":"\u2b07\ufe0f\ud83d\udd8c\ufe0f Download all posts from a creator","text":"<pre><code>ktoolbox sync-creator https://kemono.su/fanbox/user/9016\n</code></pre> Output <p>By default, you will get a <code>creator-indices.ktoolbox</code> file in the creator directory,  you can use it to update the directory anytime.</p>"},{"location":"#update-a-downloaded-creator-directory","title":"\ud83d\udd04\ufe0f Update a downloaded creator directory","text":"<pre><code>ktoolbox sync-creator https://kemono.su/fanbox/user/641955 --update-with=./xxx/creator-indices.ktoolbox\n</code></pre> About <code>creator-indices.ktoolbox</code> file <p>The <code>creator-indices.ktoolbox</code> file contains the information and filepath of posts inside the directory.</p>"},{"location":"about-kemono/","title":"About Kemono","text":"<p>Description from https://kemono.su :</p> <p>Kemono is a public archiver for:</p> <ul> <li>Patreon</li> <li>Pixiv Fanbox</li> <li>Discord</li> <li>Fantia</li> <li>Afdian</li> <li>Boosty</li> <li>DLsite</li> <li>Gumroad</li> <li>SubscribeStar</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. \\ To get started viewing content, either search for creators on the artists page, or search for content on the posts page.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#ktoolbox.__description__","title":"<code>__description__ = 'A useful CLI tool for downloading posts in Kemono.party / .su'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__title__","title":"<code>__title__ = 'KToolBox'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__version__","title":"<code>__version__ = '0.2.3'</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.__main__","title":"<code>__main__</code>","text":""},{"location":"api/#ktoolbox.__main__.main","title":"<code>main()</code>","text":"Source code in <code>ktoolbox/__main__.py</code> <pre><code>def main():\n    logger_init(cli_use=True)\n    logger.debug(generate_msg(config=config))\n    uvloop_init()\n    fire.Fire(KToolBoxCli)\n</code></pre>"},{"location":"api/#ktoolbox.action","title":"<code>action</code>","text":""},{"location":"api/#ktoolbox.action.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.action.base.__all__","title":"<code>__all__ = ['ActionRet']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.base.ActionRet","title":"<code>ActionRet</code>","text":"<p>             Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/action/base.py</code> <pre><code>class ActionRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch","title":"<code>fetch</code>","text":""},{"location":"api/#ktoolbox.action.fetch.__all__","title":"<code>__all__ = ['FetchInterruptError', 'fetch_all_creator_posts']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError","title":"<code>FetchInterruptError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception for interrupt of data fetching</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>class FetchInterruptError(Exception):\n    \"\"\"Exception for interrupt of data fetching\"\"\"\n\n    def __init__(self, *args, ret: BaseRet = None):\n        super().__init__(*args)\n        self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError.ret","title":"<code>ret = ret</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.action.fetch.FetchInterruptError.__init__","title":"<code>__init__(*args, ret=None)</code>","text":"Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>def __init__(self, *args, ret: BaseRet = None):\n    super().__init__(*args)\n    self.ret = ret\n</code></pre>"},{"location":"api/#ktoolbox.action.fetch.fetch_all_creator_posts","title":"<code>fetch_all_creator_posts(service, creator_id)</code>  <code>async</code>","text":"<p>Fetch all posts from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <p>Returns:</p> Type Description <code>AsyncGenerator[List[Post], Any]</code> <p>Async generator of several list of posts</p> Source code in <code>ktoolbox/action/fetch.py</code> <pre><code>async def fetch_all_creator_posts(service: str, creator_id: str) -&gt; AsyncGenerator[List[Post], Any]:\n    \"\"\"\n    Fetch all posts from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :return: Async generator of several list of posts\n    :raise FetchInterruptError\n    \"\"\"\n    o = 0\n    while True:\n        ret = await get_creator_post(service=service, creator_id=creator_id, o=o)\n        if ret:\n            yield ret.data\n            if len(ret.data) &lt; SEARCH_STEP:\n                break\n            else:\n                o += SEARCH_STEP\n        else:\n            raise FetchInterruptError(ret=ret)\n</code></pre>"},{"location":"api/#ktoolbox.action.job","title":"<code>job</code>","text":""},{"location":"api/#ktoolbox.action.job.__all__","title":"<code>__all__ = ['create_job_from_post', 'filter_posts_with_indices', 'create_job_from_creator']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.job.create_job_from_creator","title":"<code>create_job_from_creator(service, creator_id, path, *, update_from=None, all_pages=False, o=None, save_creator_indices=True, mix_posts=None)</code>  <code>async</code>","text":"<p>Create a list of download job from a creator</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service where the post is located</p> required <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> required <code>path</code> <code>Path</code> <p>The path for posts to download</p> required <code>update_from</code> <code>CreatorIndices</code> <p><code>CreatorIndices</code> data for update posts from current creator directory,      <code>save_creator_indices</code> will be enabled if this provided</p> <code>None</code> <code>all_pages</code> <code>bool</code> <p>Fetch all pages of posts, <code>o</code> will be ignored if enabled</p> <code>False</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data for update posts from current creator directory</p> <code>True</code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path,      <code>update_from</code>, <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_creator(\n        service: str,\n        creator_id: str,\n        path: Path,\n        *,\n        update_from: CreatorIndices = None,\n        all_pages: bool = False,\n        o: int = None,\n        save_creator_indices: bool = True,\n        mix_posts: bool = None\n) -&gt; ActionRet[List[Job]]:\n    \"\"\"\n    Create a list of download job from a creator\n\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: The path for posts to download\n    :param update_from: ``CreatorIndices`` data for update posts from current creator directory, \\\n     ``save_creator_indices`` will be enabled if this provided\n    :param all_pages: Fetch all pages of posts, ``o`` will be ignored if enabled\n    :param o: Result offset, stepping of 50 is enforced\n    :param save_creator_indices: Record ``CreatorIndices`` data for update posts from current creator directory\n    :param mix_posts: Save all files from different posts at same path, \\\n     ``update_from``, ``save_creator_indices`` will be ignored if enabled\n    \"\"\"\n    mix_posts = config.job.mix_posts if mix_posts is None else mix_posts\n\n    # Get posts\n    logger.info(f\"Start fetching posts from creator {creator_id}\")\n    if all_pages:\n        post_list: List[Post] = []\n        try:\n            async for part in fetch_all_creator_posts(service=service, creator_id=creator_id):\n                post_list += part\n        except FetchInterruptError as e:\n            return ActionRet(**e.ret.model_dump(mode=\"python\"))\n    else:\n        ret = await get_creator_post(service=service, creator_id=creator_id, o=o)\n        if ret:\n            post_list = ret.data\n        else:\n            return ActionRet(**ret.model_dump(mode=\"python\"))\n    logger.info(f\"Get {len(post_list)} posts, start creating jobs\")\n\n    # Filter posts and generate ``CreatorIndices``\n    if not mix_posts:\n        indices = None\n        if update_from:\n            post_list, indices = filter_posts_with_indices(post_list, update_from)\n            logger.info(f\"{len(post_list)} posts will be downloaded\")\n        elif save_creator_indices:  # It's unnecessary to create indices again when ``update_from`` was provided\n            indices = CreatorIndices(\n                creator_id=creator_id,\n                service=service,\n                posts={post.id: post for post in post_list},\n                posts_path={post.id: path / sanitize_filename(post.title) for post in post_list}\n            )\n        if indices:\n            async with aiofiles.open(\n                    path / DataStorageNameEnum.CreatorIndicesData.value,\n                    \"w\",\n                    encoding=\"utf-8\"\n            ) as f:\n                await f.write(indices.model_dump_json(indent=config.json_dump_indent))\n\n    job_list: List[Job] = []\n    for post in post_list:\n        # Get post path\n        if mix_posts:\n            default_post_path = path\n        elif config.job.post_id_as_path:\n            default_post_path = path / post.id\n        else:\n            default_post_path = path / sanitize_filename(post.title)\n        if update_from:\n            if not (post_path := update_from.posts_path.get(post.id)):\n                post_path = default_post_path\n        else:\n            post_path = default_post_path\n\n        # Generate jobs\n        job_list += await create_job_from_post(\n            post=post,\n            post_path=post_path,\n            post_structure=False if mix_posts else None,\n            dump_post_data=not mix_posts\n        )\n    return ActionRet(data=job_list)\n</code></pre>"},{"location":"api/#ktoolbox.action.job.create_job_from_post","title":"<code>create_job_from_post(post, post_path, *, post_structure=None, dump_post_data=True)</code>  <code>async</code>","text":"<p>Create a list of download job from a post data</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Post</code> <p>post data</p> required <code>post_path</code> <code>Path</code> <p>Path of the post directory</p> required <code>post_structure</code> <code>Union[PostStructureConfiguration, bool]</code> <p>post path structure, <code>False</code> -&gt; disable,      <code>True</code> &amp; <code>None</code> -&gt; <code>config.job.post_structure</code></p> <code>None</code> <code>dump_post_data</code> <code>bool</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/action/job.py</code> <pre><code>async def create_job_from_post(\n        post: Post,\n        post_path: Path,\n        *,\n        post_structure: Union[PostStructureConfiguration, bool] = None,\n        dump_post_data: bool = True\n) -&gt; List[Job]:\n    \"\"\"\n    Create a list of download job from a post data\n\n    :param post: post data\n    :param post_path: Path of the post directory\n    :param post_structure: post path structure, ``False`` -&gt; disable, \\\n     ``True`` &amp; ``None`` -&gt; ``config.job.post_structure``\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    post_path.mkdir(exist_ok=True)\n\n    # Load ``PostStructureConfiguration``\n    if post_structure in [True, None]:\n        post_structure = config.job.post_structure\n    if post_structure:\n        attachments_path = post_path / post_structure.attachments  # attachments\n        attachments_path.mkdir(exist_ok=True)\n        content_path = post_path / post_structure.content_filepath  # content\n        content_path.parent.mkdir(exist_ok=True)\n    else:\n        attachments_path = post_path\n        content_path = None\n\n    # Create jobs\n    jobs: List[Job] = []\n    for attachment in post.attachments:  # attachments\n        if not attachment.path:\n            continue\n        jobs.append(\n            Job(\n                path=attachments_path,\n                alt_filename=attachment.name,\n                server_path=attachment.path,\n                type=PostFileTypeEnum.Attachment\n            )\n        )\n    if post.file.path:  # file\n        jobs.append(\n            Job(\n                path=post_path,\n                alt_filename=f\"{post.id}_{post.file.name}\",\n                server_path=post.file.path,\n                type=PostFileTypeEnum.File\n            )\n        )\n\n    # Write content file\n    if content_path and post.content:\n        async with aiofiles.open(content_path, \"w\", encoding=config.downloader.encoding) as f:\n            await f.write(post.content)\n    if dump_post_data:\n        async with aiofiles.open(str(post_path / DataStorageNameEnum.PostData.value), \"w\", encoding=\"utf-8\") as f:\n            await f.write(\n                post.model_dump_json(indent=config.json_dump_indent)\n            )\n\n    return jobs\n</code></pre>"},{"location":"api/#ktoolbox.action.job.filter_posts_with_indices","title":"<code>filter_posts_with_indices(posts, indices)</code>","text":"<p>Compare and filter posts by <code>CreatorIndices</code> data</p> <p>Only keep posts that was edited after last download.</p> <p>Parameters:</p> Name Type Description Default <code>posts</code> <code>List[Post]</code> <p>Posts to filter</p> required <code>indices</code> <code>CreatorIndices</code> <p><code>CreatorIndices</code> data to use</p> required <p>Returns:</p> Type Description <code>Tuple[List[Post], CreatorIndices]</code> <p>A updated <code>List[Post]</code> and updated new <code>CreatorIndices</code> instance</p> Source code in <code>ktoolbox/action/job.py</code> <pre><code>def filter_posts_with_indices(posts: List[Post], indices: CreatorIndices) -&gt; Tuple[List[Post], CreatorIndices]:\n    \"\"\"\n    Compare and filter posts by ``CreatorIndices`` data\n\n    Only keep posts that was edited after last download.\n\n    :param posts: Posts to filter\n    :param indices: ``CreatorIndices`` data to use\n    :return: A updated ``List[Post]`` and updated **new** ``CreatorIndices`` instance\n    \"\"\"\n    new_list = list(\n        filter(\n            lambda x: x.id not in indices.posts or x.edited &gt; indices.posts[x.id].edited, posts\n        )\n    )\n    new_indices = indices.model_copy(deep=True)\n    for post in new_list:\n        new_indices.posts[post.id] = post\n    return new_list, new_indices\n</code></pre>"},{"location":"api/#ktoolbox.action.search","title":"<code>search</code>","text":""},{"location":"api/#ktoolbox.action.search.__all__","title":"<code>__all__ = ['search_creator', 'search_creator_post']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.action.search.search_creator","title":"<code>search_creator(id=None, name=None, service=None)</code>  <code>async</code>","text":"<p>Search creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator(id: str = None, name: str = None, service: str = None) -&gt; BaseRet[Iterator[Creator]]:\n    \"\"\"\n    Search creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    \"\"\"\n\n    async def inner(**kwargs):\n        def filter_func(creator: Creator):\n            \"\"\"Filter creators with attributes\"\"\"\n            for key, value in kwargs.items():\n                if value is None:\n                    continue\n                elif creator.__getattribute__(key) != value:\n                    return False\n            return True\n\n        ret = await get_creators()\n        if not ret:\n            return ret\n        creators = ret.data\n        return ActionRet(data=iter(filter(filter_func, creators)))\n\n    return await inner(id=id, name=name, service=service)\n</code></pre>"},{"location":"api/#ktoolbox.action.search.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None)</code>  <code>async</code>","text":"<p>Search posts from creator with multiple keywords support.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>str</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> Source code in <code>ktoolbox/action/search.py</code> <pre><code>async def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: str = None\n) -&gt; BaseRet[List[Post]]:\n    \"\"\"\n    Search posts from creator with multiple keywords support.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    \"\"\"\n\n    async def inner(**kwargs):\n        posts: List[Post] = []\n        if any([id, name, service]):\n            if id is not None and service:  # ``get_creator_post`` required\n                ret = await get_creator_post(\n                    service=service,\n                    creator_id=id,\n                    q=q,\n                    o=o\n                )\n                return ActionRet(data=ret.data) if ret else ret\n            else:  # else need to get ``id`` and ``service``\n                creators_ret = await search_creator(id=id, name=name, service=service)\n                if not creators_ret:\n                    return ActionRet(**creators_ret.model_dump(mode=\"python\"))\n                else:\n                    for creator in creators_ret.data:\n                        ret = await get_creator_post(\n                            service=creator.service,\n                            creator_id=creator.id,\n                            q=q,\n                            o=o\n                        )\n                        if ret:\n                            posts += ret.data\n                    return ActionRet(data=posts)\n        else:\n            return ActionRet(\n                code=RetCodeEnum.MissingParameter,\n                message=generate_msg(\n                    \"Missing `id`, `name`, `service` parameter, at least given one of them.\",\n                    **kwargs\n                )\n            )\n\n    return await inner(id=id, name=name, service=service, q=q, o=o)\n</code></pre>"},{"location":"api/#ktoolbox.api","title":"<code>api</code>","text":"<ul> <li> <p>Kemono API version: <code>1.0.0</code></p> </li> <li> <p>current App commit hash: <code>7ee4a7b18ee92a442c13950c05dc8236cfb14a60</code></p> </li> </ul>"},{"location":"api/#ktoolbox.api.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.api.base.__all__","title":"<code>__all__ = ['APITenacityStop', 'APIRet', 'BaseAPI']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.APIRet","title":"<code>APIRet</code>","text":"<p>             Bases: <code>BaseRet[_T]</code></p> <p>Return data model of API call</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APIRet(BaseRet[_T]):\n    \"\"\"Return data model of API call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.api.base.APITenacityStop","title":"<code>APITenacityStop</code>","text":"<p>             Bases: <code>stop_base</code></p> <p>APIs Stop strategies</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class APITenacityStop(stop_base):\n    \"\"\"APIs Stop strategies\"\"\"\n\n    def __call__(self, retry_state: RetryCallState) -&gt; bool:\n        if config.api.retry_times is None:\n            return stop_never(retry_state)\n        else:\n            return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.APITenacityStop.__call__","title":"<code>__call__(retry_state)</code>","text":"Source code in <code>ktoolbox/api/base.py</code> <pre><code>def __call__(self, retry_state: RetryCallState) -&gt; bool:\n    if config.api.retry_times is None:\n        return stop_never(retry_state)\n    else:\n        return stop_after_attempt(config.api.retry_times)(retry_state)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI","title":"<code>BaseAPI</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[_T]</code></p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>class BaseAPI(ABC, Generic[_T]):\n    path: str = \"/\"\n    method: Literal[\"get\", \"post\"]\n    extra_validator: Optional[Callable[[str], BaseModel]] = None\n\n    Response = BaseModel\n    \"\"\"API response model\"\"\"\n\n    @classmethod\n    def handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n        \"\"\"Handle API response\"\"\"\n        try:\n            if cls.extra_validator:\n                res_model = cls.extra_validator(res.text)\n            else:\n                res_model = cls.Response.model_validate_json(res.text)\n        except (ValueError, ValidationError) as e:\n            if isinstance(e, ValueError):\n                return APIRet(\n                    code=RetCodeEnum.JsonDecodeError,\n                    message=str(e),\n                    exception=e\n                )\n            elif isinstance(e, ValidationError):\n                return APIRet(\n                    code=RetCodeEnum.ValidationError,\n                    message=str(e),\n                    exception=e\n                )\n        else:\n            data = res_model.root if isinstance(res_model, RootModel) else res_model\n            return APIRet(data=data)\n\n    @classmethod\n    @_retry\n    async def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n        \"\"\"\n        Make a request to the API\n        :param path: Fully initialed URL path\n        :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n        \"\"\"\n        if path is None:\n            path = cls.path\n        url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n        url = urlunparse(url_parts)\n        try:\n            async with httpx.AsyncClient(verify=config.ssl_verify) as client:\n                res = await client.request(\n                    method=cls.method,\n                    url=url,\n                    timeout=config.api.timeout,\n                    follow_redirects=True,\n                    **kwargs\n                )\n        except Exception as e:\n            return APIRet(\n                code=RetCodeEnum.NetWorkError,\n                message=str(e),\n                exception=e\n            )\n        else:\n            return cls.handle_res(res)\n\n    @classmethod\n    @abstractmethod\n    async def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n        \"\"\"Function to call API\"\"\"\n        ...\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.Response","title":"<code>Response = BaseModel</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>API response model</p>"},{"location":"api/#ktoolbox.api.base.BaseAPI.extra_validator","title":"<code>extra_validator: Optional[Callable[[str], BaseModel]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.method","title":"<code>method: Literal['get', 'post']</code>  <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.path","title":"<code>path: str = '/'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.base.BaseAPI.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Function to call API</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@abstractmethod\nasync def __call__(cls, *args, **kwargs) -&gt; APIRet[Response]:\n    \"\"\"Function to call API\"\"\"\n    ...\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.handle_res","title":"<code>handle_res(res)</code>  <code>classmethod</code>","text":"<p>Handle API response</p> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\ndef handle_res(cls, res: httpx.Response) -&gt; APIRet[_T]:\n    \"\"\"Handle API response\"\"\"\n    try:\n        if cls.extra_validator:\n            res_model = cls.extra_validator(res.text)\n        else:\n            res_model = cls.Response.model_validate_json(res.text)\n    except (ValueError, ValidationError) as e:\n        if isinstance(e, ValueError):\n            return APIRet(\n                code=RetCodeEnum.JsonDecodeError,\n                message=str(e),\n                exception=e\n            )\n        elif isinstance(e, ValidationError):\n            return APIRet(\n                code=RetCodeEnum.ValidationError,\n                message=str(e),\n                exception=e\n            )\n    else:\n        data = res_model.root if isinstance(res_model, RootModel) else res_model\n        return APIRet(data=data)\n</code></pre>"},{"location":"api/#ktoolbox.api.base.BaseAPI.request","title":"<code>request(path=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Make a request to the API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Fully initialed URL path</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments of <code>httpx._client.AsyncClient.request</code></p> <code>{}</code> Source code in <code>ktoolbox/api/base.py</code> <pre><code>@classmethod\n@_retry\nasync def request(cls, path: str = None, **kwargs) -&gt; APIRet[_T]:\n    \"\"\"\n    Make a request to the API\n    :param path: Fully initialed URL path\n    :param kwargs: Keyword arguments of ``httpx._client.AsyncClient.request``\n    \"\"\"\n    if path is None:\n        path = cls.path\n    url_parts = [config.api.scheme, config.api.netloc, f\"{config.api.path}{path}\", '', '', '']\n    url = urlunparse(url_parts)\n    try:\n        async with httpx.AsyncClient(verify=config.ssl_verify) as client:\n            res = await client.request(\n                method=cls.method,\n                url=url,\n                timeout=config.api.timeout,\n                follow_redirects=True,\n                **kwargs\n            )\n    except Exception as e:\n        return APIRet(\n            code=RetCodeEnum.NetWorkError,\n            message=str(e),\n            exception=e\n        )\n    else:\n        return cls.handle_res(res)\n</code></pre>"},{"location":"api/#ktoolbox.api.misc","title":"<code>misc</code>","text":""},{"location":"api/#ktoolbox.api.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement","title":"<code>announcement</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.__all__","title":"<code>__all__ = ['Announcement']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement","title":"<code>Announcement</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/announcement.py</code> <pre><code>class Announcement(BaseModel):\n    service: Optional[str] = None\n    user_id: Optional[str] = None\n    hash: Optional[str] = None\n    \"\"\"sha256\"\"\"\n    content: Optional[str] = None\n    added: Optional[datetime] = None\n    # noinspection SpellCheckingInspection\n    \"\"\"isoformat UTC\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>isoformat UTC</p>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement.hash","title":"<code>hash: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sha256</p>"},{"location":"api/#ktoolbox.api.model.announcement.Announcement.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.announcement.Announcement.user_id","title":"<code>user_id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.creator","title":"<code>creator</code>","text":""},{"location":"api/#ktoolbox.api.model.creator.__all__","title":"<code>__all__ = ['Creator']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.creator.Creator","title":"<code>Creator</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/creator.py</code> <pre><code>class Creator(BaseModel):\n    # noinspection SpellCheckingInspection\n    favorited: int\n    # noinspection SpellCheckingInspection\n    \"\"\"The number of times this creator has been favorited\"\"\"\n    id: str\n    \"\"\"The ID of the creator\"\"\"\n    indexed: float\n    \"\"\"Timestamp when the creator was indexed, Unix time as integer\"\"\"\n    name: str\n    \"\"\"The name of the creator\"\"\"\n    service: str\n    \"\"\"The service for the creator\"\"\"\n    updated: float\n    \"\"\"Timestamp when the creator was last updated, Unix time as integer\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.api.model.creator.Creator.favorited","title":"<code>favorited: int</code>  <code>instance-attribute</code>","text":"<p>The number of times this creator has been favorited</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>The ID of the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.indexed","title":"<code>indexed: float</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was indexed, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>The service for the creator</p>"},{"location":"api/#ktoolbox.api.model.creator.Creator.updated","title":"<code>updated: float</code>  <code>instance-attribute</code>","text":"<p>Timestamp when the creator was last updated, Unix time as integer</p>"},{"location":"api/#ktoolbox.api.model.post","title":"<code>post</code>","text":""},{"location":"api/#ktoolbox.api.model.post.__all__","title":"<code>__all__ = ['File', 'Attachment', 'Post']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Attachment","title":"<code>Attachment</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Attachment(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.Attachment.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Attachment.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.File","title":"<code>File</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class File(BaseModel):\n    name: Optional[str] = None\n    path: Optional[str] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.File.name","title":"<code>name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.File.path","title":"<code>path: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post","title":"<code>Post</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>ktoolbox/api/model/post.py</code> <pre><code>class Post(BaseModel):\n    id: Optional[str] = None\n    user: Optional[str] = None\n    service: Optional[str] = None\n    title: Optional[str] = None\n    content: Optional[str] = None\n    embed: Optional[Dict[str, Any]] = None\n    shared_file: Optional[bool] = None\n    added: Optional[datetime] = None\n    published: Optional[datetime] = None\n    edited: Optional[datetime] = None\n    file: Optional[File] = None\n    attachments: Optional[List[Attachment]] = None\n</code></pre>"},{"location":"api/#ktoolbox.api.model.post.Post.added","title":"<code>added: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.attachments","title":"<code>attachments: Optional[List[Attachment]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.content","title":"<code>content: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.edited","title":"<code>edited: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.embed","title":"<code>embed: Optional[Dict[str, Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.file","title":"<code>file: Optional[File] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.id","title":"<code>id: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.published","title":"<code>published: Optional[datetime] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.service","title":"<code>service: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.shared_file","title":"<code>shared_file: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.title","title":"<code>title: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.model.post.Post.user","title":"<code>user: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.api.posts","title":"<code>posts</code>","text":""},{"location":"api/#ktoolbox.api.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.api.utils.SEARCH_STEP","title":"<code>SEARCH_STEP = 50</code>  <code>module-attribute</code>","text":"<p>Searching APIs result steps</p>"},{"location":"api/#ktoolbox.api.utils.__all__","title":"<code>__all__ = ['SEARCH_STEP', 'get_creator_icon', 'get_creator_banner']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.api.utils.get_creator_banner","title":"<code>get_creator_banner(creator_id, service)</code>","text":"<p>Get the creator banner for a given creator ID and service.</p> <p>Returns:</p> Type Description <code>str</code> <p>The banner URL.</p> Source code in <code>ktoolbox/api/utils.py</code> <pre><code>def get_creator_banner(creator_id: str, service: str) -&gt; str:\n    \"\"\"\n    Get the creator banner for a given creator ID and service.\n\n    :return: The banner URL.\n    \"\"\"\n    url_parts = [config.api.scheme, config.api.statics_netloc, f\"/banners/{service}/{creator_id}\", '', '', '']\n    return urlunparse(url_parts)\n</code></pre>"},{"location":"api/#ktoolbox.api.utils.get_creator_icon","title":"<code>get_creator_icon(creator_id, service)</code>","text":"<p>Get the creator icon for a given creator ID and service.</p> <p>Returns:</p> Type Description <code>str</code> <p>The icon URL.</p> Source code in <code>ktoolbox/api/utils.py</code> <pre><code>def get_creator_icon(creator_id: str, service: str) -&gt; str:\n    \"\"\"\n    Get the creator icon for a given creator ID and service.\n\n    :return: The icon URL.\n    \"\"\"\n    url_parts = [config.api.scheme, config.api.statics_netloc, f\"/icons/{service}/{creator_id}\", '', '', '']\n    return urlunparse(url_parts)\n</code></pre>"},{"location":"api/#ktoolbox.cli","title":"<code>cli</code>","text":""},{"location":"api/#ktoolbox.cli.__all__","title":"<code>__all__ = ['KToolBoxCli']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.cli.KToolBoxCli","title":"<code>KToolBoxCli</code>","text":"Source code in <code>ktoolbox/cli.py</code> <pre><code>class KToolBoxCli:\n    @staticmethod\n    async def version():\n        \"\"\"Show KToolBox version\"\"\"\n        return __version__\n\n    @staticmethod\n    async def site_version():\n        # noinspection SpellCheckingInspection\n        \"\"\"Show current Kemono site app commit hash\"\"\"\n        ret = await get_app_version()\n        return ret.data if ret else ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator(\n            name: str = None,\n            id: str = None,\n            service: str = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await search_creator_action(id=id, name=name, service=service)\n        if ret:\n            result_list = list(ret.data)\n            if dump:\n                await dump_search(result_list, dump)\n            return result_list or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator_post(\n            id: str = None,\n            name: str = None,\n            service: str = None,\n            q: str = None,\n            o: int = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search posts from creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n        if ret:\n            if dump:\n                await dump_search(ret.data, dump)\n            return ret.data or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    @staticmethod\n    async def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n        \"\"\"\n        Get a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            if dump:\n                async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                    await f.write(\n                        ret.data.model_dump_json(indent=config.json_dump_indent)\n                    )\n            return ret.data\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def download_post(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def download_post(\n            service: str,\n            creator_id: str,\n            post_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    async def download_post(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            post_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        \"\"\"\n        Download a specific post\n\n        :param url: The post URL\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param path: Download path, default is current directory\n        :param dump_post_data: Whether to dump post data (post.json) in post directory\n        \"\"\"\n        # Get service, creator_id, post_id\n        if url:\n            service, creator_id, post_id = parse_webpage_url(url)\n        if not all([service, creator_id, post_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\", \"post_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            post_path = path / ret.data.id if config.job.post_id_as_path else path / sanitize_filename(ret.data.title)\n            job_list = await create_job_from_post(\n                post=ret.data,\n                post_path=post_path,\n                dump_post_data=dump_post_data\n            )\n            job_runner = JobRunner(job_list=job_list)\n            await job_runner.start()\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Path = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            service: str,\n            creator_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Path = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        ...\n\n    @staticmethod\n    async def sync_creator(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Union[Path, str] = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        \"\"\"\n        Sync all posts from a creator\n\n        You can update the directory anytime after download finished, \\\n        such as to update after creator published new posts.\n\n        * If ``update_from`` was provided, it should be located **inside the creator directory**.\n\n        :param url: The post URL\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param path: Download path, default is current directory\n        :param update_from: ``CreatorIndices`` data path for update posts from current creator directory, \\\n         ``save_creator_indices`` will be enabled if this provided\n        :param save_creator_indices: Record ``CreatorIndices`` data for update posts from current creator directory\n        :param mix_posts: Save all files from different posts at same path, \\\n         ``update_from``, ``save_creator_indices`` will be ignored if enabled\n        \"\"\"\n        # Get service, creator_id\n        if url:\n            service, creator_id, _ = parse_webpage_url(url)\n        if not all([service, creator_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        if update_from:\n            update_from = update_from if isinstance(update_from, Path) else Path(update_from)\n\n        # Get ``CreatorIndices`` data\n        if update_from:\n            async with aiofiles.open(update_from, encoding=\"utf-8\") as f:\n                indices_text = await f.read()\n            indices = CreatorIndices.model_validate_json(indices_text)\n            creator_path = update_from.parent\n        else:\n            indices = None\n\n            # Get creator name\n            creator_name = creator_id\n            creator_ret = await search_creator_action(id=creator_id, service=service)\n            if creator_ret:\n                creator = next(creator_ret.data, None)\n                if creator:\n                    creator_name = creator.name\n                    logger.info(\n                        generate_msg(\n                            \"Got creator information\",\n                            name=creator.name,\n                            id=creator.id\n                        )\n                    )\n            else:\n                logger.warning(\n                    generate_msg(\n                        f\"Failed to fetch the name of creator &lt;{creator_id}&gt;, use creator ID as directory name\",\n                        detail=creator_ret.message\n                    )\n                )\n            creator_path = path / sanitize_filename(creator_name)\n\n        creator_path.mkdir(exist_ok=True)\n        ret = await create_job_from_creator(\n            service=service,\n            creator_id=creator_id,\n            path=creator_path,\n            update_from=indices,\n            all_pages=True,\n            save_creator_indices=save_creator_indices,\n            mix_posts=mix_posts\n        )\n        if ret:\n            job_runner = JobRunner(job_list=ret.data)\n            await job_runner.start()\n        else:\n            return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.download_post","title":"<code>download_post(url=None, service=None, creator_id=None, post_id=None, path=Path('.'), *, dump_post_data=True)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Download a specific post</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service name</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The creator's ID</p> <code>None</code> <code>post_id</code> <code>str</code> <p>The post ID</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>dump_post_data</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def download_post(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        post_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        dump_post_data=True\n):\n    \"\"\"\n    Download a specific post\n\n    :param url: The post URL\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param path: Download path, default is current directory\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    # Get service, creator_id, post_id\n    if url:\n        service, creator_id, post_id = parse_webpage_url(url)\n    if not all([service, creator_id, post_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\", \"post_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        post_path = path / ret.data.id if config.job.post_id_as_path else path / sanitize_filename(ret.data.title)\n        job_list = await create_job_from_post(\n            post=ret.data,\n            post_path=post_path,\n            dump_post_data=dump_post_data\n        )\n        job_runner = JobRunner(job_list=job_list)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.get_post","title":"<code>get_post(service, creator_id, post_id, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Get a specific post</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n    \"\"\"\n    Get a specific post\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        if dump:\n            async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                await f.write(\n                    ret.data.model_dump_json(indent=config.json_dump_indent)\n                )\n        return ret.data\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.search_creator","title":"<code>search_creator(name=None, id=None, service=None, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator(\n        name: str = None,\n        id: str = None,\n        service: str = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    ret = await search_creator_action(id=id, name=name, service=service)\n    if ret:\n        result_list = list(ret.data)\n        if dump:\n            await dump_search(result_list, dump)\n        return result_list or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.search_creator_post","title":"<code>search_creator_post(id=None, name=None, service=None, q=None, o=None, *, dump=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search posts from creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: int = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search posts from creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n    if ret:\n        if dump:\n            await dump_search(ret.data, dump)\n        return ret.data or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.site_version","title":"<code>site_version()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show current Kemono site app commit hash</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def site_version():\n    # noinspection SpellCheckingInspection\n    \"\"\"Show current Kemono site app commit hash\"\"\"\n    ret = await get_app_version()\n    return ret.data if ret else ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.sync_creator","title":"<code>sync_creator(url=None, service=None, creator_id=None, path=Path('.'), *, update_from=None, save_creator_indices=True, mix_posts=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Sync all posts from a creator</p> <p>You can update the directory anytime after download finished,         such as to update after creator published new posts.</p> <ul> <li>If <code>update_from</code> was provided, it should be located inside the creator directory.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service where the post is located</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>update_from</code> <code>Union[Path, str]</code> <p><code>CreatorIndices</code> data path for update posts from current creator directory,          <code>save_creator_indices</code> will be enabled if this provided</p> <code>None</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data for update posts from current creator directory</p> <code>True</code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path,          <code>update_from</code>, <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def sync_creator(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        update_from: Union[Path, str] = None,\n        save_creator_indices: bool = True,\n        mix_posts: bool = None\n):\n    \"\"\"\n    Sync all posts from a creator\n\n    You can update the directory anytime after download finished, \\\n    such as to update after creator published new posts.\n\n    * If ``update_from`` was provided, it should be located **inside the creator directory**.\n\n    :param url: The post URL\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: Download path, default is current directory\n    :param update_from: ``CreatorIndices`` data path for update posts from current creator directory, \\\n     ``save_creator_indices`` will be enabled if this provided\n    :param save_creator_indices: Record ``CreatorIndices`` data for update posts from current creator directory\n    :param mix_posts: Save all files from different posts at same path, \\\n     ``update_from``, ``save_creator_indices`` will be ignored if enabled\n    \"\"\"\n    # Get service, creator_id\n    if url:\n        service, creator_id, _ = parse_webpage_url(url)\n    if not all([service, creator_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n    if update_from:\n        update_from = update_from if isinstance(update_from, Path) else Path(update_from)\n\n    # Get ``CreatorIndices`` data\n    if update_from:\n        async with aiofiles.open(update_from, encoding=\"utf-8\") as f:\n            indices_text = await f.read()\n        indices = CreatorIndices.model_validate_json(indices_text)\n        creator_path = update_from.parent\n    else:\n        indices = None\n\n        # Get creator name\n        creator_name = creator_id\n        creator_ret = await search_creator_action(id=creator_id, service=service)\n        if creator_ret:\n            creator = next(creator_ret.data, None)\n            if creator:\n                creator_name = creator.name\n                logger.info(\n                    generate_msg(\n                        \"Got creator information\",\n                        name=creator.name,\n                        id=creator.id\n                    )\n                )\n        else:\n            logger.warning(\n                generate_msg(\n                    f\"Failed to fetch the name of creator &lt;{creator_id}&gt;, use creator ID as directory name\",\n                    detail=creator_ret.message\n                )\n            )\n        creator_path = path / sanitize_filename(creator_name)\n\n    creator_path.mkdir(exist_ok=True)\n    ret = await create_job_from_creator(\n        service=service,\n        creator_id=creator_id,\n        path=creator_path,\n        update_from=indices,\n        all_pages=True,\n        save_creator_indices=save_creator_indices,\n        mix_posts=mix_posts\n    )\n    if ret:\n        job_runner = JobRunner(job_list=ret.data)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"api/#ktoolbox.cli.KToolBoxCli.version","title":"<code>version()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show KToolBox version</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def version():\n    \"\"\"Show KToolBox version\"\"\"\n    return __version__\n</code></pre>"},{"location":"api/#ktoolbox.configuration","title":"<code>configuration</code>","text":""},{"location":"api/#ktoolbox.configuration.__all__","title":"<code>__all__ = ['config', 'APIConfiguration', 'DownloaderConfiguration', 'PostStructureConfiguration', 'JobConfiguration', 'Configuration']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.config","title":"<code>config = Configuration(_env_file='prod.env')</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration","title":"<code>APIConfiguration</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Kemono API Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Kemono API URL scheme</p> <code>netloc</code> <code>str</code> <p>Kemono API URL netloc</p> <code>statics_netloc</code> <code>str</code> <p>URL netloc of Kemono server for static files (e.g. images)</p> <code>files_netloc</code> <code>str</code> <p>URL netloc of Kemono server for post files</p> <code>path</code> <code>str</code> <p>Kemono API URL root path</p> <code>timeout</code> <code>float</code> <p>API request timeout</p> <code>retry_times</code> <code>int</code> <p>API request retry times (when request failed)</p> <code>retry_interval</code> <code>float</code> <p>Seconds of API request retry interval</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class APIConfiguration(BaseModel):\n    \"\"\"\n    Kemono API Configuration\n\n    :ivar scheme: Kemono API URL scheme\n    :ivar netloc: Kemono API URL netloc\n    :ivar statics_netloc: URL netloc of Kemono server for static files (e.g. images)\n    :ivar files_netloc: URL netloc of Kemono server for post files\n    :ivar path: Kemono API URL root path\n    :ivar timeout: API request timeout\n    :ivar retry_times: API request retry times (when request failed)\n    :ivar retry_interval: Seconds of API request retry interval\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    netloc: str = \"kemono.su\"\n    statics_netloc: str = \"img.kemono.su\"\n    files_netloc: str = \"kemono.su\"\n    path: str = \"/api/v1\"\n    timeout: float = 5.0\n    retry_times: int = 3\n    retry_interval: float = 2.0\n</code></pre>"},{"location":"api/#ktoolbox.configuration.APIConfiguration.files_netloc","title":"<code>files_netloc: str = 'kemono.su'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.netloc","title":"<code>netloc: str = 'kemono.su'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.path","title":"<code>path: str = '/api/v1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.retry_interval","title":"<code>retry_interval: float = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.retry_times","title":"<code>retry_times: int = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.statics_netloc","title":"<code>statics_netloc: str = 'img.kemono.su'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.APIConfiguration.timeout","title":"<code>timeout: float = 5.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>KToolBox Configuration</p> <p>Attributes:</p> Name Type Description <code>api</code> <code>APIConfiguration</code> <code>downloader</code> <code>DownloaderConfiguration</code> <code>job</code> <code>JobConfiguration</code> <code>logger</code> <code>LoggerConfiguration</code> <code>ssl_verify</code> <code>bool</code> <p>Enable SSL certificate verification for Kemono API server and download server</p> <code>json_dump_indent</code> <code>int</code> <p>Indent of JSON file dump</p> <code>use_uvloop</code> <code>bool</code> <p>Use uvloop for asyncio (Disabled on Windows by default)     uvloop will improve concurrent performance, but it is not compatible with Windows.     Install uvloop by <code>pip install ktoolbox[uvloop]</code> or it will not work.</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class Configuration(BaseSettings):\n    # noinspection SpellCheckingInspection,GrazieInspection\n    \"\"\"\n    KToolBox Configuration\n\n    :ivar api:\n    :ivar downloader:\n    :ivar job:\n    :ivar logger:\n    :ivar ssl_verify: Enable SSL certificate verification for Kemono API server and download server\n    :ivar json_dump_indent: Indent of JSON file dump\n    :ivar use_uvloop: Use uvloop for asyncio (Disabled on Windows by default) \\\n    uvloop will improve concurrent performance, but it is not compatible with Windows. \\\n    Install uvloop by `pip install ktoolbox[uvloop]` or it will not work.\n    \"\"\"\n    api: APIConfiguration = APIConfiguration()\n    downloader: DownloaderConfiguration = DownloaderConfiguration()\n    job: JobConfiguration = JobConfiguration()\n    logger: LoggerConfiguration = LoggerConfiguration()\n\n    ssl_verify: bool = True\n    json_dump_indent: int = 4\n    use_uvloop: bool = True\n\n    # noinspection SpellCheckingInspection\n    model_config = SettingsConfigDict(\n        env_prefix='ktoolbox_',\n        env_nested_delimiter='__',\n        env_file='.env',\n        env_file_encoding='utf-8'\n    )\n</code></pre>"},{"location":"api/#ktoolbox.configuration.Configuration.api","title":"<code>api: APIConfiguration = APIConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.downloader","title":"<code>downloader: DownloaderConfiguration = DownloaderConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.job","title":"<code>job: JobConfiguration = JobConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.json_dump_indent","title":"<code>json_dump_indent: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.logger","title":"<code>logger: LoggerConfiguration = LoggerConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.model_config","title":"<code>model_config = SettingsConfigDict(env_prefix='ktoolbox_', env_nested_delimiter='__', env_file='.env', env_file_encoding='utf-8')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.ssl_verify","title":"<code>ssl_verify: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.Configuration.use_uvloop","title":"<code>use_uvloop: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration","title":"<code>DownloaderConfiguration</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>File Downloader Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Downloader URL scheme</p> <code>timeout</code> <code>float</code> <p>Downloader request timeout</p> <code>encoding</code> <code>str</code> <p>Charset for filename parsing and post content text saving</p> <code>buffer_size</code> <code>int</code> <p>Number of bytes of file I/O buffer for each downloading file</p> <code>chunk_size</code> <code>int</code> <p>Number of bytes of chunk of downloader stream</p> <code>temp_suffix</code> <code>str</code> <p>Temp filename suffix of downloading files</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class DownloaderConfiguration(BaseModel):\n    \"\"\"\n    File Downloader Configuration\n\n    :ivar scheme: Downloader URL scheme\n    :ivar timeout: Downloader request timeout\n    :ivar encoding: Charset for filename parsing and post content text saving\n    :ivar buffer_size: Number of bytes of file I/O buffer for each downloading file\n    :ivar chunk_size: Number of bytes of chunk of downloader stream\n    :ivar temp_suffix: Temp filename suffix of downloading files\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    timeout: float = 30.0\n    encoding: str = \"utf-8\"\n    buffer_size: int = 20480\n    chunk_size: int = 1024\n    temp_suffix: str = \"tmp\"\n</code></pre>"},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.buffer_size","title":"<code>buffer_size: int = 20480</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.chunk_size","title":"<code>chunk_size: int = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.encoding","title":"<code>encoding: str = 'utf-8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.temp_suffix","title":"<code>temp_suffix: str = 'tmp'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.DownloaderConfiguration.timeout","title":"<code>timeout: float = 30.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration","title":"<code>JobConfiguration</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Download jobs Configuration</p> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>Number of coroutines for concurrent download</p> <code>post_id_as_path</code> <code>bool</code> <p>Use post ID as post directory name</p> <code>post_structure</code> <code>PostStructureConfiguration</code> <p>Post path structure</p> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path in creator directory.     It would not create any post directory, and <code>CreatorIndices</code> would not been recorded,     without <code>CreatorIndices</code> you cannot update the creator directory.</p> <code>job_list_filepath</code> <code>Optional[Path]</code> <p>Filepath for job list data saving, <code>None</code> for disable job list saving</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class JobConfiguration(BaseModel):\n    \"\"\"\n    Download jobs Configuration\n\n    :ivar count: Number of coroutines for concurrent download\n    :ivar post_id_as_path: Use post ID as post directory name\n    :ivar post_structure: Post path structure\n    :ivar mix_posts: Save all files from different posts at same path in creator directory. \\\n    It would not create any post directory, and ``CreatorIndices`` would not been recorded, \\\n    without ``CreatorIndices`` you **cannot update** the creator directory.\n    :ivar job_list_filepath: Filepath for job list data saving, ``None`` for disable job list saving\n    \"\"\"\n    count: int = 4\n    post_id_as_path: bool = False\n    post_structure: PostStructureConfiguration = PostStructureConfiguration()\n    mix_posts: bool = False\n    job_list_filepath: Optional[Path] = None\n</code></pre>"},{"location":"api/#ktoolbox.configuration.JobConfiguration.count","title":"<code>count: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.job_list_filepath","title":"<code>job_list_filepath: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.mix_posts","title":"<code>mix_posts: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.post_id_as_path","title":"<code>post_id_as_path: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.JobConfiguration.post_structure","title":"<code>post_structure: PostStructureConfiguration = PostStructureConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration","title":"<code>LoggerConfiguration</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Logger configuration</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Optional[Path]</code> <p>Path to save logs, <code>None</code> for disable log file output</p> <code>level</code> <code>Union[str, int]</code> <p>Log filter level</p> <code>rotation</code> <code>Union[str, int, time, timedelta]</code> <p>Log rotation</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class LoggerConfiguration(BaseModel):\n    \"\"\"\n    Logger configuration\n\n    :ivar path: Path to save logs, ``None`` for disable log file output\n    :ivar level: Log filter level\n    :ivar rotation: Log rotation\n    \"\"\"\n    path: Optional[Path] = Path(\"logs\")\n    level: Union[str, int] = logging.DEBUG\n    rotation: Union[str, int, datetime.time, datetime.timedelta] = \"1 week\"\n</code></pre>"},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.level","title":"<code>level: Union[str, int] = logging.DEBUG</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.path","title":"<code>path: Optional[Path] = Path('logs')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.LoggerConfiguration.rotation","title":"<code>rotation: Union[str, int, datetime.time, datetime.timedelta] = '1 week'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration","title":"<code>PostStructureConfiguration</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Post path structure model</p> <ul> <li>Default: <pre><code>|-- ..\n|-- attachments\n|   |-- 1.png\n|   |-- 2.png\n|-- content.txt\n|-- &lt;Post file&gt;\n|-- &lt;Post data (post.ktoolbox.json)&gt;\n</code></pre></li> </ul> <p>Attributes:</p> Name Type Description <code>attachments</code> <code>Path</code> <p>Sub path of attachment directory</p> <code>content_filepath</code> <code>Path</code> <p>Sub path of post content HTML file</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class PostStructureConfiguration(BaseModel):\n    # noinspection SpellCheckingInspection\n    \"\"\"\n    Post path structure model\n\n    - Default:\n    ```\n    |-- ..\n    |-- attachments\n    |   |-- 1.png\n    |   |-- 2.png\n    |-- content.txt\n    |-- &lt;Post file&gt;\n    |-- &lt;Post data (post.ktoolbox.json)&gt;\n    ```\n\n    :ivar attachments: Sub path of attachment directory\n    :ivar content_filepath: Sub path of post content HTML file\n    \"\"\"\n    attachments: Path = Path(\"attachments\")\n    content_filepath: Path = Path(\"index.html\")\n</code></pre>"},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.attachments","title":"<code>attachments: Path = Path('attachments')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.configuration.PostStructureConfiguration.content_filepath","title":"<code>content_filepath: Path = Path('index.html')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader","title":"<code>downloader</code>","text":""},{"location":"api/#ktoolbox.downloader.base","title":"<code>base</code>","text":""},{"location":"api/#ktoolbox.downloader.base.__all__","title":"<code>__all__ = ['DownloaderRet']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.base.DownloaderRet","title":"<code>DownloaderRet</code>","text":"<p>             Bases: <code>BaseRet[_T]</code></p> <p>Return data model of action call</p> Source code in <code>ktoolbox/downloader/base.py</code> <pre><code>class DownloaderRet(BaseRet[_T]):\n    \"\"\"Return data model of action call\"\"\"\n    pass\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader","title":"<code>downloader</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.__all__","title":"<code>__all__ = ['Downloader']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader","title":"<code>Downloader</code>","text":"Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>class Downloader:\n    def __init__(\n            self,\n            url: str,\n            path: Path,\n            *,\n            buffer_size: int = None,\n            chunk_size: int = None,\n            alt_filename: str = None\n    ):\n        \"\"\"\n        Initialize a file downloader\n\n        - About filename:\n            * If ``Content-Disposition`` is set in headers, use filename from it.\n            * Else if ``alt_filename`` parameter is set, use it.\n            * Else use filename from URL 'path' part.\n\n        :param url: Download URL\n        :param path: Directory path to save the file\n        :param buffer_size: Number of bytes for file I/O buffer\n        :param chunk_size: Number of bytes for chunk of download stream\n        :param alt_filename: Use this name if no filename given by the server\n        \"\"\"\n\n        self._url = url\n        self._path = path\n        self._buffer_size = buffer_size or config.downloader.buffer_size\n        self._chunk_size = chunk_size or config.downloader.chunk_size\n        self._alt_filename = alt_filename\n        self._filename = alt_filename\n\n        self._lock = asyncio.Lock()\n        self._stop: bool = False\n\n    @cached_property\n    def url(self) -&gt; str:\n        \"\"\"Download URL\"\"\"\n        return self._url\n\n    @cached_property\n    def path(self) -&gt; Path:\n        \"\"\"Directory path to save the file\"\"\"\n        return self._path\n\n    @cached_property\n    def buffer_size(self) -&gt; int:\n        \"\"\"Number of bytes for file I/O buffer\"\"\"\n        return self._buffer_size\n\n    @cached_property\n    def chunk_size(self) -&gt; int:\n        \"\"\"Number of bytes for chunk of download stream\"\"\"\n        return self._chunk_size\n\n    @property\n    def filename(self) -&gt; Optional[str]:\n        \"\"\"Actual filename of the download file\"\"\"\n        return self._filename\n\n    @property\n    def finished(self) -&gt; bool:\n        \"\"\"\n        Check if the download finished\n\n        :return: ``False`` if the download **in process**, ``True`` otherwise\n        \"\"\"\n        return not self._lock.locked()\n\n    def cancel(self):\n        \"\"\"\n        Cancel the download\n\n        It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n        \"\"\"\n        self._stop = True\n\n    async def run(\n            self,\n            *,\n            sync_callable: Callable[[\"Downloader\"], Any] = None,\n            async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n            tqdm_class: Type[std_tqdm] = None,\n            progress: bool = False\n    ) -&gt; DownloaderRet[str]:\n        \"\"\"\n        Start to download\n\n        :param sync_callable: Sync callable for download finished\n        :param async_callable: Async callable for download finished\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        :return: ``DownloaderRet`` which contain the actual output filename\n        :raise CancelledError\n        \"\"\"\n        # Use ``self._alt_filename`` instead of filename from server,\n        # to make the process more efficient\n        if (self._path / self._filename).is_file():\n            return DownloaderRet(\n                code=RetCodeEnum.FileExisted,\n                message=generate_msg(\n                    \"Download file existed, skipped\",\n                    path=self._path / self._filename\n                )\n            )\n\n        tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n        async with self._lock:\n            async with httpx.AsyncClient(verify=config.ssl_verify) as client:\n                async with client.stream(\n                        method=\"GET\",\n                        url=self._url,\n                        follow_redirects=True,\n                        timeout=config.downloader.timeout\n                ) as res:  # type: httpx.Response\n                    if res.status_code != httpx.codes.OK:\n                        return DownloaderRet(\n                            code=RetCodeEnum.GeneralFailure,\n                            message=generate_msg(\n                                \"Download failed\",\n                                status_code=res.status_code,\n                                filename=self._alt_filename\n                            )\n                        )\n\n                    # Get filename\n                    if not (filename := filename_from_headers(res.headers)):\n                        if not (filename := self._alt_filename):\n                            filename = urllib.parse.unquote(Path(self._url).name)\n                    self._filename = filename\n\n                    # Download\n                    temp_filepath = (self._path / filename).with_suffix(f\".{config.downloader.temp_suffix}\")\n                    total_size = int(length_str) if (length_str := res.headers.get(\"Content-Length\")) else None\n                    async with aiofiles.open(str(temp_filepath), \"wb\", self._buffer_size) as f:\n                        chunk_iterator = res.aiter_bytes(self._chunk_size)\n                        t = tqdm_class(\n                            desc=filename,\n                            total=total_size,\n                            disable=not progress,\n                            unit=\"B\",\n                            unit_scale=True\n                        )\n                        async for chunk in chunk_iterator:\n                            if self._stop:\n                                raise CancelledError\n                            await f.write(chunk)\n                            t.update(len(chunk))  # Update progress bar\n\n            # Download finished\n            temp_filepath.rename(self._path / filename)\n            if sync_callable:\n                sync_callable(self)\n            if async_callable:\n                await async_callable(self)\n            return DownloaderRet(\n                data=filename\n            ) if filename else DownloaderRet(\n                code=RetCodeEnum.GeneralFailure,\n                message=generate_msg(\n                    \"Download failed\",\n                    filename=self._alt_filename\n                )\n            )\n\n    __call__ = run\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.__call__","title":"<code>__call__ = run</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.downloader.downloader.Downloader.buffer_size","title":"<code>buffer_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for file I/O buffer</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.chunk_size","title":"<code>chunk_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of bytes for chunk of download stream</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.filename","title":"<code>filename: Optional[str]</code>  <code>property</code>","text":"<p>Actual filename of the download file</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.finished","title":"<code>finished: bool</code>  <code>property</code>","text":"<p>Check if the download finished</p> <p>Returns:</p> Type Description <p><code>False</code> if the download in process, <code>True</code> otherwise</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.path","title":"<code>path: Path</code>  <code>cached</code> <code>property</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.url","title":"<code>url: str</code>  <code>cached</code> <code>property</code>","text":"<p>Download URL</p>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.__init__","title":"<code>__init__(url, path, *, buffer_size=None, chunk_size=None, alt_filename=None)</code>","text":"<p>Initialize a file downloader</p> <ul> <li>About filename:<ul> <li>If <code>Content-Disposition</code> is set in headers, use filename from it.</li> <li>Else if <code>alt_filename</code> parameter is set, use it.</li> <li>Else use filename from URL 'path' part.</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Download URL</p> required <code>path</code> <code>Path</code> <p>Directory path to save the file</p> required <code>buffer_size</code> <code>int</code> <p>Number of bytes for file I/O buffer</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>Number of bytes for chunk of download stream</p> <code>None</code> <code>alt_filename</code> <code>str</code> <p>Use this name if no filename given by the server</p> <code>None</code> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def __init__(\n        self,\n        url: str,\n        path: Path,\n        *,\n        buffer_size: int = None,\n        chunk_size: int = None,\n        alt_filename: str = None\n):\n    \"\"\"\n    Initialize a file downloader\n\n    - About filename:\n        * If ``Content-Disposition`` is set in headers, use filename from it.\n        * Else if ``alt_filename`` parameter is set, use it.\n        * Else use filename from URL 'path' part.\n\n    :param url: Download URL\n    :param path: Directory path to save the file\n    :param buffer_size: Number of bytes for file I/O buffer\n    :param chunk_size: Number of bytes for chunk of download stream\n    :param alt_filename: Use this name if no filename given by the server\n    \"\"\"\n\n    self._url = url\n    self._path = path\n    self._buffer_size = buffer_size or config.downloader.buffer_size\n    self._chunk_size = chunk_size or config.downloader.chunk_size\n    self._alt_filename = alt_filename\n    self._filename = alt_filename\n\n    self._lock = asyncio.Lock()\n    self._stop: bool = False\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the download</p> <p>It will raise <code>asyncio.CancelledError</code> in <code>chunk_iterator</code> (writing chunk to file) iteration.</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>def cancel(self):\n    \"\"\"\n    Cancel the download\n\n    It will raise ``asyncio.CancelledError`` in ``chunk_iterator`` (writing chunk to file) iteration.\n    \"\"\"\n    self._stop = True\n</code></pre>"},{"location":"api/#ktoolbox.downloader.downloader.Downloader.run","title":"<code>run(*, sync_callable=None, async_callable=None, tqdm_class=None, progress=False)</code>  <code>async</code>","text":"<p>Start to download</p> <p>Parameters:</p> Name Type Description Default <code>sync_callable</code> <code>Callable[[Downloader], Any]</code> <p>Sync callable for download finished</p> <code>None</code> <code>async_callable</code> <code>Callable[[Downloader], Coroutine]</code> <p>Async callable for download finished</p> <code>None</code> <code>tqdm_class</code> <code>Type[tqdm]</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>False</code> <p>Returns:</p> Type Description <code>DownloaderRet[str]</code> <p><code>DownloaderRet</code> which contain the actual output filename</p> Source code in <code>ktoolbox/downloader/downloader.py</code> <pre><code>async def run(\n        self,\n        *,\n        sync_callable: Callable[[\"Downloader\"], Any] = None,\n        async_callable: Callable[[\"Downloader\"], Coroutine] = None,\n        tqdm_class: Type[std_tqdm] = None,\n        progress: bool = False\n) -&gt; DownloaderRet[str]:\n    \"\"\"\n    Start to download\n\n    :param sync_callable: Sync callable for download finished\n    :param async_callable: Async callable for download finished\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    :return: ``DownloaderRet`` which contain the actual output filename\n    :raise CancelledError\n    \"\"\"\n    # Use ``self._alt_filename`` instead of filename from server,\n    # to make the process more efficient\n    if (self._path / self._filename).is_file():\n        return DownloaderRet(\n            code=RetCodeEnum.FileExisted,\n            message=generate_msg(\n                \"Download file existed, skipped\",\n                path=self._path / self._filename\n            )\n        )\n\n    tqdm_class: Type[std_tqdm] = tqdm_class or tqdm.asyncio.tqdm\n    async with self._lock:\n        async with httpx.AsyncClient(verify=config.ssl_verify) as client:\n            async with client.stream(\n                    method=\"GET\",\n                    url=self._url,\n                    follow_redirects=True,\n                    timeout=config.downloader.timeout\n            ) as res:  # type: httpx.Response\n                if res.status_code != httpx.codes.OK:\n                    return DownloaderRet(\n                        code=RetCodeEnum.GeneralFailure,\n                        message=generate_msg(\n                            \"Download failed\",\n                            status_code=res.status_code,\n                            filename=self._alt_filename\n                        )\n                    )\n\n                # Get filename\n                if not (filename := filename_from_headers(res.headers)):\n                    if not (filename := self._alt_filename):\n                        filename = urllib.parse.unquote(Path(self._url).name)\n                self._filename = filename\n\n                # Download\n                temp_filepath = (self._path / filename).with_suffix(f\".{config.downloader.temp_suffix}\")\n                total_size = int(length_str) if (length_str := res.headers.get(\"Content-Length\")) else None\n                async with aiofiles.open(str(temp_filepath), \"wb\", self._buffer_size) as f:\n                    chunk_iterator = res.aiter_bytes(self._chunk_size)\n                    t = tqdm_class(\n                        desc=filename,\n                        total=total_size,\n                        disable=not progress,\n                        unit=\"B\",\n                        unit_scale=True\n                    )\n                    async for chunk in chunk_iterator:\n                        if self._stop:\n                            raise CancelledError\n                        await f.write(chunk)\n                        t.update(len(chunk))  # Update progress bar\n\n        # Download finished\n        temp_filepath.rename(self._path / filename)\n        if sync_callable:\n            sync_callable(self)\n        if async_callable:\n            await async_callable(self)\n        return DownloaderRet(\n            data=filename\n        ) if filename else DownloaderRet(\n            code=RetCodeEnum.GeneralFailure,\n            message=generate_msg(\n                \"Download failed\",\n                filename=self._alt_filename\n            )\n        )\n</code></pre>"},{"location":"api/#ktoolbox.enum","title":"<code>enum</code>","text":""},{"location":"api/#ktoolbox.enum.__all__","title":"<code>__all__ = ['TextEnum', 'RetCodeEnum', 'PostFileTypeEnum', 'DataStorageNameEnum']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.DataStorageNameEnum","title":"<code>DataStorageNameEnum</code>","text":"<p>             Bases: <code>Enum</code></p> <p>File names for saving KToolBox data files</p> Source code in <code>ktoolbox/enum.py</code> <pre><code>class DataStorageNameEnum(Enum):\n    \"\"\"File names for saving KToolBox data files\"\"\"\n    PostData = \"post.json\"\n    CreatorIndicesData = \"creator-indices.ktoolbox\"\n    JobListData = \"job-list.ktoolbox\"\n    LogData = \"ktoolbox.log\"\n</code></pre>"},{"location":"api/#ktoolbox.enum.DataStorageNameEnum.CreatorIndicesData","title":"<code>CreatorIndicesData = 'creator-indices.ktoolbox'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.DataStorageNameEnum.JobListData","title":"<code>JobListData = 'job-list.ktoolbox'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.DataStorageNameEnum.LogData","title":"<code>LogData = 'ktoolbox.log'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.DataStorageNameEnum.PostData","title":"<code>PostData = 'post.json'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.PostFileTypeEnum","title":"<code>PostFileTypeEnum</code>","text":"<p>             Bases: <code>Enum</code></p> <p>File types of Kemono post files</p> Source code in <code>ktoolbox/enum.py</code> <pre><code>class PostFileTypeEnum(Enum):\n    # noinspection SpellCheckingInspection\n    \"\"\"File types of Kemono post files\"\"\"\n    Attachment = \"attachment\"\n    File = \"file\"\n</code></pre>"},{"location":"api/#ktoolbox.enum.PostFileTypeEnum.Attachment","title":"<code>Attachment = 'attachment'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.PostFileTypeEnum.File","title":"<code>File = 'file'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.RetCodeEnum","title":"<code>RetCodeEnum</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>Enum for <code>BaseRet.code</code></p> Source code in <code>ktoolbox/enum.py</code> <pre><code>class RetCodeEnum(IntEnum):\n    \"\"\"Enum for ``BaseRet.code``\"\"\"\n    Success = 0\n    GeneralFailure = -1\n\n    # APIRet\n    NetWorkError = 1001\n    JsonDecodeError = 1002\n    ValidationError = 1003\n\n    # ActionRet\n    MissingParameter = 2001\n\n    # DownloaderRet\n    FileExisted = 3001\n</code></pre>"},{"location":"api/#ktoolbox.enum.RetCodeEnum.FileExisted","title":"<code>FileExisted = 3001</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.RetCodeEnum.GeneralFailure","title":"<code>GeneralFailure = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.RetCodeEnum.JsonDecodeError","title":"<code>JsonDecodeError = 1002</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.RetCodeEnum.MissingParameter","title":"<code>MissingParameter = 2001</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.RetCodeEnum.NetWorkError","title":"<code>NetWorkError = 1001</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.RetCodeEnum.Success","title":"<code>Success = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.RetCodeEnum.ValidationError","title":"<code>ValidationError = 1003</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.TextEnum","title":"<code>TextEnum</code>","text":"<p>             Bases: <code>Enum</code></p> Source code in <code>ktoolbox/enum.py</code> <pre><code>class TextEnum(Enum):\n    SearchResultEmpty = str(None)\n    MissingParams = \"Required parameters are missing\"\n</code></pre>"},{"location":"api/#ktoolbox.enum.TextEnum.MissingParams","title":"<code>MissingParams = 'Required parameters are missing'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.enum.TextEnum.SearchResultEmpty","title":"<code>SearchResultEmpty = str(None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.job","title":"<code>job</code>","text":""},{"location":"api/#ktoolbox.job.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.job.model.__all__","title":"<code>__all__ = ['Job', 'JobListData', 'CreatorIndices']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.job.model.CreatorIndices","title":"<code>CreatorIndices</code>","text":"<p>             Bases: <code>BaseKToolBoxData</code></p> <p>Creator directory indices model</p> <p>Record the path of each downloaded post.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class CreatorIndices(BaseKToolBoxData):\n    \"\"\"\n    Creator directory indices model\n\n    Record the path of each downloaded post.\n    \"\"\"\n    creator_id: str\n    \"\"\"Creator ID\"\"\"\n    service: str\n    \"\"\"Creator service\"\"\"\n    posts: Dict[str, Post] = {}\n    \"\"\"All posts, ``id`` -&gt; ``Post``\"\"\"\n    posts_path: Dict[str, Path] = {}\n    \"\"\"Posts and their path, ``id`` -&gt; ``Path``\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.creator_id","title":"<code>creator_id: str</code>  <code>instance-attribute</code>","text":"<p>Creator ID</p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.posts","title":"<code>posts: Dict[str, Post] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All posts, <code>id</code> -&gt; <code>Post</code></p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.posts_path","title":"<code>posts_path: Dict[str, Path] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Posts and their path, <code>id</code> -&gt; <code>Path</code></p>"},{"location":"api/#ktoolbox.job.model.CreatorIndices.service","title":"<code>service: str</code>  <code>instance-attribute</code>","text":"<p>Creator service</p>"},{"location":"api/#ktoolbox.job.model.Job","title":"<code>Job</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Download job model</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class Job(BaseModel):\n    \"\"\"\n    Download job model\n    \"\"\"\n    path: Path\n    \"\"\"Directory path to save the file\"\"\"\n    alt_filename: Optional[str] = None\n    \"\"\"Use this name if no filename given by the server\"\"\"\n    server_path: str\n    \"\"\"The `path` part of download URL\"\"\"\n    type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None\n    \"\"\"Target file type\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.Job.alt_filename","title":"<code>alt_filename: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use this name if no filename given by the server</p>"},{"location":"api/#ktoolbox.job.model.Job.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":"<p>Directory path to save the file</p>"},{"location":"api/#ktoolbox.job.model.Job.server_path","title":"<code>server_path: str</code>  <code>instance-attribute</code>","text":"<p>The <code>path</code> part of download URL</p>"},{"location":"api/#ktoolbox.job.model.Job.type","title":"<code>type: Optional[Literal[PostFileTypeEnum.Attachment, PostFileTypeEnum.File]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target file type</p>"},{"location":"api/#ktoolbox.job.model.JobListData","title":"<code>JobListData</code>","text":"<p>             Bases: <code>BaseKToolBoxData</code></p> <p>Download job list data model</p> <p>For saving the list of jobs to disk.</p> Source code in <code>ktoolbox/job/model.py</code> <pre><code>class JobListData(BaseKToolBoxData):\n    \"\"\"\n    Download job list data model\n\n    For saving the list of jobs to disk.\n    \"\"\"\n    jobs: List[Job] = []\n    \"\"\"All jobs\"\"\"\n</code></pre>"},{"location":"api/#ktoolbox.job.model.JobListData.jobs","title":"<code>jobs: List[Job] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All jobs</p>"},{"location":"api/#ktoolbox.job.runner","title":"<code>runner</code>","text":""},{"location":"api/#ktoolbox.job.runner.__all__","title":"<code>__all__ = ['JobRunner']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.job.runner.JobRunner","title":"<code>JobRunner</code>","text":"Source code in <code>ktoolbox/job/runner.py</code> <pre><code>class JobRunner:\n    def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True):\n        \"\"\"\n        Create a job runner\n\n        :param job_list: Jobs to initial ``self._job_queue``\n        :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n        :param progress: Show progress bar\n        \"\"\"\n        job_list = job_list or []\n        self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n        for job in job_list:\n            self._job_queue.put_nowait(job)\n        self._tqdm_class = tqdm_class\n        self._progress = progress\n        self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n        self._concurrent_tasks: Set[asyncio.Task] = set()\n        self._lock = asyncio.Lock()\n\n    @property\n    def finished(self):\n        \"\"\"\n        Check if all jobs finished\n\n        :return: ``False`` if **in process**, ``False`` otherwise\n        \"\"\"\n        return not self._lock.locked()\n\n    @cached_property\n    def downloaders(self):\n        \"\"\"Get downloaders with task\"\"\"\n        return MappingProxyType(self._downloaders_with_task)\n\n    @property\n    def waiting_size(self) -&gt; int:\n        \"\"\"Get the number of jobs waiting to be processed\"\"\"\n        return self._job_queue.qsize()\n\n    @property\n    def done_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that done\"\"\"\n        size = 0\n        for downloader, task in self._downloaders_with_task.items():\n            if downloader.finished or task.done():\n                size += 1\n        return size\n\n    @property\n    def processing_size(self) -&gt; int:\n        \"\"\"Get the number of jobs that in process\"\"\"\n        return len(self._downloaders_with_task) - self.done_size\n\n    async def processor(self) -&gt; int:\n        \"\"\"Process each job in ``self._job_queue``\"\"\"\n        failed_num = 0\n        while not self._job_queue.empty():\n            job = await self._job_queue.get()\n\n            # Create downloader\n            url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n            url = urlunparse(url_parts)\n            downloader = Downloader(\n                url=url,\n                path=job.path,\n                alt_filename=job.alt_filename\n            )\n\n            # Create task\n            task = asyncio.create_task(\n                downloader.run(\n                    tqdm_class=self._tqdm_class,\n                    progress=self._progress\n                )\n            )\n            self._downloaders_with_task[downloader] = task\n            # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n            #   Delete this for counting finished job tasks\n\n            # Run task\n            task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n            task_done = task_done_set.pop()\n            try:\n                exception = task_done.exception()\n            except CancelledError as e:\n                exception = e\n            if not exception:  # raise Exception when cancelled or other exceptions\n                ret = task_done.result()\n                if ret.code == RetCodeEnum.Success:\n                    logger.success(\n                        generate_msg(\n                            \"Download success\",\n                            filename=ret.data\n                        )\n                    )\n                elif ret.code == RetCodeEnum.FileExisted:\n                    logger.warning(ret.message)\n                else:\n                    logger.error(ret.message)\n                    failed_num += 1\n            elif isinstance(exception, CancelledError):\n                logger.warning(\n                    generate_msg(\n                        \"Download cancelled\",\n                        filename=job.alt_filename\n                    )\n                )\n            else:\n                logger.error(\n                    generate_msg(\n                        \"Download failed\",\n                        filename=job.alt_filename,\n                        exception=exception\n                    )\n                )\n                failed_num += 1\n            self._job_queue.task_done()\n        await self._job_queue.join()\n        return failed_num\n\n    async def start(self):\n        \"\"\"\n        Start processing jobs concurrently\n\n        It will **Block** until other call of ``self.start()`` method finished\n        \"\"\"\n        failed_num = 0\n        async with self._lock:\n            self._concurrent_tasks.clear()\n            for _ in range(config.job.count):\n                task = asyncio.create_task(self.processor())\n                self._concurrent_tasks.add(task)\n                task.add_done_callback(self._concurrent_tasks.discard)\n            task_done_set, _ = await asyncio.wait(self._concurrent_tasks)\n            for task in task_done_set:\n                try:\n                    failed_num += task.result()\n                except CancelledError:\n                    pass\n        if failed_num:\n            logger.warning(generate_msg(f\"{failed_num} jobs failed, download finished\"))\n        else:\n            logger.success(generate_msg(\"All jobs in queue finished\"))\n\n    async def add_jobs(self, *jobs: Job):\n        \"\"\"Add jobs to ``self._job_queue``\"\"\"\n        for job in jobs:\n            await self._job_queue.put(job)\n\n    @staticmethod\n    async def _force_cancel(target: asyncio.Task, wait_time: float = None) -&gt; bool:\n        \"\"\"\n        Force cancel ``asyncio.Task`` after ``wait_time`` seconds\n\n        :param target: Target task\n        :param wait_time: Seconds to wait before cancel (``0`` for skip one event loop run cycle)\n        :return: Whether cancelled successfully\n        \"\"\"\n        if wait_time is not None:\n            await asyncio.sleep(wait_time)\n        return target.cancel()\n\n    async def cancel_downloader(self, target: Downloader) -&gt; bool:\n        \"\"\"\n        Cancel downloader\n\n        :return: Whether cancelled successfully\n        \"\"\"\n        task = self._downloaders_with_task[target]\n        if not task.done():\n            target.cancel()\n            return await self._force_cancel(task, 0) or task.done()\n        return True\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.done_size","title":"<code>done_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that done</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.downloaders","title":"<code>downloaders</code>  <code>cached</code> <code>property</code>","text":"<p>Get downloaders with task</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.finished","title":"<code>finished</code>  <code>property</code>","text":"<p>Check if all jobs finished</p> <p>Returns:</p> Type Description <p><code>False</code> if in process, <code>False</code> otherwise</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.processing_size","title":"<code>processing_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs that in process</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.waiting_size","title":"<code>waiting_size: int</code>  <code>property</code>","text":"<p>Get the number of jobs waiting to be processed</p>"},{"location":"api/#ktoolbox.job.runner.JobRunner.__init__","title":"<code>__init__(*, job_list=None, tqdm_class=None, progress=True)</code>","text":"<p>Create a job runner</p> <p>Parameters:</p> Name Type Description Default <code>job_list</code> <code>List[Job]</code> <p>Jobs to initial <code>self._job_queue</code></p> <code>None</code> <code>tqdm_class</code> <code>tqdm</code> <p><code>tqdm</code> class to replace default <code>tqdm.asyncio.tqdm</code></p> <code>None</code> <code>progress</code> <code>bool</code> <p>Show progress bar</p> <code>True</code> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>def __init__(self, *, job_list: List[Job] = None, tqdm_class: std_tqdm = None, progress: bool = True):\n    \"\"\"\n    Create a job runner\n\n    :param job_list: Jobs to initial ``self._job_queue``\n    :param tqdm_class: ``tqdm`` class to replace default ``tqdm.asyncio.tqdm``\n    :param progress: Show progress bar\n    \"\"\"\n    job_list = job_list or []\n    self._job_queue: asyncio.Queue[Job] = asyncio.Queue()\n    for job in job_list:\n        self._job_queue.put_nowait(job)\n    self._tqdm_class = tqdm_class\n    self._progress = progress\n    self._downloaders_with_task: Dict[Downloader, asyncio.Task] = {}\n    self._concurrent_tasks: Set[asyncio.Task] = set()\n    self._lock = asyncio.Lock()\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.add_jobs","title":"<code>add_jobs(*jobs)</code>  <code>async</code>","text":"<p>Add jobs to <code>self._job_queue</code></p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def add_jobs(self, *jobs: Job):\n    \"\"\"Add jobs to ``self._job_queue``\"\"\"\n    for job in jobs:\n        await self._job_queue.put(job)\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.cancel_downloader","title":"<code>cancel_downloader(target)</code>  <code>async</code>","text":"<p>Cancel downloader</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether cancelled successfully</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def cancel_downloader(self, target: Downloader) -&gt; bool:\n    \"\"\"\n    Cancel downloader\n\n    :return: Whether cancelled successfully\n    \"\"\"\n    task = self._downloaders_with_task[target]\n    if not task.done():\n        target.cancel()\n        return await self._force_cancel(task, 0) or task.done()\n    return True\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.processor","title":"<code>processor()</code>  <code>async</code>","text":"<p>Process each job in <code>self._job_queue</code></p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def processor(self) -&gt; int:\n    \"\"\"Process each job in ``self._job_queue``\"\"\"\n    failed_num = 0\n    while not self._job_queue.empty():\n        job = await self._job_queue.get()\n\n        # Create downloader\n        url_parts = [config.downloader.scheme, config.api.files_netloc, job.server_path, '', '', '']\n        url = urlunparse(url_parts)\n        downloader = Downloader(\n            url=url,\n            path=job.path,\n            alt_filename=job.alt_filename\n        )\n\n        # Create task\n        task = asyncio.create_task(\n            downloader.run(\n                tqdm_class=self._tqdm_class,\n                progress=self._progress\n            )\n        )\n        self._downloaders_with_task[downloader] = task\n        # task.add_done_callback(lambda _: self._downloaders_with_task.pop(downloader))\n        #   Delete this for counting finished job tasks\n\n        # Run task\n        task_done_set, _ = await asyncio.wait([task], return_when=asyncio.FIRST_EXCEPTION)\n        task_done = task_done_set.pop()\n        try:\n            exception = task_done.exception()\n        except CancelledError as e:\n            exception = e\n        if not exception:  # raise Exception when cancelled or other exceptions\n            ret = task_done.result()\n            if ret.code == RetCodeEnum.Success:\n                logger.success(\n                    generate_msg(\n                        \"Download success\",\n                        filename=ret.data\n                    )\n                )\n            elif ret.code == RetCodeEnum.FileExisted:\n                logger.warning(ret.message)\n            else:\n                logger.error(ret.message)\n                failed_num += 1\n        elif isinstance(exception, CancelledError):\n            logger.warning(\n                generate_msg(\n                    \"Download cancelled\",\n                    filename=job.alt_filename\n                )\n            )\n        else:\n            logger.error(\n                generate_msg(\n                    \"Download failed\",\n                    filename=job.alt_filename,\n                    exception=exception\n                )\n            )\n            failed_num += 1\n        self._job_queue.task_done()\n    await self._job_queue.join()\n    return failed_num\n</code></pre>"},{"location":"api/#ktoolbox.job.runner.JobRunner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start processing jobs concurrently</p> <p>It will Block until other call of <code>self.start()</code> method finished</p> Source code in <code>ktoolbox/job/runner.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Start processing jobs concurrently\n\n    It will **Block** until other call of ``self.start()`` method finished\n    \"\"\"\n    failed_num = 0\n    async with self._lock:\n        self._concurrent_tasks.clear()\n        for _ in range(config.job.count):\n            task = asyncio.create_task(self.processor())\n            self._concurrent_tasks.add(task)\n            task.add_done_callback(self._concurrent_tasks.discard)\n        task_done_set, _ = await asyncio.wait(self._concurrent_tasks)\n        for task in task_done_set:\n            try:\n                failed_num += task.result()\n            except CancelledError:\n                pass\n    if failed_num:\n        logger.warning(generate_msg(f\"{failed_num} jobs failed, download finished\"))\n    else:\n        logger.success(generate_msg(\"All jobs in queue finished\"))\n</code></pre>"},{"location":"api/#ktoolbox.model","title":"<code>model</code>","text":""},{"location":"api/#ktoolbox.model.__all__","title":"<code>__all__ = ['BaseKToolBoxData', 'SearchResult']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData","title":"<code>BaseKToolBoxData</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base class for all KToolBox data models.</p> Source code in <code>ktoolbox/model.py</code> <pre><code>class BaseKToolBoxData(BaseModel):\n    \"\"\"\n    Base class for all KToolBox data models.\n    \"\"\"\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        self.type = type(self)\n\n    version: str = __version__\n    type: Union[Type[\"BaseKToolBoxData\"], str] = None\n\n    @field_serializer('type')\n    def _(self, value: Type[\"BaseKToolBoxData\"], _info):\n        return str(value)\n</code></pre>"},{"location":"api/#ktoolbox.model.BaseKToolBoxData.type","title":"<code>type: Union[Type[BaseKToolBoxData], str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData.version","title":"<code>version: str = __version__</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.model.BaseKToolBoxData._","title":"<code>_(value, _info)</code>","text":"Source code in <code>ktoolbox/model.py</code> <pre><code>@field_serializer('type')\ndef _(self, value: Type[\"BaseKToolBoxData\"], _info):\n    return str(value)\n</code></pre>"},{"location":"api/#ktoolbox.model.BaseKToolBoxData.__init__","title":"<code>__init__(**data)</code>","text":"Source code in <code>ktoolbox/model.py</code> <pre><code>def __init__(self, **data: Any):\n    super().__init__(**data)\n    self.type = type(self)\n</code></pre>"},{"location":"api/#ktoolbox.model.SearchResult","title":"<code>SearchResult</code>","text":"<p>             Bases: <code>BaseKToolBoxData</code>, <code>Generic[_T]</code></p> <p>Cli search result</p> Source code in <code>ktoolbox/model.py</code> <pre><code>class SearchResult(BaseKToolBoxData, Generic[_T]):\n    \"\"\"Cli search result\"\"\"\n    result: List[_T] = []\n</code></pre>"},{"location":"api/#ktoolbox.model.SearchResult.result","title":"<code>result: List[_T] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils","title":"<code>utils</code>","text":""},{"location":"api/#ktoolbox.utils.__all__","title":"<code>__all__ = ['BaseRet', 'filename_from_headers', 'generate_msg', 'logger_init', 'dump_search', 'parse_webpage_url', 'uvloop_init']</code>  <code>module-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet","title":"<code>BaseRet</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[_T]</code></p> <p>Base data model of function return value</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>class BaseRet(BaseModel, Generic[_T]):\n    \"\"\"Base data model of function return value\"\"\"\n    code: int = RetCodeEnum.Success.value\n    message: str = ''\n    exception: Optional[Exception] = None\n    data: Optional[_T] = None\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __bool__(self):\n        return self.code == RetCodeEnum.Success\n</code></pre>"},{"location":"api/#ktoolbox.utils.BaseRet.code","title":"<code>code: int = RetCodeEnum.Success.value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.data","title":"<code>data: Optional[_T] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.exception","title":"<code>exception: Optional[Exception] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.message","title":"<code>message: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#ktoolbox.utils.BaseRet.__bool__","title":"<code>__bool__()</code>","text":"Source code in <code>ktoolbox/utils.py</code> <pre><code>def __bool__(self):\n    return self.code == RetCodeEnum.Success\n</code></pre>"},{"location":"api/#ktoolbox.utils.dump_search","title":"<code>dump_search(result, path)</code>  <code>async</code>","text":"Source code in <code>ktoolbox/utils.py</code> <pre><code>async def dump_search(result: List[BaseModel], path: Path):\n    async with aiofiles.open(str(path), \"w\", encoding=\"utf-8\") as f:\n        await f.write(\n            SearchResult(result=result)\n            .model_dump_json(indent=config.json_dump_indent)\n        )\n</code></pre>"},{"location":"api/#ktoolbox.utils.filename_from_headers","title":"<code>filename_from_headers(headers)</code>","text":"<p>Get file name from headers.</p> <p>Parse from <code>Content-Disposition</code>.</p> <ul> <li> <p>Example: <pre><code>filename_from_headers('attachment;filename*=utf-8\\'\\'README%2Emd;filename=\"README.md\"')\n</code></pre></p> </li> <li> <p>Return: <pre><code>README.md\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP headers</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>File name</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def filename_from_headers(headers: Dict[str, str]) -&gt; Optional[str]:\n    \"\"\"\n    Get file name from headers.\n\n    Parse from ``Content-Disposition``.\n\n    - Example:\n    ```\n    filename_from_headers('attachment;filename*=utf-8\\\\'\\\\'README%2Emd;filename=\"README.md\"')\n    ```\n\n    - Return:\n    ```\n    README.md\n    ```\n\n    :param headers: HTTP headers\n    :return: File name\n    \"\"\"\n    if not (disposition := headers.get(\"Content-Disposition\")):\n        if not (disposition := headers.get(\"content-disposition\")):\n            return None\n    _, options = cgi.parse_header(disposition)  # alternative: `parse_header` in `utils.py`\n    if filename := options.get(\"filename*\"):\n        if len(name_with_charset := filename.split(\"''\")) == 2:\n            charset, name = name_with_charset\n            return urllib.parse.unquote(name, charset)\n    if filename := options.get(\"filename\"):\n        return urllib.parse.unquote(filename, config.downloader.encoding)\n    return None\n</code></pre>"},{"location":"api/#ktoolbox.utils.generate_msg","title":"<code>generate_msg(title=None, **kwargs)</code>","text":"<p>Generate message for <code>BaseRet</code> and logger</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Message title</p> <code>None</code> <code>kwargs</code> <p>Extra data</p> <code>{}</code> Source code in <code>ktoolbox/utils.py</code> <pre><code>def generate_msg(title: str = None, **kwargs):\n    \"\"\"\n    Generate message for ``BaseRet`` and logger\n\n    :param title: Message title\n    :param kwargs: Extra data\n    \"\"\"\n    title: str = title or \"\"\n    return f\"{title} - {kwargs}\" if kwargs else title\n</code></pre>"},{"location":"api/#ktoolbox.utils.logger_init","title":"<code>logger_init(cli_use=False, disable_stdout=False)</code>","text":"<p>Initialize <code>loguru</code> logger</p> <p>Parameters:</p> Name Type Description Default <code>cli_use</code> <code>bool</code> <p>Set logger level <code>INFO</code> and filter out <code>SUCCESS</code></p> <code>False</code> <code>disable_stdout</code> <code>bool</code> <p>Disable default output stream</p> <code>False</code> Source code in <code>ktoolbox/utils.py</code> <pre><code>def logger_init(cli_use: bool = False, disable_stdout: bool = False):\n    \"\"\"\n    Initialize ``loguru`` logger\n\n    :param cli_use: Set logger level ``INFO`` and filter out ``SUCCESS``\n    :param disable_stdout: Disable default output stream\n    \"\"\"\n    if disable_stdout:\n        logger.remove()\n    elif cli_use:\n        logger.remove()\n        logger.add(\n            sys.stderr,\n            level=logging.INFO,\n            filter=lambda record: record[\"level\"].name != \"SUCCESS\"\n        )\n    if path := config.logger.path:\n        path.mkdir(exist_ok=True)\n        if path is not None:\n            logger.add(\n                path / DataStorageNameEnum.LogData.value,\n                level=config.logger.level,\n                rotation=config.logger.rotation,\n                diagnose=True\n            )\n</code></pre>"},{"location":"api/#ktoolbox.utils.parse_header","title":"<code>parse_header(line)</code>","text":"<p>Alternative resolution for parsing header line.</p> <p>Apply when <code>cgi.parse_header</code> is unable to use due to the deprecation of <code>cgi</code> module.</p> <p>https://peps.python.org/pep-0594/#cgi</p> <ul> <li> <p>Example: <pre><code>parse_header(\"text/html; charset=utf-8\")\n</code></pre></p> </li> <li> <p>Return: <pre><code>{'text/html': None, 'charset': 'utf-8'}\n</code></pre></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Header line</p> required <p>Returns:</p> Type Description <code>Dict[str, Optional[str]]</code> <p>Dict of header line</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def parse_header(line: str) -&gt; Dict[str, Optional[str]]:\n    \"\"\"\n    Alternative resolution for parsing header line.\n\n    Apply when ``cgi.parse_header`` is unable to use due to the deprecation of `cgi` module.\n\n    https://peps.python.org/pep-0594/#cgi\n\n    - Example:\n    ```\n    parse_header(\"text/html; charset=utf-8\")\n    ```\n\n    - Return:\n    ```\n    {'text/html': None, 'charset': 'utf-8'}\n    ```\n\n    :param line: Header line\n    :return: Dict of header line\n    \"\"\"\n    dict_value: Dict[str, Optional[str]] = {}\n    for item in line.split(\";\"):\n        if len(pair := item.split(\"=\")) == 1:\n            dict_value[pair[0]] = None\n        else:\n            dict_value.setdefault(*pair)\n    return dict_value\n</code></pre>"},{"location":"api/#ktoolbox.utils.parse_webpage_url","title":"<code>parse_webpage_url(url)</code>","text":"<p>Fetch service, user_id, post_id from webpage url</p> <p>Each part can be <code>None</code> if not found in url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Kemono Webpage url</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str], Optional[str]]</code> <p>Tuple of service, user_id, post_id</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def parse_webpage_url(url: str) -&gt; Tuple[Optional[str], Optional[str], Optional[str]]:\n    # noinspection SpellCheckingInspection\n    \"\"\"\n    Fetch **service**, **user_id**, **post_id** from webpage url\n\n    Each part can be ``None`` if not found in url.\n\n    :param url: Kemono Webpage url\n    :return: Tuple of **service**, **user_id**, **post_id**\n    \"\"\"\n    path_url = Path(url)\n    parts = path_url.parts\n    if (url_parts_len := len(parts)) &lt; 7:\n        # Pad to full size\n        parts += tuple(None for _ in range(7 - url_parts_len))\n    _scheme, _netloc, service, _user_key, user_id, _post_key, post_id = parts\n    return service, user_id, post_id\n</code></pre>"},{"location":"api/#ktoolbox.utils.uvloop_init","title":"<code>uvloop_init()</code>","text":"<p>Set event loop policy to uvloop if available.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If uvloop enabled successfully</p> Source code in <code>ktoolbox/utils.py</code> <pre><code>def uvloop_init() -&gt; bool:\n    \"\"\"\n    Set event loop policy to uvloop if available.\n\n    :return: If uvloop enabled successfully\n    \"\"\"\n    if config.use_uvloop:\n        if sys.platform == \"win32\":\n            logger.info(\"uvloop is not supported on Windows, but it's optional.\")\n        else:\n            try:\n                # noinspection PyUnresolvedReferences\n                import uvloop\n            except ModuleNotFoundError:\n                logger.info(\n                    \"uvloop is not installed, but it's optional. \"\n                    \"You can install it with `pip install ktoolbox[uvloop]`\"\n                )\n            else:\n                asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n                logger.success(\"Set event loop policy to uvloop successfully.\")\n                return True\n    return False\n</code></pre>"},{"location":"commands/","title":"Commands","text":"<p>Usage</p> <p>Visit Command</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>class KToolBoxCli:\n    @staticmethod\n    async def version():\n        \"\"\"Show KToolBox version\"\"\"\n        return __version__\n\n    @staticmethod\n    async def site_version():\n        # noinspection SpellCheckingInspection\n        \"\"\"Show current Kemono site app commit hash\"\"\"\n        ret = await get_app_version()\n        return ret.data if ret else ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator(\n            name: str = None,\n            id: str = None,\n            service: str = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await search_creator_action(id=id, name=name, service=service)\n        if ret:\n            result_list = list(ret.data)\n            if dump:\n                await dump_search(result_list, dump)\n            return result_list or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator_post(\n            id: str = None,\n            name: str = None,\n            service: str = None,\n            q: str = None,\n            o: int = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search posts from creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n        if ret:\n            if dump:\n                await dump_search(ret.data, dump)\n            return ret.data or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    @staticmethod\n    async def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n        \"\"\"\n        Get a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            if dump:\n                async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                    await f.write(\n                        ret.data.model_dump_json(indent=config.json_dump_indent)\n                    )\n            return ret.data\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def download_post(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def download_post(\n            service: str,\n            creator_id: str,\n            post_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    async def download_post(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            post_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        \"\"\"\n        Download a specific post\n\n        :param url: The post URL\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param path: Download path, default is current directory\n        :param dump_post_data: Whether to dump post data (post.json) in post directory\n        \"\"\"\n        # Get service, creator_id, post_id\n        if url:\n            service, creator_id, post_id = parse_webpage_url(url)\n        if not all([service, creator_id, post_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\", \"post_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            post_path = path / ret.data.id if config.job.post_id_as_path else path / sanitize_filename(ret.data.title)\n            job_list = await create_job_from_post(\n                post=ret.data,\n                post_path=post_path,\n                dump_post_data=dump_post_data\n            )\n            job_runner = JobRunner(job_list=job_list)\n            await job_runner.start()\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Path = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            service: str,\n            creator_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Path = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        ...\n\n    @staticmethod\n    async def sync_creator(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Union[Path, str] = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        \"\"\"\n        Sync all posts from a creator\n\n        You can update the directory anytime after download finished, \\\n        such as to update after creator published new posts.\n\n        * If ``update_from`` was provided, it should be located **inside the creator directory**.\n\n        :param url: The post URL\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param path: Download path, default is current directory\n        :param update_from: ``CreatorIndices`` data path for update posts from current creator directory, \\\n         ``save_creator_indices`` will be enabled if this provided\n        :param save_creator_indices: Record ``CreatorIndices`` data for update posts from current creator directory\n        :param mix_posts: Save all files from different posts at same path, \\\n         ``update_from``, ``save_creator_indices`` will be ignored if enabled\n        \"\"\"\n        # Get service, creator_id\n        if url:\n            service, creator_id, _ = parse_webpage_url(url)\n        if not all([service, creator_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        if update_from:\n            update_from = update_from if isinstance(update_from, Path) else Path(update_from)\n\n        # Get ``CreatorIndices`` data\n        if update_from:\n            async with aiofiles.open(update_from, encoding=\"utf-8\") as f:\n                indices_text = await f.read()\n            indices = CreatorIndices.model_validate_json(indices_text)\n            creator_path = update_from.parent\n        else:\n            indices = None\n\n            # Get creator name\n            creator_name = creator_id\n            creator_ret = await search_creator_action(id=creator_id, service=service)\n            if creator_ret:\n                creator = next(creator_ret.data, None)\n                if creator:\n                    creator_name = creator.name\n                    logger.info(\n                        generate_msg(\n                            \"Got creator information\",\n                            name=creator.name,\n                            id=creator.id\n                        )\n                    )\n            else:\n                logger.warning(\n                    generate_msg(\n                        f\"Failed to fetch the name of creator &lt;{creator_id}&gt;, use creator ID as directory name\",\n                        detail=creator_ret.message\n                    )\n                )\n            creator_path = path / sanitize_filename(creator_name)\n\n        creator_path.mkdir(exist_ok=True)\n        ret = await create_job_from_creator(\n            service=service,\n            creator_id=creator_id,\n            path=creator_path,\n            update_from=indices,\n            all_pages=True,\n            save_creator_indices=save_creator_indices,\n            mix_posts=mix_posts\n        )\n        if ret:\n            job_runner = JobRunner(job_list=ret.data)\n            await job_runner.start()\n        else:\n            return ret.message\n</code></pre>"},{"location":"commands/#ktoolbox.cli.KToolBoxCli.download_post","title":"<code>download_post</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Download a specific post</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service name</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The creator's ID</p> <code>None</code> <code>post_id</code> <code>str</code> <p>The post ID</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>dump_post_data</code> <p>Whether to dump post data (post.json) in post directory</p> <code>True</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def download_post(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        post_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        dump_post_data=True\n):\n    \"\"\"\n    Download a specific post\n\n    :param url: The post URL\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param path: Download path, default is current directory\n    :param dump_post_data: Whether to dump post data (post.json) in post directory\n    \"\"\"\n    # Get service, creator_id, post_id\n    if url:\n        service, creator_id, post_id = parse_webpage_url(url)\n    if not all([service, creator_id, post_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\", \"post_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        post_path = path / ret.data.id if config.job.post_id_as_path else path / sanitize_filename(ret.data.title)\n        job_list = await create_job_from_post(\n            post=ret.data,\n            post_path=post_path,\n            dump_post_data=dump_post_data\n        )\n        job_runner = JobRunner(job_list=job_list)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/#ktoolbox.cli.KToolBoxCli.get_post","title":"<code>get_post</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Get a specific post</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The service name</p> required <code>creator_id</code> <code>str</code> <p>The creator's ID</p> required <code>post_id</code> <code>str</code> <p>The post ID</p> required <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n    \"\"\"\n    Get a specific post\n\n    :param service: The service name\n    :param creator_id: The creator's ID\n    :param post_id: The post ID\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    ret = await get_post_api(\n        service=service,\n        creator_id=creator_id,\n        post_id=post_id\n    )\n    if ret:\n        if dump:\n            async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                await f.write(\n                    ret.data.model_dump_json(indent=config.json_dump_indent)\n                )\n        return ret.data\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/#ktoolbox.cli.KToolBoxCli.search_creator","title":"<code>search_creator</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator(\n        name: str = None,\n        id: str = None,\n        service: str = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    ret = await search_creator_action(id=id, name=name, service=service)\n    if ret:\n        result_list = list(ret.data)\n        if dump:\n            await dump_search(result_list, dump)\n        return result_list or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/#ktoolbox.cli.KToolBoxCli.search_creator_post","title":"<code>search_creator_post</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Search posts from creator, you can use multiple parameters as keywords.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the creator</p> <code>None</code> <code>service</code> <code>str</code> <p>The service for the creator</p> <code>None</code> <code>q</code> <code>str</code> <p>Search query</p> <code>None</code> <code>o</code> <code>int</code> <p>Result offset, stepping of 50 is enforced</p> <code>None</code> <code>dump</code> <code>Path</code> <p>Dump the result to a JSON file</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def search_creator_post(\n        id: str = None,\n        name: str = None,\n        service: str = None,\n        q: str = None,\n        o: int = None,\n        *,\n        dump: Path = None\n):\n    \"\"\"\n    Search posts from creator, you can use multiple parameters as keywords.\n\n    :param id: The ID of the creator\n    :param name: The name of the creator\n    :param service: The service for the creator\n    :param q: Search query\n    :param o: Result offset, stepping of 50 is enforced\n    :param dump: Dump the result to a JSON file\n    \"\"\"\n    ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n    if ret:\n        if dump:\n            await dump_search(ret.data, dump)\n        return ret.data or TextEnum.SearchResultEmpty.value\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/#ktoolbox.cli.KToolBoxCli.site_version","title":"<code>site_version</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show current Kemono site app commit hash</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def site_version():\n    # noinspection SpellCheckingInspection\n    \"\"\"Show current Kemono site app commit hash\"\"\"\n    ret = await get_app_version()\n    return ret.data if ret else ret.message\n</code></pre>"},{"location":"commands/#ktoolbox.cli.KToolBoxCli.sync_creator","title":"<code>sync_creator</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Sync all posts from a creator</p> <p>You can update the directory anytime after download finished,         such as to update after creator published new posts.</p> <ul> <li>If <code>update_from</code> was provided, it should be located inside the creator directory.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The post URL</p> <code>None</code> <code>service</code> <code>str</code> <p>The service where the post is located</p> <code>None</code> <code>creator_id</code> <code>str</code> <p>The ID of the creator</p> <code>None</code> <code>path</code> <code>Union[Path, str]</code> <p>Download path, default is current directory</p> <code>Path('.')</code> <code>update_from</code> <code>Union[Path, str]</code> <p><code>CreatorIndices</code> data path for update posts from current creator directory,          <code>save_creator_indices</code> will be enabled if this provided</p> <code>None</code> <code>save_creator_indices</code> <code>bool</code> <p>Record <code>CreatorIndices</code> data for update posts from current creator directory</p> <code>True</code> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path,          <code>update_from</code>, <code>save_creator_indices</code> will be ignored if enabled</p> <code>None</code> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def sync_creator(\n        url: str = None,\n        service: str = None,\n        creator_id: str = None,\n        path: Union[Path, str] = Path(\".\"),\n        *,\n        update_from: Union[Path, str] = None,\n        save_creator_indices: bool = True,\n        mix_posts: bool = None\n):\n    \"\"\"\n    Sync all posts from a creator\n\n    You can update the directory anytime after download finished, \\\n    such as to update after creator published new posts.\n\n    * If ``update_from`` was provided, it should be located **inside the creator directory**.\n\n    :param url: The post URL\n    :param service: The service where the post is located\n    :param creator_id: The ID of the creator\n    :param path: Download path, default is current directory\n    :param update_from: ``CreatorIndices`` data path for update posts from current creator directory, \\\n     ``save_creator_indices`` will be enabled if this provided\n    :param save_creator_indices: Record ``CreatorIndices`` data for update posts from current creator directory\n    :param mix_posts: Save all files from different posts at same path, \\\n     ``update_from``, ``save_creator_indices`` will be ignored if enabled\n    \"\"\"\n    # Get service, creator_id\n    if url:\n        service, creator_id, _ = parse_webpage_url(url)\n    if not all([service, creator_id]):\n        return generate_msg(\n            TextEnum.MissingParams.value,\n            use_at_lease_one=[\n                [\"url\"],\n                [\"service\", \"creator_id\"]\n            ])\n\n    path = path if isinstance(path, Path) else Path(path)\n    if update_from:\n        update_from = update_from if isinstance(update_from, Path) else Path(update_from)\n\n    # Get ``CreatorIndices`` data\n    if update_from:\n        async with aiofiles.open(update_from, encoding=\"utf-8\") as f:\n            indices_text = await f.read()\n        indices = CreatorIndices.model_validate_json(indices_text)\n        creator_path = update_from.parent\n    else:\n        indices = None\n\n        # Get creator name\n        creator_name = creator_id\n        creator_ret = await search_creator_action(id=creator_id, service=service)\n        if creator_ret:\n            creator = next(creator_ret.data, None)\n            if creator:\n                creator_name = creator.name\n                logger.info(\n                    generate_msg(\n                        \"Got creator information\",\n                        name=creator.name,\n                        id=creator.id\n                    )\n                )\n        else:\n            logger.warning(\n                generate_msg(\n                    f\"Failed to fetch the name of creator &lt;{creator_id}&gt;, use creator ID as directory name\",\n                    detail=creator_ret.message\n                )\n            )\n        creator_path = path / sanitize_filename(creator_name)\n\n    creator_path.mkdir(exist_ok=True)\n    ret = await create_job_from_creator(\n        service=service,\n        creator_id=creator_id,\n        path=creator_path,\n        update_from=indices,\n        all_pages=True,\n        save_creator_indices=save_creator_indices,\n        mix_posts=mix_posts\n    )\n    if ret:\n        job_runner = JobRunner(job_list=ret.data)\n        await job_runner.start()\n    else:\n        return ret.message\n</code></pre>"},{"location":"commands/#ktoolbox.cli.KToolBoxCli.version","title":"<code>version</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Show KToolBox version</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>@staticmethod\nasync def version():\n    \"\"\"Show KToolBox version\"\"\"\n    return __version__\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-to-solve-the-failure-of-uvloop-installation","title":"How to solve the failure of uvloop installation?","text":"<p>It's optional</p> <p>uvloop can improve concurrent performance, but it's optional.  If you don't want to install uvloop, you can ignore this step.</p> <p>On Windows, uvloop is not supported. If you failed installing uvloop on Linux or macOS,  you can try to install it with system package manager like apt, yum or brew,  pacakge managers provide prebuilt wheels for uvloop.</p> <ul> <li>Install with apt     <pre><code>sudo apt install python3-uvloop\n</code></pre></li> </ul>"},{"location":"faq/#attachments-folder-inside-post-directory-is-no-need-for-me","title":"<code>attachments</code> folder inside post directory is no need for me","text":"<p>You can set configuration option <code>job.post_structure.attachments</code> to <code>./</code></p> <p>Set the configuration by <code>prod.env</code> dotenv file or system environment variables: <pre><code>KTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n</code></pre></p> <p><code>./</code> means attachments will be downloaded directly into the post directory.</p> <p>Notice</p> <p>For more information, please visit Configuration-Guide page.</p>"},{"location":"faq/#commands-and-flags-should-use-or-_-as-seperator","title":"Commands and flags should use <code>-</code> or <code>_</code> as seperator?","text":"<p>Both is support, <code>-</code> is suggested.</p>"},{"location":"more/","title":"More","text":""},{"location":"more/#other-branches","title":"Other Branches","text":"<ul> <li>Pure Python branch: \ud83d\udd17pure-py</li> </ul> <p>About</p> <ul> <li>Use pydantic v1 so that cargo is not needed for installation</li> <li>For example, you can use it on iOS terminal App a-Shell</li> <li>\ud83d\udd17PyPI</li> </ul> <ul> <li>Development branch: \ud83d\udd17devel</li> </ul>"},{"location":"more/#code-coverage","title":"Code Coverage","text":""},{"location":"more/#license","title":"License","text":"<p>KToolBox is licensed under MIT.</p> <p>Copyright \u00a9 2023 by Ljzd-PRO.</p>"},{"location":"shortcut/","title":"Shortcuts for iOS","text":"<p>You can run KToolBox using iOS terminal App a-Shell, and the following shortcuts  can help you automatically install KToolBox and download posts</p>"},{"location":"shortcut/#get-the-shortcuts","title":"Get the shortcuts","text":"<p>Visit shortcut URLs below or download shortcut files at <code>shortcuts/</code></p>"},{"location":"shortcut/#english","title":"English","text":"<ul> <li>KToolBox Manager</li> <li>Download Kemono Post</li> </ul>"},{"location":"shortcut/#chinese","title":"Chinese","text":"<ul> <li>KToolBox \u7ba1\u7406\u5668</li> <li>\u4e0b\u8f7d Kemono \u4f5c\u54c1</li> </ul>"},{"location":"shortcut/#usage","title":"Usage","text":"<ul> <li>Use \"KToolBox Manager\" to install, update, uninstall KToolBox in a-Shell</li> <li>You can trigger \"Download Kemono Post\" by web page share view, or run directly in Shortcuts App</li> </ul>"},{"location":"configuration/guide/","title":"Guide","text":"<ul> <li>KToolBox read <code>prod.env</code> file in the work folder or environment variables to store configuration</li> <li>Check Reference for all configuration options</li> <li>Use <code>__</code> to specify the sub option, like <code>KTOOLBOX_API__SCHEME</code> means <code>api.scheme</code></li> <li>All configuration options are optional</li> </ul>"},{"location":"configuration/guide/#prodenv-file-example","title":"<code>prod.env</code> file example","text":"<pre><code># Download 10 files at the same time.\nKTOOLBOX_JOB__COUNT=10\n\n# Allocate 102400 Bytes as buffer for each download job\nKTOOLBOX_DOWNLOADER__BUFFER_SIZE=102400\n\n# Set post attachments directory path as `./`, it means to save all attachments files in post directory\n# without making a new sub directory to storage them\nKTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n\n# Disable SSL certificate verification for Kemono API server and download server\n# It's useful when certificate on Kemono server expired. (SSL: CERTIFICATE_VERIFY_FAILED)\nKTOOLBOX_SSL_VERIFY=False\n</code></pre>"},{"location":"configuration/reference/","title":"Reference","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>KToolBox Configuration</p> <p>Attributes:</p> Name Type Description <code>api</code> <code>APIConfiguration</code> <code>downloader</code> <code>DownloaderConfiguration</code> <code>job</code> <code>JobConfiguration</code> <code>logger</code> <code>LoggerConfiguration</code> <code>ssl_verify</code> <code>bool</code> <p>Enable SSL certificate verification for Kemono API server and download server</p> <code>json_dump_indent</code> <code>int</code> <p>Indent of JSON file dump</p> <code>use_uvloop</code> <code>bool</code> <p>Use uvloop for asyncio (Disabled on Windows by default)     uvloop will improve concurrent performance, but it is not compatible with Windows.     Install uvloop by <code>pip install ktoolbox[uvloop]</code> or it will not work.</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class Configuration(BaseSettings):\n    # noinspection SpellCheckingInspection,GrazieInspection\n    \"\"\"\n    KToolBox Configuration\n\n    :ivar api:\n    :ivar downloader:\n    :ivar job:\n    :ivar logger:\n    :ivar ssl_verify: Enable SSL certificate verification for Kemono API server and download server\n    :ivar json_dump_indent: Indent of JSON file dump\n    :ivar use_uvloop: Use uvloop for asyncio (Disabled on Windows by default) \\\n    uvloop will improve concurrent performance, but it is not compatible with Windows. \\\n    Install uvloop by `pip install ktoolbox[uvloop]` or it will not work.\n    \"\"\"\n    api: APIConfiguration = APIConfiguration()\n    downloader: DownloaderConfiguration = DownloaderConfiguration()\n    job: JobConfiguration = JobConfiguration()\n    logger: LoggerConfiguration = LoggerConfiguration()\n\n    ssl_verify: bool = True\n    json_dump_indent: int = 4\n    use_uvloop: bool = True\n\n    # noinspection SpellCheckingInspection\n    model_config = SettingsConfigDict(\n        env_prefix='ktoolbox_',\n        env_nested_delimiter='__',\n        env_file='.env',\n        env_file_encoding='utf-8'\n    )\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.api","title":"<code>api: APIConfiguration = APIConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.downloader","title":"<code>downloader: DownloaderConfiguration = DownloaderConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.job","title":"<code>job: JobConfiguration = JobConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.logger","title":"<code>logger: LoggerConfiguration = LoggerConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.ssl_verify","title":"<code>ssl_verify: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.json_dump_indent","title":"<code>json_dump_indent: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.Configuration.use_uvloop","title":"<code>use_uvloop: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration","title":"<code>APIConfiguration</code>","text":"<p>Kemono API Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Kemono API URL scheme</p> <code>netloc</code> <code>str</code> <p>Kemono API URL netloc</p> <code>statics_netloc</code> <code>str</code> <p>URL netloc of Kemono server for static files (e.g. images)</p> <code>files_netloc</code> <code>str</code> <p>URL netloc of Kemono server for post files</p> <code>path</code> <code>str</code> <p>Kemono API URL root path</p> <code>timeout</code> <code>float</code> <p>API request timeout</p> <code>retry_times</code> <code>int</code> <p>API request retry times (when request failed)</p> <code>retry_interval</code> <code>float</code> <p>Seconds of API request retry interval</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class APIConfiguration(BaseModel):\n    \"\"\"\n    Kemono API Configuration\n\n    :ivar scheme: Kemono API URL scheme\n    :ivar netloc: Kemono API URL netloc\n    :ivar statics_netloc: URL netloc of Kemono server for static files (e.g. images)\n    :ivar files_netloc: URL netloc of Kemono server for post files\n    :ivar path: Kemono API URL root path\n    :ivar timeout: API request timeout\n    :ivar retry_times: API request retry times (when request failed)\n    :ivar retry_interval: Seconds of API request retry interval\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    netloc: str = \"kemono.su\"\n    statics_netloc: str = \"img.kemono.su\"\n    files_netloc: str = \"kemono.su\"\n    path: str = \"/api/v1\"\n    timeout: float = 5.0\n    retry_times: int = 3\n    retry_interval: float = 2.0\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.netloc","title":"<code>netloc: str = 'kemono.su'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.statics_netloc","title":"<code>statics_netloc: str = 'img.kemono.su'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.files_netloc","title":"<code>files_netloc: str = 'kemono.su'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.path","title":"<code>path: str = '/api/v1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.timeout","title":"<code>timeout: float = 5.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.retry_times","title":"<code>retry_times: int = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.APIConfiguration.retry_interval","title":"<code>retry_interval: float = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration","title":"<code>DownloaderConfiguration</code>","text":"<p>File Downloader Configuration</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>Literal['http', 'https']</code> <p>Downloader URL scheme</p> <code>timeout</code> <code>float</code> <p>Downloader request timeout</p> <code>encoding</code> <code>str</code> <p>Charset for filename parsing and post content text saving</p> <code>buffer_size</code> <code>int</code> <p>Number of bytes of file I/O buffer for each downloading file</p> <code>chunk_size</code> <code>int</code> <p>Number of bytes of chunk of downloader stream</p> <code>temp_suffix</code> <code>str</code> <p>Temp filename suffix of downloading files</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class DownloaderConfiguration(BaseModel):\n    \"\"\"\n    File Downloader Configuration\n\n    :ivar scheme: Downloader URL scheme\n    :ivar timeout: Downloader request timeout\n    :ivar encoding: Charset for filename parsing and post content text saving\n    :ivar buffer_size: Number of bytes of file I/O buffer for each downloading file\n    :ivar chunk_size: Number of bytes of chunk of downloader stream\n    :ivar temp_suffix: Temp filename suffix of downloading files\n    \"\"\"\n    scheme: Literal[\"http\", \"https\"] = \"https\"\n    timeout: float = 30.0\n    encoding: str = \"utf-8\"\n    buffer_size: int = 20480\n    chunk_size: int = 1024\n    temp_suffix: str = \"tmp\"\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.scheme","title":"<code>scheme: Literal['http', 'https'] = 'https'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.timeout","title":"<code>timeout: float = 30.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.encoding","title":"<code>encoding: str = 'utf-8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.buffer_size","title":"<code>buffer_size: int = 20480</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.chunk_size","title":"<code>chunk_size: int = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.DownloaderConfiguration.temp_suffix","title":"<code>temp_suffix: str = 'tmp'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration","title":"<code>PostStructureConfiguration</code>","text":"<p>Post path structure model</p> <ul> <li>Default: <pre><code>|-- ..\n|-- attachments\n|   |-- 1.png\n|   |-- 2.png\n|-- content.txt\n|-- &lt;Post file&gt;\n|-- &lt;Post data (post.ktoolbox.json)&gt;\n</code></pre></li> </ul> <p>Attributes:</p> Name Type Description <code>attachments</code> <code>Path</code> <p>Sub path of attachment directory</p> <code>content_filepath</code> <code>Path</code> <p>Sub path of post content HTML file</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class PostStructureConfiguration(BaseModel):\n    # noinspection SpellCheckingInspection\n    \"\"\"\n    Post path structure model\n\n    - Default:\n    ```\n    |-- ..\n    |-- attachments\n    |   |-- 1.png\n    |   |-- 2.png\n    |-- content.txt\n    |-- &lt;Post file&gt;\n    |-- &lt;Post data (post.ktoolbox.json)&gt;\n    ```\n\n    :ivar attachments: Sub path of attachment directory\n    :ivar content_filepath: Sub path of post content HTML file\n    \"\"\"\n    attachments: Path = Path(\"attachments\")\n    content_filepath: Path = Path(\"index.html\")\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration.attachments","title":"<code>attachments: Path = Path('attachments')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.PostStructureConfiguration.content_filepath","title":"<code>content_filepath: Path = Path('index.html')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration","title":"<code>JobConfiguration</code>","text":"<p>Download jobs Configuration</p> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>Number of coroutines for concurrent download</p> <code>post_id_as_path</code> <code>bool</code> <p>Use post ID as post directory name</p> <code>post_structure</code> <code>PostStructureConfiguration</code> <p>Post path structure</p> <code>mix_posts</code> <code>bool</code> <p>Save all files from different posts at same path in creator directory.     It would not create any post directory, and <code>CreatorIndices</code> would not been recorded,     without <code>CreatorIndices</code> you cannot update the creator directory.</p> <code>job_list_filepath</code> <code>Optional[Path]</code> <p>Filepath for job list data saving, <code>None</code> for disable job list saving</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class JobConfiguration(BaseModel):\n    \"\"\"\n    Download jobs Configuration\n\n    :ivar count: Number of coroutines for concurrent download\n    :ivar post_id_as_path: Use post ID as post directory name\n    :ivar post_structure: Post path structure\n    :ivar mix_posts: Save all files from different posts at same path in creator directory. \\\n    It would not create any post directory, and ``CreatorIndices`` would not been recorded, \\\n    without ``CreatorIndices`` you **cannot update** the creator directory.\n    :ivar job_list_filepath: Filepath for job list data saving, ``None`` for disable job list saving\n    \"\"\"\n    count: int = 4\n    post_id_as_path: bool = False\n    post_structure: PostStructureConfiguration = PostStructureConfiguration()\n    mix_posts: bool = False\n    job_list_filepath: Optional[Path] = None\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.count","title":"<code>count: int = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.post_id_as_path","title":"<code>post_id_as_path: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.post_structure","title":"<code>post_structure: PostStructureConfiguration = PostStructureConfiguration()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.mix_posts","title":"<code>mix_posts: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.JobConfiguration.job_list_filepath","title":"<code>job_list_filepath: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration","title":"<code>LoggerConfiguration</code>","text":"<p>Logger configuration</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Optional[Path]</code> <p>Path to save logs, <code>None</code> for disable log file output</p> <code>level</code> <code>Union[str, int]</code> <p>Log filter level</p> <code>rotation</code> <code>Union[str, int, time, timedelta]</code> <p>Log rotation</p> Source code in <code>ktoolbox/configuration.py</code> <pre><code>class LoggerConfiguration(BaseModel):\n    \"\"\"\n    Logger configuration\n\n    :ivar path: Path to save logs, ``None`` for disable log file output\n    :ivar level: Log filter level\n    :ivar rotation: Log rotation\n    \"\"\"\n    path: Optional[Path] = Path(\"logs\")\n    level: Union[str, int] = logging.DEBUG\n    rotation: Union[str, int, datetime.time, datetime.timedelta] = \"1 week\"\n</code></pre>"},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration.path","title":"<code>path: Optional[Path] = Path('logs')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration.level","title":"<code>level: Union[str, int] = logging.DEBUG</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"configuration/reference/#ktoolbox.configuration.LoggerConfiguration.rotation","title":"<code>rotation: Union[str, int, datetime.time, datetime.timedelta] = '1 week'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"zh/","title":"\u6b22\u8fce\u4f7f\u7528 KToolBox","text":"KToolBox  <p>   KToolBox \u662f\u4e00\u4e2a\u7528\u4e8e\u4e0b\u8f7d   Kemono.party / Kemono.su   \u4e2d\u4f5c\u54c1\u5185\u5bb9\u7684\u5b9e\u7528\u547d\u4ee4\u884c\u5de5\u5177 </p> <p> </p> <p></p>"},{"location":"zh/#_1","title":"\u529f\u80fd","text":"<ul> <li>\u652f\u6301 \u591a\u7ebf\u7a0b \u4e0b\u8f7d\uff08\u6280\u672f\u4e0a\u662f\u534f\u7a0b\uff09</li> <li>\u652f\u6301\u4e0b\u8f7d\u5355\u4e2a\u4f5c\u54c1\u4ee5\u53ca\u6307\u5b9a\u7684\u753b\u5e08\u7684 \u6240\u6709\u4f5c\u54c1</li> <li>\u53ef \u66f4\u65b0\u5df2\u4e0b\u8f7d \u7684\u753b\u5e08\u76ee\u5f55\u81f3\u6700\u65b0\u72b6\u6001</li> <li>\u53ef\u81ea\u5b9a\u4e49\u4e0b\u8f7d\u7684\u4f5c\u54c1/\u753b\u5e08 \u76ee\u5f55\u7ed3\u6784</li> <li>\u53ef\u641c\u7d22\u753b\u5e08\u548c\u4f5c\u54c1\uff0c\u5e76 \u5bfc\u51fa\u7ed3\u679c</li> <li>\u652f\u6301\u5168\u5e73\u53f0\uff0c\u5e76\u63d0\u4f9b iOS \u5feb\u6377\u6307\u4ee4</li> </ul>"},{"location":"zh/#_2","title":"\u4f7f\u7528\u65b9\u6cd5","text":""},{"location":"zh/#_3","title":"\u5b89\u88c5","text":"\u4e00\u822c\u60c5\u51b5\u5bf9\u4e8e iOS a-Shell <pre><code>pip3 install ktoolbox\n</code></pre> <pre><code>pip3 install ktoolbox-pure-py\n</code></pre> <p>\u5173\u4e8e a-Shell</p> <p>a-Shell \u662f\u4e00\u4e2a iOS \u7ec8\u7aef App\uff0c\u5b83\u53ea\u80fd\u8fd0\u884c\u7eaf Python \u811a\u672c</p>"},{"location":"zh/#_4","title":"\u547d\u4ee4","text":"<p>\u4f7f\u7528\u5e2e\u52a9\u547d\u4ee4\u6216\u524d\u5f80 \u547d\u4ee4 \u9875\u9762\u67e5\u770b\u66f4\u591a\u5e2e\u52a9\u3002</p>"},{"location":"zh/#_5","title":"\u2753 \u83b7\u53d6\u5e2e\u52a9\u603b\u89c8","text":"<pre><code>ktoolbox -h\n</code></pre>"},{"location":"zh/#_6","title":"\u2753 \u83b7\u53d6\u67d0\u4e2a\u547d\u4ee4\u7684\u5e2e\u52a9\u4fe1\u606f","text":"<pre><code>ktoolbox download-post -h\n</code></pre>"},{"location":"zh/#_7","title":"\u2b07\ufe0f\ud83d\uddbc\ufe0f \u4e0b\u8f7d\u6307\u5b9a\u7684\u4f5c\u54c1","text":"<pre><code>ktoolbox download-post https://kemono.su/fanbox/user/49494721/post/6608808\n</code></pre> \u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25 <p>\u5982\u679c\u90e8\u5206\u6587\u4ef6\u4e0b\u8f7d\u5931\u8d25\uff0c\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u91cd\u65b0\u8fd0\u884c\u547d\u4ee4\uff0c\u5df2\u4e0b\u8f7d\u5b8c\u6210\u7684\u6587\u4ef6\u4f1a\u88ab \u8df3\u8fc7\u3002</p>"},{"location":"zh/#_8","title":"\u2b07\ufe0f\ud83d\udd8c\ufe0f \u4e0b\u8f7d\u4f5c\u8005\u7684\u6240\u6709\u4f5c\u54c1","text":"<pre><code>ktoolbox sync-creator https://kemono.su/fanbox/user/9016\n</code></pre> \u8f93\u51fa <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4f60\u4f1a\u5728\u4f5c\u8005\u76ee\u5f55\u4e0b\u5f97\u5230\u4e00\u4e2a <code>creator-indices.ktoolbox</code> \u6587\u4ef6\uff0c\u4f60\u53ef\u4ee5\u7528\u5b83\u6765\u66f4\u65b0\u76ee\u5f55\u3002</p>"},{"location":"zh/#_9","title":"\ud83d\udd04\ufe0f \u66f4\u65b0\u4e00\u4e2a\u4f5c\u8005\u76ee\u5f55","text":"<pre><code>ktoolbox sync-creator https://kemono.su/fanbox/user/641955 --update-with=./xxx/creator-indices.ktoolbox\n</code></pre> \u5173\u4e8e <code>creator-indices.ktoolbox</code> \u6587\u4ef6 <p><code>creator-indices.ktoolbox</code> \u5305\u542b\u76ee\u5f55\u4e0b\u7684\u6240\u6709\u4f5c\u54c1\u7684\u4fe1\u606f\u548c\u8def\u5f84\u3002</p>"},{"location":"zh/about-kemono/","title":"\u5173\u4e8e Kemono","text":"<p>\u5b98\u7f51 https://kemono.su \u7684\u4ecb\u7ecd\uff1a</p> <p>Kemono is a public archiver for:</p> <ul> <li>Patreon</li> <li>Pixiv Fanbox</li> <li>Discord</li> <li>Fantia</li> <li>Afdian</li> <li>Boosty</li> <li>DLsite</li> <li>Gumroad</li> <li>SubscribeStar</li> </ul> <p>Contributors here upload content and share it here for easy searching and organization. \\ To get started viewing content, either search for creators on the artists page, or search for content on the posts page.</p>"},{"location":"zh/api/","title":"API \u6587\u6863","text":""},{"location":"zh/commands/","title":"\u547d\u4ee4","text":"<p>\u7528\u6cd5</p> <p>\u524d\u5f80 \u547d\u4ee4</p> Source code in <code>ktoolbox/cli.py</code> <pre><code>class KToolBoxCli:\n    @staticmethod\n    async def version():\n        \"\"\"Show KToolBox version\"\"\"\n        return __version__\n\n    @staticmethod\n    async def site_version():\n        # noinspection SpellCheckingInspection\n        \"\"\"Show current Kemono site app commit hash\"\"\"\n        ret = await get_app_version()\n        return ret.data if ret else ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator(\n            name: str = None,\n            id: str = None,\n            service: str = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await search_creator_action(id=id, name=name, service=service)\n        if ret:\n            result_list = list(ret.data)\n            if dump:\n                await dump_search(result_list, dump)\n            return result_list or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    # noinspection PyShadowingBuiltins\n    @staticmethod\n    async def search_creator_post(\n            id: str = None,\n            name: str = None,\n            service: str = None,\n            q: str = None,\n            o: int = None,\n            *,\n            dump: Path = None\n    ):\n        \"\"\"\n        Search posts from creator, you can use multiple parameters as keywords.\n\n        :param id: The ID of the creator\n        :param name: The name of the creator\n        :param service: The service for the creator\n        :param q: Search query\n        :param o: Result offset, stepping of 50 is enforced\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await search_creator_post_action(id=id, name=name, service=service, q=q, o=o)\n        if ret:\n            if dump:\n                await dump_search(ret.data, dump)\n            return ret.data or TextEnum.SearchResultEmpty.value\n        else:\n            return ret.message\n\n    @staticmethod\n    async def get_post(service: str, creator_id: str, post_id: str, *, dump: Path = None):\n        \"\"\"\n        Get a specific post\n\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param dump: Dump the result to a JSON file\n        \"\"\"\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            if dump:\n                async with aiofiles.open(str(dump), \"w\", encoding=\"utf-8\") as f:\n                    await f.write(\n                        ret.data.model_dump_json(indent=config.json_dump_indent)\n                    )\n            return ret.data\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def download_post(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def download_post(\n            service: str,\n            creator_id: str,\n            post_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        ...\n\n    @staticmethod\n    async def download_post(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            post_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            dump_post_data=True\n    ):\n        \"\"\"\n        Download a specific post\n\n        :param url: The post URL\n        :param service: The service name\n        :param creator_id: The creator's ID\n        :param post_id: The post ID\n        :param path: Download path, default is current directory\n        :param dump_post_data: Whether to dump post data (post.json) in post directory\n        \"\"\"\n        # Get service, creator_id, post_id\n        if url:\n            service, creator_id, post_id = parse_webpage_url(url)\n        if not all([service, creator_id, post_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\", \"post_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        ret = await get_post_api(\n            service=service,\n            creator_id=creator_id,\n            post_id=post_id\n        )\n        if ret:\n            post_path = path / ret.data.id if config.job.post_id_as_path else path / sanitize_filename(ret.data.title)\n            job_list = await create_job_from_post(\n                post=ret.data,\n                post_path=post_path,\n                dump_post_data=dump_post_data\n            )\n            job_runner = JobRunner(job_list=job_list)\n            await job_runner.start()\n        else:\n            return ret.message\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            url: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Path = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        ...\n\n    @staticmethod\n    @overload\n    async def sync_creator(\n            service: str,\n            creator_id: str,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Path = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        ...\n\n    @staticmethod\n    async def sync_creator(\n            url: str = None,\n            service: str = None,\n            creator_id: str = None,\n            path: Union[Path, str] = Path(\".\"),\n            *,\n            update_from: Union[Path, str] = None,\n            save_creator_indices: bool = True,\n            mix_posts: bool = None\n    ):\n        \"\"\"\n        Sync all posts from a creator\n\n        You can update the directory anytime after download finished, \\\n        such as to update after creator published new posts.\n\n        * If ``update_from`` was provided, it should be located **inside the creator directory**.\n\n        :param url: The post URL\n        :param service: The service where the post is located\n        :param creator_id: The ID of the creator\n        :param path: Download path, default is current directory\n        :param update_from: ``CreatorIndices`` data path for update posts from current creator directory, \\\n         ``save_creator_indices`` will be enabled if this provided\n        :param save_creator_indices: Record ``CreatorIndices`` data for update posts from current creator directory\n        :param mix_posts: Save all files from different posts at same path, \\\n         ``update_from``, ``save_creator_indices`` will be ignored if enabled\n        \"\"\"\n        # Get service, creator_id\n        if url:\n            service, creator_id, _ = parse_webpage_url(url)\n        if not all([service, creator_id]):\n            return generate_msg(\n                TextEnum.MissingParams.value,\n                use_at_lease_one=[\n                    [\"url\"],\n                    [\"service\", \"creator_id\"]\n                ])\n\n        path = path if isinstance(path, Path) else Path(path)\n        if update_from:\n            update_from = update_from if isinstance(update_from, Path) else Path(update_from)\n\n        # Get ``CreatorIndices`` data\n        if update_from:\n            async with aiofiles.open(update_from, encoding=\"utf-8\") as f:\n                indices_text = await f.read()\n            indices = CreatorIndices.model_validate_json(indices_text)\n            creator_path = update_from.parent\n        else:\n            indices = None\n\n            # Get creator name\n            creator_name = creator_id\n            creator_ret = await search_creator_action(id=creator_id, service=service)\n            if creator_ret:\n                creator = next(creator_ret.data, None)\n                if creator:\n                    creator_name = creator.name\n                    logger.info(\n                        generate_msg(\n                            \"Got creator information\",\n                            name=creator.name,\n                            id=creator.id\n                        )\n                    )\n            else:\n                logger.warning(\n                    generate_msg(\n                        f\"Failed to fetch the name of creator &lt;{creator_id}&gt;, use creator ID as directory name\",\n                        detail=creator_ret.message\n                    )\n                )\n            creator_path = path / sanitize_filename(creator_name)\n\n        creator_path.mkdir(exist_ok=True)\n        ret = await create_job_from_creator(\n            service=service,\n            creator_id=creator_id,\n            path=creator_path,\n            update_from=indices,\n            all_pages=True,\n            save_creator_indices=save_creator_indices,\n            mix_posts=mix_posts\n        )\n        if ret:\n            job_runner = JobRunner(job_list=ret.data)\n            await job_runner.start()\n        else:\n            return ret.message\n</code></pre>"},{"location":"zh/faq/","title":"\u5e38\u89c1\u95ee\u9898","text":""},{"location":"zh/faq/#uvloop","title":"\u5982\u4f55\u89e3\u51b3 uvloop \u5b89\u88c5\u5931\u8d25\u7684\u95ee\u9898\uff1f","text":"<p>\u8fd9\u662f\u53ef\u9009\u7684</p> <p>uvloop \u53ef\u4ee5\u63d0\u9ad8\u5e76\u53d1\u6027\u80fd\uff0c\u4f46\u5b83\u662f \u53ef\u9009\u7684\u3002\u5982\u679c\u4f60\u4e0d\u60f3\u5b89\u88c5 uvloop\uff0c\u4f60\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e2a\u6b65\u9aa4\u3002</p> <p>uvloop \u5728 Windows \u4e0a \u4e0d\u53d7\u652f\u6301\u3002\u5982\u679c\u4f60\u5728 Linux \u6216 macOS \u5b89\u88c5\u5931\u8d25\uff0c  \u4f60\u53ef\u4ee5\u5c1d\u8bd5\u7528\u4f8b\u5982 apt\u3001yum\u3001brew \u7684\u7cfb\u7edf\u5305\u7ba1\u7406\u5668\u5b89\u88c5\uff0c\u5305\u7ba1\u7406\u5668\u63d0\u4f9b\u6784\u5efa\u597d\u7684 uvloop \u5305\u3002</p> <ul> <li>\u4f7f\u7528 apt \u5b89\u88c5     <pre><code>sudo apt install python3-uvloop\n</code></pre></li> </ul>"},{"location":"zh/faq/#attachments","title":"\u6211\u4e0d\u9700\u8981\u4f5c\u54c1\u76ee\u5f55\u4e0b\u7684 <code>attachments</code> \u6587\u4ef6\u5939","text":"<p>\u4f60\u53ef\u4ee5\u8bbe\u7f6e\u914d\u7f6e\u9009\u9879 <code>job.post_structure.attachments</code> \u4e3a <code>./</code></p> <p>\u901a\u8fc7 dotenv\u6587\u4ef6 <code>prod.env</code> \u6216\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u6765\u8bbe\u7f6e\u914d\u7f6e\uff1a <pre><code>KTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n</code></pre></p> <p><code>./</code> \u8868\u793a\u9644\u4ef6\u6587\u4ef6\u5c06\u4f1a\u76f4\u63a5\u4e0b\u8f7d\u5230\u4f5c\u54c1\u76ee\u5f55\u4e0b\u3002</p> <p>\u63d0\u793a</p> <p>\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u8003 \u914d\u7f6e-\u5411\u5bfc \u9875\u9762\u3002</p>"},{"location":"zh/faq/#-_","title":"\u547d\u4ee4\u548c\u6807\u5fd7\uff08\u9009\u9879\uff09\u5e94\u5f53\u4f7f\u7528 <code>-</code> \u8fd8\u662f <code>_</code> \u4f5c\u4e3a\u5206\u9694\u7b26\uff1f","text":"<p>\u4e24\u8005\u90fd\u652f\u6301\uff0c\u63a8\u8350\u4f7f\u7528 <code>-</code>\u3002</p>"},{"location":"zh/more/","title":"\u66f4\u591a","text":""},{"location":"zh/more/#_2","title":"\u5176\u4ed6\u5206\u652f","text":"<ul> <li>\u7eaf Python \u5206\u652f\uff1a\ud83d\udd17pure-py</li> </ul> <p>\u5173\u4e8e</p> <ul> <li>\u4f7f\u7528 pydantic v1 \u56e0\u6b64\u5b89\u88c5\u65f6\u4e0d\u9700\u8981 cargo</li> <li>\u4f8b\u5982\u4f60\u53ef\u4ee5\u5728 iOS \u7684\u7ec8\u7aef App a-Shell \u8fd0\u884c</li> <li>\ud83d\udd17PyPI</li> </ul> <ul> <li>\u5f00\u53d1\u7248\u5206\u652f\uff1a\ud83d\udd17devel</li> </ul>"},{"location":"zh/more/#_3","title":"\u4ee3\u7801\u8986\u76d6\u7387","text":""},{"location":"zh/more/#_4","title":"\u8bb8\u53ef\u8bc1","text":"<p>KToolBox \u4f7f\u7528 MIT \u8bb8\u53ef\u8bc1.</p> <p>Copyright \u00a9 2023 by Ljzd-PRO.</p>"},{"location":"zh/shortcut/","title":"iOS \u5feb\u6377\u6307\u4ee4","text":"<p>\u4f60\u53ef\u4ee5\u5728 iOS \u7ec8\u7aef App a-Shell \u8fd0\u884c KToolBox\uff0c\u4e0b\u5217\u5feb\u6377\u6307\u4ee4\u53ef\u4ee5\u5e2e\u52a9\u4f60\u81ea\u52a8\u5b8c\u6210 KToolBox \u7684\u5b89\u88c5\u4ee5\u53ca\u4f5c\u54c1\u4e0b\u8f7d</p>"},{"location":"zh/shortcut/#_1","title":"\u83b7\u53d6\u5feb\u6377\u6307\u4ee4","text":"<p>\u8bbf\u95ee\u4e0b\u9762\u7684\u5feb\u6377\u6307\u4ee4 URL \u6216\u524d\u5f80 <code>shortcuts/</code> \u4e0b\u8f7d\u5feb\u6377\u6307\u4ee4\u6587\u4ef6</p>"},{"location":"zh/shortcut/#_2","title":"\u82f1\u6587","text":"<ul> <li>KToolBox Manager</li> <li>Download Kemono Post</li> </ul>"},{"location":"zh/shortcut/#_3","title":"\u4e2d\u6587","text":"<ul> <li>KToolBox \u7ba1\u7406\u5668</li> <li>\u4e0b\u8f7d Kemono \u4f5c\u54c1</li> </ul>"},{"location":"zh/shortcut/#_4","title":"\u7528\u6cd5","text":"<ul> <li>\u4f7f\u7528 \u201cKToolBox \u7ba1\u7406\u5668\u201d \u4ee5\u5728 a-Shell \u4e2d \u5b89\u88c5\u3001\u66f4\u65b0\u3001\u5378\u8f7d KToolBox</li> <li>\u4f60\u53ef\u4ee5\u901a\u8fc7\u7f51\u9875\u5171\u4eab\u754c\u9762\u89e6\u53d1\u201c\u4e0b\u8f7d Kemono \u4f5c\u54c1\u201d\uff0c\u6216\u76f4\u63a5\u5728\u5feb\u6377\u6307\u4ee4 App \u8fd0\u884c</li> </ul>"},{"location":"zh/configuration/guide/","title":"\u5411\u5bfc","text":"<ul> <li>KToolBox \u8bfb\u53d6\u5de5\u4f5c\u76ee\u5f55\u4e0b\u7684 <code>prod.env</code> \u6587\u4ef6 \u6216 \u73af\u5883\u53d8\u91cf \u6765\u8bbe\u5b9a\u914d\u7f6e</li> <li>\u524d\u5f80 \u53c2\u8003 \u67e5\u770b\u6240\u6709\u914d\u7f6e\u9009\u9879</li> <li>\u7528 <code>__</code> \u6765\u6307\u5b9a\u5b50\u9009\u9879, \u4f8b\u5982 <code>KTOOLBOX_API__SCHEME</code> \u76f8\u5f53\u4e8e <code>api.scheme</code></li> <li>\u6240\u6709\u914d\u7f6e\u9009\u9879\u90fd\u662f\u53ef\u9009\u7684</li> </ul>"},{"location":"zh/configuration/guide/#prodenv","title":"<code>prod.env</code> \u6587\u4ef6\u793a\u4f8b","text":"<pre><code># \u53ef\u540c\u65f6\u4e0b\u8f7d10\u4e2a\u6587\u4ef6\nKTOOLBOX_JOB__COUNT=10\n\n# \u4e3a\u6bcf\u4e2a\u4e0b\u8f7d\u4efb\u52a1\u5206\u914d 102400 \u5b57\u8282\u5185\u5b58\u4f5c\u4e3a\u7f13\u51b2\u533a\nKTOOLBOX_DOWNLOADER__BUFFER_SIZE=102400\n\n# \u8bbe\u7f6e\u4f5c\u54c1\u9644\u4ef6\u76ee\u5f55\u4e3a `./`, \u8fd9\u610f\u5473\u7740\u6240\u6709\u9644\u4ef6\u5c06\u76f4\u63a5\u4fdd\u5b58\u5728\u4f5c\u54c1\u76ee\u5f55\u4e0b\n# \u800c\u4e0d\u4f1a\u521b\u5efa\u4e00\u4e2a\u5b50\u76ee\u5f55\u6765\u50a8\u5b58\nKTOOLBOX_JOB__POST_STRUCTURE__ATTACHMENTS=./\n\n# \u4e3aKemono API\u670d\u52a1\u5668\u548c\u4e0b\u8f7d\u670d\u52a1\u5668\u7981\u7528SSL\u8bc1\u4e66\u68c0\u67e5\n# \u5728Kemono\u670d\u52a1\u5668\u7684\u8bc1\u4e66\u8fc7\u671f\u65f6\u5f88\u6709\u7528 \uff08SSL: CERTIFICATE_VERIFY_FAILED\uff09\nKTOOLBOX_SSL_VERIFY=False\n</code></pre>"},{"location":"zh/configuration/reference/","title":"\u53c2\u8003","text":""}]}